<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>行川居</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingchuan.vip/"/>
  <updated>2019-08-30T08:31:56.060Z</updated>
  <id>http://www.xingchuan.vip/</id>
  
  <author>
    <name>川总</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>28.Linux学习日常(四)</title>
    <link href="http://www.xingchuan.vip/28.Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8(%E5%9B%9B).html"/>
    <id>http://www.xingchuan.vip/28.Linux学习日常(四).html</id>
    <published>2019-08-30T10:31:00.000Z</published>
    <updated>2019-08-30T08:31:56.060Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h5 id="上一章我们在Linux上成功安装了MySQL，并且可以在本机连接，这一章我们学习把Java项目部署到Linux上，这也是我们开发人员必会的技能之一。"><a href="#上一章我们在Linux上成功安装了MySQL，并且可以在本机连接，这一章我们学习把Java项目部署到Linux上，这也是我们开发人员必会的技能之一。" class="headerlink" title="上一章我们在Linux上成功安装了MySQL，并且可以在本机连接，这一章我们学习把Java项目部署到Linux上，这也是我们开发人员必会的技能之一。"></a>上一章我们在Linux上成功安装了MySQL，并且可以在本机连接，这一章我们学习把Java项目部署到Linux上，这也是我们开发人员必会的技能之一。</h5><hr><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h5 id="因为现在的主流是springboot，所以之后都是以springboot项目为例。"><a href="#因为现在的主流是springboot，所以之后都是以springboot项目为例。" class="headerlink" title="因为现在的主流是springboot，所以之后都是以springboot项目为例。"></a>因为现在的主流是springboot，所以之后都是以springboot项目为例。</h5><h4 id="创建springboot项目，编写接口hello，输出helloworld。"><a href="#创建springboot项目，编写接口hello，输出helloworld。" class="headerlink" title="创建springboot项目，编写接口hello，输出helloworld。"></a>创建springboot项目，编写接口hello，输出helloworld。</h4><h5 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String sayHello()&#123;</span><br><span class="line">        return &quot;hello world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进入idea控制台，输出打包命令"><a href="#进入idea控制台，输出打包命令" class="headerlink" title="进入idea控制台，输出打包命令"></a>进入idea控制台，输出打包命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br><span class="line"></span><br><span class="line">打包完成后显示:</span><br><span class="line">[INFO] Replacing main artifact with repackaged archive</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  3.944 s</span><br><span class="line">[INFO] Finished at: 2019-08-30T09:06:02+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h4 id="打包完成后再target目录下会有jar包，因为springboot内置tomcat，我们只需要把jar包上传到Linux启动即可。"><a href="#打包完成后再target目录下会有jar包，因为springboot内置tomcat，我们只需要把jar包上传到Linux启动即可。" class="headerlink" title="打包完成后再target目录下会有jar包，因为springboot内置tomcat，我们只需要把jar包上传到Linux启动即可。"></a>打包完成后再target目录下会有jar包，因为springboot内置tomcat，我们只需要把jar包上传到Linux启动即可。</h4><h4 id="进入usr-local-src-，创建project目录"><a href="#进入usr-local-src-，创建project目录" class="headerlink" title="进入usr/local/src/，创建project目录"></a>进入usr/local/src/，创建project目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/src/project</span><br></pre></td></tr></table></figure><h4 id="通过Xshell把jar包上传到此目录，输入下面命令启动"><a href="#通过Xshell把jar包上传到此目录，输入下面命令启动" class="headerlink" title="通过Xshell把jar包上传到此目录，输入下面命令启动"></a>通过Xshell把jar包上传到此目录，输入下面命令启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar 你的名字.jar &gt;temp.txt 2&gt;&amp;1&amp;</span><br><span class="line"></span><br><span class="line">Linux中0、1和2分别表示标准输入、标准输出和标准错误信息输出，可以用来指定需要重定向的标准输入或输出。在一般使用时，默认的是标准输出，即1。</span><br><span class="line">例如：2&gt;temp.txt 就是将错误信息写入temp.txt 标准输出还是显示在屏幕上。</span><br></pre></td></tr></table></figure><h4 id="最后可以在本机通过ip访问项目，输出helloworld"><a href="#最后可以在本机通过ip访问项目，输出helloworld" class="headerlink" title="最后可以在本机通过ip访问项目，输出helloworld"></a>最后可以在本机通过ip访问项目，输出helloworld</h4><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h5 id="通过这几章学习，我们完成了在Linux上配置java环境、安装MySQL，部署项目三部曲，通过这些，我们也练习了Linux的常用命令，后面我们继续学习Nginx和Docker，完成一个互联网程序员的基本技术栈，尽情期待！"><a href="#通过这几章学习，我们完成了在Linux上配置java环境、安装MySQL，部署项目三部曲，通过这些，我们也练习了Linux的常用命令，后面我们继续学习Nginx和Docker，完成一个互联网程序员的基本技术栈，尽情期待！" class="headerlink" title="通过这几章学习，我们完成了在Linux上配置java环境、安装MySQL，部署项目三部曲，通过这些，我们也练习了Linux的常用命令，后面我们继续学习Nginx和Docker，完成一个互联网程序员的基本技术栈，尽情期待！"></a>通过这几章学习，我们完成了在Linux上配置java环境、安装MySQL，部署项目三部曲，通过这些，我们也练习了Linux的常用命令，后面我们继续学习<strong>Nginx</strong>和<strong>Docker</strong>，完成一个互联网程序员的基本技术栈，尽情期待！</h5><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;h5 id=&quot;
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://www.xingchuan.vip/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>27.Linux学习日常(三)</title>
    <link href="http://www.xingchuan.vip/27.Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8(%E4%B8%89).html"/>
    <id>http://www.xingchuan.vip/27.Linux学习日常(三).html</id>
    <published>2019-08-29T16:41:00.000Z</published>
    <updated>2019-08-29T09:31:12.888Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h5 id="上一章我们通过在linux安装jdk来练习linux的基本命令，同时为之后的学习做好准备工作，这一章我们通过在linux继续安装mysql来深入练习命令，也是为后面学习做好准备工作。"><a href="#上一章我们通过在linux安装jdk来练习linux的基本命令，同时为之后的学习做好准备工作，这一章我们通过在linux继续安装mysql来深入练习命令，也是为后面学习做好准备工作。" class="headerlink" title="上一章我们通过在linux安装jdk来练习linux的基本命令，同时为之后的学习做好准备工作，这一章我们通过在linux继续安装mysql来深入练习命令，也是为后面学习做好准备工作。"></a>上一章我们通过在linux安装jdk来练习linux的基本命令，同时为之后的学习做好准备工作，这一章我们通过在linux继续安装mysql来深入练习命令，也是为后面学习做好准备工作。</h5><hr><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><blockquote><p>这里又可以多学几条命令了！</p></blockquote><h5 id="查看centOS7的防火墙状态："><a href="#查看centOS7的防火墙状态：" class="headerlink" title="查看centOS7的防火墙状态："></a>查看centOS7的防火墙状态：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status  firewalld</span><br><span class="line">如果看到active(running)说明防火墙打开。</span><br></pre></td></tr></table></figure><h5 id="关闭防火墙："><a href="#关闭防火墙：" class="headerlink" title="关闭防火墙："></a>关闭防火墙：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld</span><br><span class="line">如果看到状态为inacive(dead)就意味关闭了。</span><br></pre></td></tr></table></figure><h5 id="打开防火墙"><a href="#打开防火墙" class="headerlink" title="打开防火墙"></a>打开防火墙</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start firewalld</span><br></pre></td></tr></table></figure><h6 id="上面的命令都是临时关闭防火墙，重启后又会恢复到默认状态"><a href="#上面的命令都是临时关闭防火墙，重启后又会恢复到默认状态" class="headerlink" title="上面的命令都是临时关闭防火墙，重启后又会恢复到默认状态"></a>上面的命令都是临时关闭防火墙，重启后又会恢复到默认状态</h6><h5 id="永久关闭防火墙"><a href="#永久关闭防火墙" class="headerlink" title="永久关闭防火墙"></a>永久关闭防火墙</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl disable firewalld</span><br></pre></td></tr></table></figure><h4 id="从mysql官网上下载适合自己的mysql版本"><a href="#从mysql官网上下载适合自己的mysql版本" class="headerlink" title="从mysql官网上下载适合自己的mysql版本"></a>从mysql官网上下载适合自己的mysql版本</h4><h5 id="下载地址：https-dev-mysql-com-downloads-mysql-5-6-html-downloads"><a href="#下载地址：https-dev-mysql-com-downloads-mysql-5-6-html-downloads" class="headerlink" title="下载地址：https://dev.mysql.com/downloads/mysql/5.6.html#downloads"></a>下载地址：<a href="https://dev.mysql.com/downloads/mysql/5.6.html#downloads" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/5.6.html#downloads</a></h5><h5 id="本人选择下载的是：-mysql-5-6-45-linux-glibc2-12-x86-64-tar-gz"><a href="#本人选择下载的是：-mysql-5-6-45-linux-glibc2-12-x86-64-tar-gz" class="headerlink" title="本人选择下载的是： mysql-5.6.45-linux-glibc2.12-x86_64.tar.gz"></a>本人选择下载的是： mysql-5.6.45-linux-glibc2.12-x86_64.tar.gz</h5><hr><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><h5 id="打开Xshell，连接虚拟机"><a href="#打开Xshell，连接虚拟机" class="headerlink" title="打开Xshell，连接虚拟机"></a>打开Xshell，连接虚拟机</h5><h5 id="在usr-local-src-在创建mysql目录"><a href="#在usr-local-src-在创建mysql目录" class="headerlink" title="在usr/local/src/在创建mysql目录"></a>在usr/local/src/在创建mysql目录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/src/mysql</span><br></pre></td></tr></table></figure><h5 id="把下载好的mysql压缩文件上传到linux上，并压缩"><a href="#把下载好的mysql压缩文件上传到linux上，并压缩" class="headerlink" title="把下载好的mysql压缩文件上传到linux上，并压缩"></a>把下载好的mysql压缩文件上传到linux上，并压缩</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf mysql-5.6.45-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure><h5 id="压缩完成后重命名为mysql"><a href="#压缩完成后重命名为mysql" class="headerlink" title="压缩完成后重命名为mysql"></a>压缩完成后重命名为mysql</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv mysql-5.6.45-linux-glibc2.12-x86_64.tar.gz mysql</span><br></pre></td></tr></table></figure><h5 id="创建mysql用户组及用户"><a href="#创建mysql用户组及用户" class="headerlink" title="创建mysql用户组及用户"></a>创建mysql用户组及用户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -r -g mysql mysql</span><br></pre></td></tr></table></figure><h5 id="进入mysql目录里，执行添加MySQL配置的操作"><a href="#进入mysql目录里，执行添加MySQL配置的操作" class="headerlink" title="进入mysql目录里，执行添加MySQL配置的操作"></a>进入mysql目录里，执行添加MySQL配置的操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp support-files/my-default.cnf/etc/my.cnf</span><br><span class="line">提示是否覆盖，按Y，回车</span><br></pre></td></tr></table></figure><h5 id="编辑-etc-my-cnf文件"><a href="#编辑-etc-my-cnf文件" class="headerlink" title="编辑/etc/my.cnf文件"></a>编辑/etc/my.cnf文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br></pre></td></tr></table></figure><h5 id="按i进入编辑模式，按esc输入：wq保存退出"><a href="#按i进入编辑模式，按esc输入：wq保存退出" class="headerlink" title="按i进入编辑模式，按esc输入：wq保存退出"></a>按i进入编辑模式，按esc输入：wq保存退出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># For advice on how to change settings please see</span><br><span class="line"># http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html</span><br><span class="line"># *** DO NOT EDIT THIS FILE. It&apos;s a template which will be copied to the</span><br><span class="line"># *** default location during install, and will be replaced if you</span><br><span class="line"># *** upgrade to a newer version of MySQL.</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line"># Remove leading # and set to the amount of RAM for the most important data</span><br><span class="line"># cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</span><br><span class="line"># innodb_buffer_pool_size = 128M</span><br><span class="line"></span><br><span class="line"># Remove leading # to turn on a very important data integrity option: logging</span><br><span class="line"># changes to the binary log between backups.</span><br><span class="line"># log_bin</span><br><span class="line"></span><br><span class="line"># These are commonly set, remove the # and set as required.</span><br><span class="line">basedir = /usr/local/src/mysql/mysql</span><br><span class="line">datadir = /usr/local/src/mysql/mysql/data</span><br><span class="line">port = 3306</span><br><span class="line"># server_id = .....</span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line">character-set-server = utf8</span><br><span class="line">skip-name-resolve</span><br><span class="line">log-error = /usr/local/src/mysql/mysql/data/error.log</span><br><span class="line">pid-file = /usr/local/src/mysql/mysql/data/mysql.pid</span><br><span class="line">explicit_defaults_for_timestamp=true</span><br><span class="line"></span><br><span class="line"># Remove leading # to set options mainly useful for reporting servers.</span><br><span class="line"># The server defaults are faster for transactions and fast SELECTs.</span><br><span class="line"># Adjust sizes as needed, experiment to find the optimal values.</span><br><span class="line"># join_buffer_size = 128M</span><br><span class="line"># sort_buffer_size = 2M</span><br><span class="line"># read_rnd_buffer_size = 2M</span><br></pre></td></tr></table></figure><h5 id="在mysql当前目录下设定目录的访问权限"><a href="#在mysql当前目录下设定目录的访问权限" class="headerlink" title="在mysql当前目录下设定目录的访问权限"></a>在mysql当前目录下设定目录的访问权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql .</span><br><span class="line">chgrp -R mysql .</span><br><span class="line">scripts/mysql_install_db --user=mysql</span><br><span class="line">chown -R root .</span><br><span class="line">chown -R mysql data</span><br></pre></td></tr></table></figure><h5 id="初始化数据，进入mysql-scripts目录下，执行下面命令"><a href="#初始化数据，进入mysql-scripts目录下，执行下面命令" class="headerlink" title="初始化数据，进入mysql/scripts目录下，执行下面命令"></a>初始化数据，进入mysql/scripts目录下，执行下面命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysql_install_db --verbose --user=root --defaults-file=/etc/my.cnf --datadir=/usr/local/src/mysql/mysql/data --basedir=/usr/local/src/mysql/mysql --pid-file=/usr/local/src/mysql/mysql/data/mysql.pid --tmpdir=/tmp</span><br></pre></td></tr></table></figure><h5 id="启动mysql，进入-usr-local-src-mysql-mysql-bin目录，执行下面命令"><a href="#启动mysql，进入-usr-local-src-mysql-mysql-bin目录，执行下面命令" class="headerlink" title="启动mysql，进入/usr/local/src/mysql/mysql/bin目录，执行下面命令:"></a>启动mysql，进入/usr/local/src/mysql/mysql/bin目录，执行下面命令:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysqld_safe --defaults-file=/etc/my.cnf --socket=/tmp/mysql.sock --user=root &amp;</span><br></pre></td></tr></table></figure><h5 id="设置开机启动，进入mysql命令，执行下面命令。"><a href="#设置开机启动，进入mysql命令，执行下面命令。" class="headerlink" title="设置开机启动，进入mysql命令，执行下面命令。"></a>设置开机启动，进入mysql命令，执行下面命令。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/src/mysql/mysql//support-files/mysql.server /etc/init.d/mysqld</span><br><span class="line">cp /usr/local/src/mysql/mysql//support-files/mysql.server /etc/rc.d/init.d/mysql</span><br><span class="line"></span><br><span class="line">chmod 700 /etc/init.d/mysql</span><br><span class="line">chkconfig --add mysqld</span><br><span class="line">chkconfig --level 2345 mysqld on</span><br><span class="line">chown mysql:mysql -R /usr/local/src/mysql/mysql/</span><br></pre></td></tr></table></figure><h5 id="重启linux"><a href="#重启linux" class="headerlink" title="重启linux"></a>重启linux</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h5 id="查看mysql状态"><a href="#查看mysql状态" class="headerlink" title="查看mysql状态"></a>查看mysql状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld status</span><br></pre></td></tr></table></figure><h4 id="接下来我们就可以通过本地的navicat连接虚拟机的数据库了，达到了最终的效果。"><a href="#接下来我们就可以通过本地的navicat连接虚拟机的数据库了，达到了最终的效果。" class="headerlink" title="接下来我们就可以通过本地的navicat连接虚拟机的数据库了，达到了最终的效果。"></a>接下来我们就可以通过本地的navicat连接虚拟机的数据库了，达到了最终的效果。</h4><hr><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="修改mysql密码"><a href="#修改mysql密码" class="headerlink" title="修改mysql密码"></a>修改mysql密码</h4><blockquote><ul><li>在mysql系统外，使用mysqladmin</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root -p password &quot;test123&quot;</span><br><span class="line">Enter password: [输入原来旧密码]</span><br></pre></td></tr></table></figure><blockquote><ul><li>通过登录MySQL系统</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot  -p</span><br><span class="line">Enter password:[原来的密码]</span><br><span class="line">mysql&gt;use mysql;</span><br><span class="line">mysql&gt;update user set password=password(&quot;test)&quot; where user=&apos;root&apos;;</span><br><span class="line">mysql&gt;exit;</span><br></pre></td></tr></table></figure><h6 id="然后重启MySQL服务。"><a href="#然后重启MySQL服务。" class="headerlink" title="然后重启MySQL服务。"></a>然后重启MySQL服务。</h6><h4 id="Linux下开启、关闭、重启MySQL服务"><a href="#Linux下开启、关闭、重启MySQL服务" class="headerlink" title="Linux下开启、关闭、重启MySQL服务"></a>Linux下开启、关闭、重启MySQL服务</h4><h5 id="启动："><a href="#启动：" class="headerlink" title="启动："></a>启动：</h5><blockquote><ul><li>使用 service 启动：service mysql start</li><li>使用 mysqld 脚本启动：/etc/inint.d/mysql start</li><li>使用 safe_mysqld 启动：safe_mysql&amp;</li></ul></blockquote><h5 id="停止："><a href="#停止：" class="headerlink" title="停止："></a>停止：</h5><blockquote><ul><li>使用service启动：service mysql stop</li><li>使用mysqld 脚本启动：/etc/inint.d/mysql stop</li><li>mysqladmin shutdowm</li></ul></blockquote><h5 id="重启："><a href="#重启：" class="headerlink" title="重启："></a>重启：</h5><blockquote><ul><li>使用service启动：service mysql restart</li><li>使用mysqld脚本启动：/etc/inint.d/mysql restart</li></ul></blockquote><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h5 id="本章我们完成了在linux上安装MySQL数据库，并且可以在本机连接，同时又学习了一些新的指令，下一章我们会学习把java项目部署到linux上，并且可以远程访问，敬请期待"><a href="#本章我们完成了在linux上安装MySQL数据库，并且可以在本机连接，同时又学习了一些新的指令，下一章我们会学习把java项目部署到linux上，并且可以远程访问，敬请期待" class="headerlink" title="本章我们完成了在linux上安装MySQL数据库，并且可以在本机连接，同时又学习了一些新的指令，下一章我们会学习把java项目部署到linux上，并且可以远程访问，敬请期待!"></a>本章我们完成了在linux上安装MySQL数据库，并且可以在本机连接，同时又学习了一些新的指令，下一章我们会学习把java项目部署到linux上，并且可以远程访问，敬请期待!</h5><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;h5 id=&quot;
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://www.xingchuan.vip/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>26.Linux学习日常(二)</title>
    <link href="http://www.xingchuan.vip/26.Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8(%E4%BA%8C).html"/>
    <id>http://www.xingchuan.vip/26.Linux学习日常(二).html</id>
    <published>2019-08-29T14:40:00.000Z</published>
    <updated>2019-08-29T07:19:02.620Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h5 id="上一章，我们主要安装好了Linux，学习了基础的指令，这一章我们通过在linux上安装java环境来熟悉下常用执行。"><a href="#上一章，我们主要安装好了Linux，学习了基础的指令，这一章我们通过在linux上安装java环境来熟悉下常用执行。" class="headerlink" title="上一章，我们主要安装好了Linux，学习了基础的指令，这一章我们通过在linux上安装java环境来熟悉下常用执行。"></a>上一章，我们主要安装好了Linux，学习了基础的指令，这一章我们通过在linux上安装java环境来熟悉下常用执行。</h5><hr><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h4><blockquote><p>Linux系统版本：CentOS 7 64位</p></blockquote><blockquote><p>终端模拟器：Xshell 6</p></blockquote><blockquote><p>Java版本：jdk-8u221-linux-x64</p></blockquote><h4 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h4><h5 id="下载地址：https-www-oracle-com-technetwork-java-javase-downloads-jdk8-downloads-2133151-html"><a href="#下载地址：https-www-oracle-com-technetwork-java-javase-downloads-jdk8-downloads-2133151-html" class="headerlink" title="下载地址：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html"></a>下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></h5><h5 id="选择jdk-8u221-linux-x64-tar-gz下载"><a href="#选择jdk-8u221-linux-x64-tar-gz下载" class="headerlink" title="选择jdk-8u221-linux-x64.tar.gz下载"></a>选择jdk-8u221-linux-x64.tar.gz下载</h5><hr><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><h4 id="打开Xshell，连接虚拟机。"><a href="#打开Xshell，连接虚拟机。" class="headerlink" title="打开Xshell，连接虚拟机。"></a>打开Xshell，连接虚拟机。</h4><h4 id="检查系统是否已经安装jdk"><a href="#检查系统是否已经安装jdk" class="headerlink" title="检查系统是否已经安装jdk"></a>检查系统是否已经安装jdk</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><h5 id="如果出现以下命令，则表示已经安装"><a href="#如果出现以下命令，则表示已经安装" class="headerlink" title="如果出现以下命令，则表示已经安装"></a>如果出现以下命令，则表示已经安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version &quot;1.8.0_181&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_181-b13)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.181-b13, mixed mode)</span><br></pre></td></tr></table></figure><h4 id="进入usr-local-src下"><a href="#进入usr-local-src下" class="headerlink" title="进入usr/local/src下"></a>进入usr/local/src下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/</span><br></pre></td></tr></table></figure><h4 id="通过Xshell把下载好的jdk上传到mysql目录，使用下面命令解压"><a href="#通过Xshell把下载好的jdk上传到mysql目录，使用下面命令解压" class="headerlink" title="通过Xshell把下载好的jdk上传到mysql目录，使用下面命令解压"></a>通过Xshell把下载好的jdk上传到mysql目录，使用下面命令解压</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /usr/local/src/jdk-8u221-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h4 id="解压后更改文件名为java"><a href="#解压后更改文件名为java" class="headerlink" title="解压后更改文件名为java"></a>解压后更改文件名为java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/local/src/jdk1.8.0_181 /usr/local/src/java</span><br></pre></td></tr></table></figure><h4 id="修改配置文件，配置环境变量"><a href="#修改配置文件，配置环境变量" class="headerlink" title="修改配置文件，配置环境变量"></a>修改配置文件，配置环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure><h4 id="输入”G”定位到最后一行，按i进入编辑模式，添加下面几行信息："><a href="#输入”G”定位到最后一行，按i进入编辑模式，添加下面几行信息：" class="headerlink" title="输入”G”定位到最后一行，按i进入编辑模式，添加下面几行信息："></a>输入”G”定位到最后一行，按i进入编辑模式，添加下面几行信息：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br></pre></td></tr></table></figure><h4 id="按esc退出编辑模式。输入：wq后回车保存退出"><a href="#按esc退出编辑模式。输入：wq后回车保存退出" class="headerlink" title="按esc退出编辑模式。输入：wq后回车保存退出"></a>按esc退出编辑模式。输入：wq后回车保存退出</h4><h4 id="让配置文件失效，可以输入以下命令或者重启系统"><a href="#让配置文件失效，可以输入以下命令或者重启系统" class="headerlink" title="让配置文件失效，可以输入以下命令或者重启系统"></a>让配置文件失效，可以输入以下命令或者重启系统</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">重启命令：</span><br><span class="line">init 6</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h4 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a>检查是否安装成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -verson</span><br><span class="line"></span><br><span class="line">openjdk version &quot;1.8.0_181&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_181-b13)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.181-b13, mixed mode)</span><br></pre></td></tr></table></figure><h4 id="删除tar包"><a href="#删除tar包" class="headerlink" title="删除tar包"></a>删除tar包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm- rf /usr/local/src/java</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h5 id="本章主要通过安装jdk来练习linux命令，也是为之后部署java项目到linux服务器上做好准备工作，下一章，我们将在linux上安装mysql数据库，敬请期待！"><a href="#本章主要通过安装jdk来练习linux命令，也是为之后部署java项目到linux服务器上做好准备工作，下一章，我们将在linux上安装mysql数据库，敬请期待！" class="headerlink" title="本章主要通过安装jdk来练习linux命令，也是为之后部署java项目到linux服务器上做好准备工作，下一章，我们将在linux上安装mysql数据库，敬请期待！"></a>本章主要通过安装jdk来练习linux命令，也是为之后部署java项目到linux服务器上做好准备工作，下一章，我们将在linux上安装mysql数据库，敬请期待！</h5><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;h5 id=&quot;
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://www.xingchuan.vip/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>25.Linux学习日常(一)</title>
    <link href="http://www.xingchuan.vip/25.Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8(%E4%B8%80).html"/>
    <id>http://www.xingchuan.vip/25.Linux学习日常(一).html</id>
    <published>2019-08-29T10:51:00.000Z</published>
    <updated>2019-08-29T03:30:15.968Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h5 id="入行一年有余，Linux一直是本人的痛点，因为工作的两家公司服务器都window系统，所以一直没有机会深入了解和使用，现在趁工作之余去学习下，也为后面的挑战提前做好准备。"><a href="#入行一年有余，Linux一直是本人的痛点，因为工作的两家公司服务器都window系统，所以一直没有机会深入了解和使用，现在趁工作之余去学习下，也为后面的挑战提前做好准备。" class="headerlink" title="入行一年有余，Linux一直是本人的痛点，因为工作的两家公司服务器都window系统，所以一直没有机会深入了解和使用，现在趁工作之余去学习下，也为后面的挑战提前做好准备。"></a>入行一年有余，Linux一直是本人的痛点，因为工作的两家公司服务器都window系统，所以一直没有机会深入了解和使用，现在趁工作之余去学习下，也为后面的挑战提前做好准备。</h5><h5 id="话不多说，我们开始学习！"><a href="#话不多说，我们开始学习！" class="headerlink" title="话不多说，我们开始学习！"></a>话不多说，我们开始学习！</h5><hr><h3 id="什么是Linux？"><a href="#什么是Linux？" class="headerlink" title="什么是Linux？"></a>什么是Linux？</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h4><blockquote><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p></blockquote><blockquote><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p></blockquote><blockquote><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p></blockquote><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><blockquote><ul><li>开源</li><li>多用户多任务</li><li>良好的用户界面</li><li>优异的性能与稳定性</li></ul></blockquote><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><blockquote><ul><li>ubuntu</li><li>debian</li><li>centos</li><li>redhat</li><li>suse等</li></ul></blockquote><hr><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><h4 id="安装方式："><a href="#安装方式：" class="headerlink" title="安装方式："></a>安装方式：</h4><h5 id="真机安装：就和安装windows系统一个。"><a href="#真机安装：就和安装windows系统一个。" class="headerlink" title="真机安装：就和安装windows系统一个。"></a>真机安装：就和安装windows系统一个。</h5><h5 id="虚拟机安装：通过一些特定手段，进行模拟安装并使用。"><a href="#虚拟机安装：通过一些特定手段，进行模拟安装并使用。" class="headerlink" title="虚拟机安装：通过一些特定手段，进行模拟安装并使用。"></a>虚拟机安装：通过一些特定手段，进行模拟安装并使用。</h5><h6 id="如果是学习或者测试使用，建议使用虚拟机安装方式，比如我。"><a href="#如果是学习或者测试使用，建议使用虚拟机安装方式，比如我。" class="headerlink" title="如果是学习或者测试使用，建议使用虚拟机安装方式，比如我。"></a>如果是学习或者测试使用，建议使用虚拟机安装方式，比如我。</h6><h4 id="虚拟机安装："><a href="#虚拟机安装：" class="headerlink" title="虚拟机安装："></a>虚拟机安装：</h4><h5 id="比较热门的产品有vmware-workstation和virtual-Box。"><a href="#比较热门的产品有vmware-workstation和virtual-Box。" class="headerlink" title="比较热门的产品有vmware workstation和virtual Box。"></a>比较热门的产品有vmware workstation和virtual Box。</h5><h5 id="本人选择了vmware-workstation，你们可以百度破解自行安装。"><a href="#本人选择了vmware-workstation，你们可以百度破解自行安装。" class="headerlink" title="本人选择了vmware workstation，你们可以百度破解自行安装。"></a>本人选择了vmware workstation，你们可以百度破解自行安装。</h5><h4 id="镜像安装“"><a href="#镜像安装“" class="headerlink" title="镜像安装“"></a>镜像安装“</h4><h5 id="版本选择："><a href="#版本选择：" class="headerlink" title="版本选择："></a>版本选择：</h5><blockquote><p>CentOS 7，因为目前主流为7.x，公司使用人数也是最多。</p></blockquote><h5 id="下载地址：https-www-centos-org-。"><a href="#下载地址：https-www-centos-org-。" class="headerlink" title="下载地址：https://www.centos.org/。"></a>下载地址：<a href="https://www.centos.org/。" target="_blank" rel="noopener">https://www.centos.org/。</a></h5><blockquote><ul><li>本人选择下载：CentOS-7-x86_64-DVD-1810.iso 版本。</li></ul></blockquote><h4 id="VMwear安装Centos7超详细过程"><a href="#VMwear安装Centos7超详细过程" class="headerlink" title="VMwear安装Centos7超详细过程"></a>VMwear安装Centos7超详细过程</h4><blockquote><ul><li>这里我推荐一个文章给大家，他写的非常详细，我就不重复造轮子了。</li></ul></blockquote><h5 id="链接地址：https-www-jianshu-com-p-ce08cdbc4ddb-utm-source-tuicool-amp-utm-medium-referral"><a href="#链接地址：https-www-jianshu-com-p-ce08cdbc4ddb-utm-source-tuicool-amp-utm-medium-referral" class="headerlink" title="链接地址：https://www.jianshu.com/p/ce08cdbc4ddb?utm_source=tuicool&amp;utm_medium=referral"></a>链接地址：<a href="https://www.jianshu.com/p/ce08cdbc4ddb?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.jianshu.com/p/ce08cdbc4ddb?utm_source=tuicool&amp;utm_medium=referral</a></h5><h4 id="安装Xshell："><a href="#安装Xshell：" class="headerlink" title="安装Xshell："></a>安装Xshell：</h4><h5 id="下载地址：http-www-121down-com-soft-softview-102857-html"><a href="#下载地址：http-www-121down-com-soft-softview-102857-html" class="headerlink" title="下载地址：http://www.121down.com/soft/softview-102857.html"></a>下载地址：<a href="http://www.121down.com/soft/softview-102857.html" target="_blank" rel="noopener">http://www.121down.com/soft/softview-102857.html</a></h5><hr><h3 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h3><h4 id="指令与选项"><a href="#指令与选项" class="headerlink" title="指令与选项"></a>指令与选项</h4><blockquote><ul><li>在Linux终端输入的内容称之为指令。</li><li>通用格式： #指令主体(空格)<a href="空格">选项</a>[操作对象]</li></ul></blockquote><h4 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h4><h5 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h5><blockquote><p>作用：列出当前工作目录下的所有文件/文件夹的名称</p></blockquote><blockquote><p>语法：</p><blockquote><ul><li><strong>#ls</strong> //列出当前工作目录下的所有文件/文件夹的名称</li><li><strong>#ls 路径</strong> //列出指定路径下的所有文件/文件夹的名称</li><li><strong>#ls 选项 路径</strong> //在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示。</li><li><strong>#ls -lh 路径</strong> //列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的时候可读性较高的显示。</li></ul></blockquote></blockquote><h5 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a>pwd指令</h5><blockquote><p>语法：<strong>#pwd</strong> 打印当前工作目录</p></blockquote><h5 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h5><blockquote><p>作用： 用于切换当前的工作目录</p></blockquote><blockquote><p>语法：</p><blockquote><ul><li><strong>#cd 路径</strong> //路径为绝对路径</li><li><strong>#cd ~</strong> //表示进入当前用户家目录</li></ul></blockquote></blockquote><h5 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h5><blockquote><p>作用：创建目录<br>语法：</p><blockquote><ul><li><strong>mkdir 路径</strong> //路径可以是文件夹名称也可以是包含名称的一个完整路径</li><li><strong>mkdir -p 路径</strong> //当一次性创建多层不存在的目录时，记得添加-p参数，否则会报错</li><li><strong>#mkdir 路径1 路径2 路径3…</strong> //一次性创建多个目录</li></ul></blockquote></blockquote><h5 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h5><blockquote><p>作用：创建文件<br>语法： <strong>#touch 文件路径</strong> //路径可是文件名也可以是路径</p></blockquote><h5 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a>cp指令</h5><blockquote><p>作用：复制文件/文件夹到指定目录，也可以对文件进行重命名。<br>语法：</p><blockquote><ul><li><strong>#cp 原路径 目标路径</strong></li><li><strong>#cp -r 原路径 目标路径</strong> //递归复制，用来复制文件夹。</li></ul></blockquote></blockquote><h5 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h5><blockquote><p>作用：移动文档到新的位置</p></blockquote><blockquote><p>语法： <strong>#mv 原路径 目标路径</strong></p></blockquote><h5 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h5><blockquote><p>作用：移除/删除文档<br>语法：</p><blockquote><ul><li><strong>rm 文件路径</strong></li><li><strong>rm -f</strong> //强制删除</li><li><strong>rm -r</strong> //递归删除</li></ul></blockquote></blockquote><h5 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h5><blockquote><p>作用：打开一个文件<br>语法：、</p><blockquote><ul><li><strong>#cat 文件的路径</strong></li><li><strong>#cat 待合并的文件路径1 待合并的文件路径2 ….文件路径n &gt; 合并之后的文件路径</strong></li></ul></blockquote></blockquote><h5 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h5><blockquote><p>作用：查看一个文件的前n行，如果不指定n，则默认为前10行。<br>语法：**#head -n 文件路径</p></blockquote><h5 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h5><blockquote><p>作用：查看一个文件的末n行，如果n不指定默认显示后10行。<br>语法: #tail -n 文件路径</p></blockquote><h5 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h5><blockquote><p>作用：查看文件，以较少的内容进行输出<br>语法：<strong>#less 需要查看的文件路径</strong></p></blockquote><h5 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h5><blockquote><p>作用：压缩和打包<br>语法：</p><blockquote><ul><li><strong>tar zxvf xxxxx.tar</strong>//解包</li><li><strong>tar czvf xxxxx.tar DirName</strong>` //打包</li></ul></blockquote></blockquote><h5 id="gz命令"><a href="#gz命令" class="headerlink" title="gz命令"></a>gz命令</h5><blockquote><p>作用：解压和压缩<br>语法:</p><blockquote><ul><li><strong>gunzip FileName.gz</strong> //解压</li><li><strong>gzip -d FileName.gz</strong><br>//解压</li><li><strong>gzip FileName</strong> //压缩</li><li><strong>tar zcvf FileName.tar.gz DirName1 DirName2 DirName3</strong></li></ul></blockquote></blockquote><hr><h3 id="常用系统命令"><a href="#常用系统命令" class="headerlink" title="常用系统命令"></a>常用系统命令</h3><h4 id="查看ip"><a href="#查看ip" class="headerlink" title="查看ip"></a>查看ip</h4><blockquote><ul><li><strong>ifconfig</strong></li></ul></blockquote><h4 id="重启指令"><a href="#重启指令" class="headerlink" title="重启指令"></a>重启指令</h4><blockquote><ul><li><strong>reboot</strong></li><li><strong>shutdown -r now</strong> 立即重启</li><li><strong>shutdown -r 5</strong> 5分钟后重启</li><li><strong>shutdown -r 10:30</strong> 在时间没10.30时候重启</li></ul></blockquote><h4 id="关机指令"><a href="#关机指令" class="headerlink" title="关机指令"></a>关机指令</h4><blockquote><ul><li><strong>init 0</strong></li><li><strong>halt</strong></li><li><strong>poweroff</strong></li><li><strong>shutdown -h now</strong> 立刻关机</li><li><strong>shutdown -h 5</strong> 5分钟后自动关机</li></ul></blockquote><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h5 id="第一章主要学习什么是linux、linux以及相关软件的安装，还有了解linux的基本指令和常用指令。下一章我们将通过实践，进一步了练习linux操作，熟练使用这些指令。"><a href="#第一章主要学习什么是linux、linux以及相关软件的安装，还有了解linux的基本指令和常用指令。下一章我们将通过实践，进一步了练习linux操作，熟练使用这些指令。" class="headerlink" title="第一章主要学习什么是linux、linux以及相关软件的安装，还有了解linux的基本指令和常用指令。下一章我们将通过实践，进一步了练习linux操作，熟练使用这些指令。"></a>第一章主要学习什么是linux、linux以及相关软件的安装，还有了解linux的基本指令和常用指令。下一章我们将通过实践，进一步了练习linux操作，熟练使用这些指令。</h5><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;h5 id=&quot;
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://www.xingchuan.vip/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>24.Sharding-jdbc分库分表</title>
    <link href="http://www.xingchuan.vip/24.Sharding-jdbc%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html"/>
    <id>http://www.xingchuan.vip/24.Sharding-jdbc分库分表.html</id>
    <published>2019-08-26T10:02:00.000Z</published>
    <updated>2019-08-26T02:40:40.365Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="一、Sharding-jdbc简介"><a href="#一、Sharding-jdbc简介" class="headerlink" title="一、Sharding-jdbc简介"></a>一、Sharding-jdbc简介</h3><blockquote><ul><li>Sharding-JDBC是Sharding-Sphere的一个产品，它有三个产品，分别是Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar，这三个产品提供了标准化的数据分片、读写分离、柔性事务和数据治理功能。我们这里用的是Sharding-JDBC，所以想了解后面两个产品的话可以去它们官网查看。</li></ul></blockquote><blockquote><ul><li>Sharding-JDBC为轻量级Java框架，使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，兼容性特别强。适用的ORM框架有JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC；第三方的数据库连接池有DBCP, C3P0, BoneCP, Druid等；支持的数据库有MySQL，Oracle，SQLServer和PostgreSQL；多样化的配置文件Java，yaml，Spring Boot ，Spring命名空间。其实这里说的都是废话，大家可以不看，下面我们动手开始正式配置。</li></ul></blockquote><hr><h3 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h3><h4 id="数据库准备："><a href="#数据库准备：" class="headerlink" title="数据库准备："></a>数据库准备：</h4><h5 id="准备两个数据库：database0和database1，每个数据库都有两个表goods-0-goods-1，表结构都一样。"><a href="#准备两个数据库：database0和database1，每个数据库都有两个表goods-0-goods-1，表结构都一样。" class="headerlink" title="准备两个数据库：database0和database1，每个数据库都有两个表goods_0,goods_1，表结构都一样。"></a>准备两个数据库：database0和database1，每个数据库都有两个表goods_0,goods_1，表结构都一样。</h5><h6 id="建表sql"><a href="#建表sql" class="headerlink" title="建表sql:"></a>建表sql:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SET FOREIGN_KEY_CHECKS=0;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for goods_0</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `goods_0`;</span><br><span class="line">CREATE TABLE `goods_0` (</span><br><span class="line">  `goods_id` bigint(20) NOT NULL,</span><br><span class="line">  `goods_name` varchar(100) DEFAULT NULL,</span><br><span class="line">  `goods_type` bigint(20) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`goods_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for goods_1</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `goods_1`;</span><br><span class="line">CREATE TABLE `goods_1` (</span><br><span class="line">  `goods_id` bigint(20) NOT NULL,</span><br><span class="line">  `goods_name` varchar(100) DEFAULT NULL,</span><br><span class="line">  `goods_type` bigint(20) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`goods_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h4 id="项目相关配置："><a href="#项目相关配置：" class="headerlink" title="项目相关配置："></a>项目相关配置：</h4><h6 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml:"></a>web.xml:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.cz&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc-demo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;sharding-jdbc-demo&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">        &lt;sharding.jdbc.version&gt;3.0.0&lt;/sharding.jdbc.version&gt;</span><br><span class="line">        &lt;mybatis.version&gt;1.2.0&lt;/mybatis.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- lombok --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- druid --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.9&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- sharding-jdbc --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.dangdang&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;sharding-jdbc-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.5.4&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h6 id="application-xml"><a href="#application-xml" class="headerlink" title="application.xml:"></a>application.xml:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">##jpa设置</span><br><span class="line">spring:</span><br><span class="line">  jpa:</span><br><span class="line">    database: mysql</span><br><span class="line">    show-sql: true</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: none</span><br><span class="line"></span><br><span class="line">##数据库配置</span><br><span class="line">##数据库database0地址</span><br><span class="line">database0:</span><br><span class="line">  url: jdbc:mysql://localhost:3306/database0?characterEncoding=utf8&amp;useSSL=false</span><br><span class="line">  username: root</span><br><span class="line">  password: root</span><br><span class="line">  driverClassName: com.mysql.cj.jdbc.Driver</span><br><span class="line">  databaseName: database0</span><br><span class="line"></span><br><span class="line">##数据库database1地址</span><br><span class="line">database1:</span><br><span class="line">  url: jdbc:mysql://localhost:3306/database1?characterEncoding=utf8&amp;useSSL=false</span><br><span class="line">  username: root</span><br><span class="line">  password: root</span><br><span class="line">  driverClassName: com.mysql.cj.jdbc.Driver</span><br><span class="line">  databaseName: database1</span><br></pre></td></tr></table></figure><hr><h3 id="三、开发"><a href="#三、开发" class="headerlink" title="三、开发"></a>三、开发</h3><h4 id="创建实体类："><a href="#创建实体类：" class="headerlink" title="创建实体类："></a>创建实体类：</h4><blockquote><ul><li>这里使用Jpa开发。</li></ul></blockquote><h5 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import javax.persistence.Entity;</span><br><span class="line">import javax.persistence.Id;</span><br><span class="line">import javax.persistence.Table;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ClassName: Goods</span><br><span class="line"> * @date: 2019/8/20  9:36</span><br><span class="line"> * @author: guohao</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;goods&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class Goods &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    private Long goodsId;</span><br><span class="line"></span><br><span class="line">    private String goodsName;</span><br><span class="line"></span><br><span class="line">    private Long goodsType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建仓库："><a href="#创建仓库：" class="headerlink" title="创建仓库："></a>创建仓库：</h4><h5 id="自定义两个接口：findAllByGoodsIdBetween和findAllByGoodsIdIn"><a href="#自定义两个接口：findAllByGoodsIdBetween和findAllByGoodsIdIn" class="headerlink" title="自定义两个接口：findAllByGoodsIdBetween和findAllByGoodsIdIn"></a>自定义两个接口：findAllByGoodsIdBetween和findAllByGoodsIdIn</h5><h5 id="核心代码：-1"><a href="#核心代码：-1" class="headerlink" title="核心代码："></a>核心代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import com.cz.shardingjdbcdemo.entity.Goods;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ClassName: GoodsRepository</span><br><span class="line"> * @date: 2019/8/20  9:40</span><br><span class="line"> * @author: guohao</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">public interface GoodsRepository extends JpaRepository&lt;Goods,Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Goods&gt; findAllByGoodsIdBetween(Long goodsId1, Long goodsId2);</span><br><span class="line"></span><br><span class="line">    List&lt;Goods&gt; findAllByGoodsIdIn(List&lt;Long&gt; goodsIds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据库和分库分表相关的配置类："><a href="#数据库和分库分表相关的配置类：" class="headerlink" title="数据库和分库分表相关的配置类："></a>数据库和分库分表相关的配置类：</h4><h5 id="创建Database0的配置类："><a href="#创建Database0的配置类：" class="headerlink" title="创建Database0的配置类："></a>创建Database0的配置类：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ClassName: Database0Config</span><br><span class="line"> * @date: 2019/8/20  9:44</span><br><span class="line"> * @author: guohao</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@ConfigurationProperties(prefix = &quot;database0&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class Database0Config &#123;</span><br><span class="line"></span><br><span class="line">    private String url;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private String driverClassName;</span><br><span class="line">    private String databaseName;</span><br><span class="line"></span><br><span class="line">    public DataSource createDataSource() &#123;</span><br><span class="line">        DruidDataSource result = new DruidDataSource();</span><br><span class="line">        result.setDriverClassName(getDriverClassName());</span><br><span class="line">        result.setUrl(getUrl());</span><br><span class="line">        result.setUsername(getUsername());</span><br><span class="line">        result.setPassword(getPassword());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建Database1的配置类："><a href="#创建Database1的配置类：" class="headerlink" title="创建Database1的配置类："></a>创建Database1的配置类：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ClassName: Database1Config</span><br><span class="line"> * @date: 2019/8/20  9:46</span><br><span class="line"> * @author: guohao</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@ConfigurationProperties(prefix = &quot;database1&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class Database1Config &#123;</span><br><span class="line"></span><br><span class="line">    private String url;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private String driverClassName;</span><br><span class="line">    private String databaseName;</span><br><span class="line"></span><br><span class="line">    public DataSource createDataSource() &#123;</span><br><span class="line">        DruidDataSource result = new DruidDataSource();</span><br><span class="line">        result.setDriverClassName(getDriverClassName());</span><br><span class="line">        result.setUrl(getUrl());</span><br><span class="line">        result.setUsername(getUsername());</span><br><span class="line">        result.setPassword(getPassword());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建分表策略TableShardingAlgorithm的配置类："><a href="#创建分表策略TableShardingAlgorithm的配置类：" class="headerlink" title="创建分表策略TableShardingAlgorithm的配置类："></a>创建分表策略TableShardingAlgorithm的配置类：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import com.dangdang.ddframe.rdb.sharding.api.ShardingValue;</span><br><span class="line">import com.dangdang.ddframe.rdb.sharding.api.strategy.table.SingleKeyTableShardingAlgorithm;</span><br><span class="line">import com.google.common.collect.Range;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.LinkedHashSet;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这里使用的都是单键分片策略</span><br><span class="line"> * 示例分表策略是：</span><br><span class="line"> * GoodsType为奇数使用goods_1表</span><br><span class="line"> * GoodsType为偶数使用goods_0表</span><br><span class="line"> * @author yangyang</span><br><span class="line"> * @date 2019/1/30</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class TableShardingAlgorithm implements SingleKeyTableShardingAlgorithm&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String doEqualSharding(final Collection&lt;String&gt; tableNames, final ShardingValue&lt;Long&gt; shardingValue) &#123;</span><br><span class="line">        for (String each : tableNames) &#123;</span><br><span class="line">            if (each.endsWith(shardingValue.getValue() % 2 + &quot;&quot;)) &#123;</span><br><span class="line">                return each;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;String&gt; doInSharding(final Collection&lt;String&gt; tableNames, final ShardingValue&lt;Long&gt; shardingValue) &#123;</span><br><span class="line">        Collection&lt;String&gt; result = new LinkedHashSet&lt;&gt;(tableNames.size());</span><br><span class="line">        for (Long value : shardingValue.getValues()) &#123;</span><br><span class="line">            for (String tableName : tableNames) &#123;</span><br><span class="line">                if (tableName.endsWith(value % 2 + &quot;&quot;)) &#123;</span><br><span class="line">                    result.add(tableName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;String&gt; doBetweenSharding(final Collection&lt;String&gt; tableNames,</span><br><span class="line">                                                final ShardingValue&lt;Long&gt; shardingValue) &#123;</span><br><span class="line">        Collection&lt;String&gt; result = new LinkedHashSet&lt;&gt;(tableNames.size());</span><br><span class="line">        Range&lt;Long&gt; range = shardingValue.getValueRange();</span><br><span class="line">        for (Long i = range.lowerEndpoint(); i &lt;= range.upperEndpoint(); i++) &#123;</span><br><span class="line">            for (String each : tableNames) &#123;</span><br><span class="line">                if (each.endsWith(i % 2 + &quot;&quot;)) &#123;</span><br><span class="line">                    result.add(each);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建分库策略DatabaseShardingAlgorithm配置类："><a href="#创建分库策略DatabaseShardingAlgorithm配置类：" class="headerlink" title="创建分库策略DatabaseShardingAlgorithm配置类："></a>创建分库策略DatabaseShardingAlgorithm配置类：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">import com.dangdang.ddframe.rdb.sharding.api.ShardingValue;</span><br><span class="line">import com.dangdang.ddframe.rdb.sharding.api.strategy.database.SingleKeyDatabaseShardingAlgorithm;</span><br><span class="line">import com.google.common.collect.Range;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.LinkedHashSet;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这里使用的都是单键分片策略</span><br><span class="line"> * 示例分库策略是：</span><br><span class="line"> * GoodsId&lt;=20使用database0库</span><br><span class="line"> * 其余使用database1库</span><br><span class="line"> * @author guohao</span><br><span class="line"> * @date 2019/1/30</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class DatabaseShardingAlgorithm implements SingleKeyDatabaseShardingAlgorithm&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Database0Config database0Config;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Database1Config database1Config;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String doEqualSharding(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;Long&gt; shardingValue) &#123;</span><br><span class="line">        Long value = shardingValue.getValue();</span><br><span class="line">        if (value &lt;= 20L) &#123;</span><br><span class="line">            return database0Config.getDatabaseName();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return database1Config.getDatabaseName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;String&gt; doInSharding(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;Long&gt; shardingValue) &#123;</span><br><span class="line">        Collection&lt;String&gt; result = new LinkedHashSet&lt;&gt;(availableTargetNames.size());</span><br><span class="line">        for (Long value : shardingValue.getValues()) &#123;</span><br><span class="line">            if (value &lt;= 20L) &#123;</span><br><span class="line">                result.add(database0Config.getDatabaseName());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result.add(database1Config.getDatabaseName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;String&gt; doBetweenSharding(Collection&lt;String&gt; availableTargetNames,</span><br><span class="line">                                                ShardingValue&lt;Long&gt; shardingValue) &#123;</span><br><span class="line">        Collection&lt;String&gt; result = new LinkedHashSet&lt;&gt;(availableTargetNames.size());</span><br><span class="line">        Range&lt;Long&gt; range = shardingValue.getValueRange();</span><br><span class="line">        for (Long value = range.lowerEndpoint(); value &lt;= range.upperEndpoint(); value++) &#123;</span><br><span class="line">            if (value &lt;= 20L) &#123;</span><br><span class="line">                result.add(database0Config.getDatabaseName());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result.add(database1Config.getDatabaseName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建数据库DataSourceConfig配置类："><a href="#创建数据库DataSourceConfig配置类：" class="headerlink" title="创建数据库DataSourceConfig配置类："></a>创建数据库DataSourceConfig配置类：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">import com.dangdang.ddframe.rdb.sharding.api.ShardingDataSourceFactory;</span><br><span class="line">import com.dangdang.ddframe.rdb.sharding.api.rule.DataSourceRule;</span><br><span class="line">import com.dangdang.ddframe.rdb.sharding.api.rule.ShardingRule;</span><br><span class="line">import com.dangdang.ddframe.rdb.sharding.api.rule.TableRule;</span><br><span class="line">import com.dangdang.ddframe.rdb.sharding.api.strategy.database.DatabaseShardingStrategy;</span><br><span class="line">import com.dangdang.ddframe.rdb.sharding.api.strategy.table.TableShardingStrategy;</span><br><span class="line">import com.dangdang.ddframe.rdb.sharding.keygen.DefaultKeyGenerator;</span><br><span class="line">import com.dangdang.ddframe.rdb.sharding.keygen.KeyGenerator;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">/**</span><br><span class="line"> * @ClassName: DataSourceConfig</span><br><span class="line"> * @date: 2019/8/20  9:47</span><br><span class="line"> * @author: guohao</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class DataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Database0Config database0Config;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Database1Config database1Config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DatabaseShardingAlgorithm databaseShardingAlgorithm;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TableShardingAlgorithm tableShardingAlgorithm;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource getDataSource() throws SQLException &#123;</span><br><span class="line">        return buildDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private DataSource buildDataSource() throws SQLException &#123;</span><br><span class="line">        //分库设置</span><br><span class="line">        Map&lt;String, DataSource&gt; dataSourceMap = new HashMap&lt;&gt;(2);</span><br><span class="line">        //添加两个数据库database0和database1</span><br><span class="line">        dataSourceMap.put(database0Config.getDatabaseName(), database0Config.createDataSource());</span><br><span class="line">        dataSourceMap.put(database1Config.getDatabaseName(), database1Config.createDataSource());</span><br><span class="line">        //设置默认数据库</span><br><span class="line">        DataSourceRule dataSourceRule = new DataSourceRule(dataSourceMap, database0Config.getDatabaseName());</span><br><span class="line"></span><br><span class="line">        //分表设置，大致思想就是将查询虚拟表Goods根据一定规则映射到真实表中去</span><br><span class="line">        TableRule orderTableRule = TableRule.builder(&quot;goods&quot;)</span><br><span class="line">                .actualTables(Arrays.asList(&quot;goods_0&quot;, &quot;goods_1&quot;))</span><br><span class="line">                .dataSourceRule(dataSourceRule)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        //分库分表策略</span><br><span class="line">        ShardingRule shardingRule = ShardingRule.builder()</span><br><span class="line">                .dataSourceRule(dataSourceRule)</span><br><span class="line">                .tableRules(Arrays.asList(orderTableRule))</span><br><span class="line">                .databaseShardingStrategy(new DatabaseShardingStrategy(&quot;goods_id&quot;, databaseShardingAlgorithm))</span><br><span class="line">                .tableShardingStrategy(new TableShardingStrategy(&quot;goods_type&quot;, tableShardingAlgorithm)).build();</span><br><span class="line">        DataSource dataSource = ShardingDataSourceFactory.createDataSource(shardingRule);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public KeyGenerator keyGenerator() &#123;</span><br><span class="line">        return new DefaultKeyGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、示例验证"><a href="#四、示例验证" class="headerlink" title="四、示例验证"></a>四、示例验证</h3><h4 id="编写controller代码："><a href="#编写controller代码：" class="headerlink" title="编写controller代码："></a>编写controller代码：</h4><h5 id="为了方便，这里省去了serviceImpl和service类，真实项目不可以省去。"><a href="#为了方便，这里省去了serviceImpl和service类，真实项目不可以省去。" class="headerlink" title="为了方便，这里省去了serviceImpl和service类，真实项目不可以省去。"></a>为了方便，这里省去了serviceImpl和service类，真实项目不可以省去。</h5><h5 id="核心代码；"><a href="#核心代码；" class="headerlink" title="核心代码；"></a>核心代码；</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import com.cz.shardingjdbcdemo.dao.GoodsRepository;</span><br><span class="line">import com.cz.shardingjdbcdemo.entity.Goods;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import com.dangdang.ddframe.rdb.sharding.keygen.KeyGenerator;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ClassName: GoodsController</span><br><span class="line"> * @date: 2019/8/20  9:54</span><br><span class="line"> * @author: guohao</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">public class GoodsController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KeyGenerator keyGenerator;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private GoodsRepository goodsRepository;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/save&quot;)</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        for(int i= 1 ; i &lt;= 40 ; i ++)&#123;</span><br><span class="line">            Goods goods = new Goods();</span><br><span class="line">            goods.setGoodsId((long) i);</span><br><span class="line">            goods.setGoodsName( &quot;shangpin&quot; + i);</span><br><span class="line">            goods.setGoodsType((long) (i+1));</span><br><span class="line">            goodsRepository.save(goods);</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/select&quot;)</span><br><span class="line">    public String select()&#123;</span><br><span class="line">        return goodsRepository.findAll().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/delete&quot;)</span><br><span class="line">    public void delete()&#123;</span><br><span class="line">        goodsRepository.deleteAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/query1&quot;)</span><br><span class="line">    public Object query1()&#123;</span><br><span class="line">        return goodsRepository.findAllByGoodsIdBetween(10L, 30L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/query2&quot;)</span><br><span class="line">    public Object query2()&#123;</span><br><span class="line">        List&lt;Long&gt; goodsIds = new ArrayList&lt;&gt;();</span><br><span class="line">        goodsIds.add(10L);</span><br><span class="line">        goodsIds.add(15L);</span><br><span class="line">        goodsIds.add(20L);</span><br><span class="line">        goodsIds.add(25L);</span><br><span class="line">        return goodsRepository.findAllByGoodsIdIn(goodsIds);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="通过postman测试"><a href="#通过postman测试" class="headerlink" title="通过postman测试"></a>通过postman测试</h4><h5 id="最终结果为："><a href="#最终结果为：" class="headerlink" title="最终结果为："></a>最终结果为：</h5><blockquote><ul><li>database0存入id小于20的数据库，表goods_0存入id为基数的数据库，表goods_1存入id为偶数的数据。</li><li>database1存入id小于20的数据库，表goods_0存入id为基数的数据库，表goods_1存入id为偶数的数据。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、Sharding-jdbc简介&quot;&gt;&lt;a href=&quot;#一、Sharding-jdbc简介&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="随记" scheme="http://www.xingchuan.vip/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://www.xingchuan.vip/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>23.Elasticsearch(三) Springboot整合Elasticsearch</title>
    <link href="http://www.xingchuan.vip/23.Elasticsearch(%E4%B8%89)%20Springboot%E6%95%B4%E5%90%88Elasticsearch.html"/>
    <id>http://www.xingchuan.vip/23.Elasticsearch(三) Springboot整合Elasticsearch.html</id>
    <published>2019-08-16T09:48:00.000Z</published>
    <updated>2019-08-16T03:14:21.436Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><h5 id="Elasticsearch："><a href="#Elasticsearch：" class="headerlink" title="Elasticsearch："></a>Elasticsearch：</h5><blockquote><p><strong>6.4.2</strong>(由于spring-boot-starter-data-elasticsearch最高支持6.8.+的版本，所以本人从前两章的7.1.0换成之前下载的6.4.2版本)</p></blockquote><h5 id="Springboot："><a href="#Springboot：" class="headerlink" title="Springboot："></a>Springboot：</h5><blockquote><p><strong>2.1.7.PRLEASE</strong></p></blockquote><h5 id="pom-xml："><a href="#pom-xml：" class="headerlink" title="pom.xml："></a>pom.xml：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.cz&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springboot-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;springboot-elasticsearch&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h5 id="application-yml："><a href="#application-yml：" class="headerlink" title="application.yml："></a>application.yml：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    jest:</span><br><span class="line">      uris: http://192.168.4.109:9200</span><br><span class="line">  data:</span><br><span class="line">    elasticsearch:</span><br><span class="line">      cluster-name: my-application</span><br><span class="line">      cluster-nodes: 192.168.4.109:9300</span><br></pre></td></tr></table></figure><blockquote><p>可以更换成你自己的ip，cluster-name在elasticsearch的配置文件里可以看到。</p></blockquote><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><h5 id="进入elasticsearch的bin目录，启动elasticsearch-bat。"><a href="#进入elasticsearch的bin目录，启动elasticsearch-bat。" class="headerlink" title="进入elasticsearch的bin目录，启动elasticsearch.bat。"></a>进入elasticsearch的bin目录，启动elasticsearch.bat。</h5><h5 id="通过cmd进入elasticsearch-head-master目录，执行grunt-server命令，启动插件。"><a href="#通过cmd进入elasticsearch-head-master目录，执行grunt-server命令，启动插件。" class="headerlink" title="通过cmd进入elasticsearch-head-master目录，执行grunt server命令，启动插件。"></a>通过cmd进入elasticsearch-head-master目录，执行grunt server命令，启动插件。</h5><h5 id="如果能正常访问9100和9200端口，则继续执行下面步骤。"><a href="#如果能正常访问9100和9200端口，则继续执行下面步骤。" class="headerlink" title="如果能正常访问9100和9200端口，则继续执行下面步骤。"></a>如果能正常访问9100和9200端口，则继续执行下面步骤。</h5><hr><h3 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h3><h4 id="创建实体类："><a href="#创建实体类：" class="headerlink" title="创建实体类："></a>创建实体类：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package com.cz.springbootelasticsearch.entity;</span><br><span class="line"></span><br><span class="line">import org.springframework.data.annotation.Id;</span><br><span class="line">import org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line">import org.springframework.data.elasticsearch.annotations.Field;</span><br><span class="line">import org.springframework.data.elasticsearch.annotations.FieldType;</span><br><span class="line"></span><br><span class="line">@Document(indexName = &quot;item&quot;,type = &quot;docs&quot;,shards = 1,replicas = 0)</span><br><span class="line">public class Item &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    private Long id;</span><br><span class="line">    @Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;)</span><br><span class="line">    private String title;</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String category;</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String brand;</span><br><span class="line">    @Field(type = FieldType.Double)</span><br><span class="line">    private Double price;</span><br><span class="line">    @Field(index = false, type = FieldType.Keyword)</span><br><span class="line">    private String images;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Item() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Item(Long id, String title, String category, String brand, Double price, String images) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.title = title;</span><br><span class="line">        this.category = category;</span><br><span class="line">        this.brand = brand;</span><br><span class="line">        this.price = price;</span><br><span class="line">        this.images = images;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(String title) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCategory() &#123;</span><br><span class="line">        return category;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCategory(String category) &#123;</span><br><span class="line">        this.category = category;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getBrand() &#123;</span><br><span class="line">        return brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBrand(String brand) &#123;</span><br><span class="line">        this.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(Double price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getImages() &#123;</span><br><span class="line">        return images;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setImages(String images) &#123;</span><br><span class="line">        this.images = images;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Item&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, title=&apos;&quot; + title + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, category=&apos;&quot; + category + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, brand=&apos;&quot; + brand + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &quot;, images=&apos;&quot; + images + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Repository接口"><a href="#Repository接口" class="headerlink" title="Repository接口"></a>Repository接口</h4><blockquote><p>Spring Data的强大之处，在于不用作任何dao处理，自动根据方法名或类的信息进行curd操作。所以我们只需要定义接口，继续ElasticsearchRepository就可以了。</p></blockquote><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.cz.springbootelasticsearch.dao;</span><br><span class="line"></span><br><span class="line">import com.cz.springbootelasticsearch.entity.Item;</span><br><span class="line">import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface ItemRepository extends ElasticsearchRepository&lt;Item,Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;Item&gt; findByTitleLike(String title);</span><br><span class="line"></span><br><span class="line">    public List&lt;Item&gt; findByPriceBetween(double price1,double price2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接来下创建对应的controller，service，serviceImpl，完整代码我上传到github上，会在文章末尾贴出。</p></blockquote><h4 id="创建一个新对象"><a href="#创建一个新对象" class="headerlink" title="创建一个新对象"></a>创建一个新对象</h4><h5 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h5><h6 id="controller："><a href="#controller：" class="headerlink" title="controller："></a>controller：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 增加</span><br><span class="line">   * 本人为了方便测试，所以在下面直接new对象，真实开发则是从前端接收对象，同时记得验证。</span><br><span class="line">   * @param item</span><br><span class="line">   */</span><br><span class="line">  @PostMapping(value = &quot;/item&quot;)</span><br><span class="line">  public void addItem(Item item)&#123;</span><br><span class="line">      item = new Item();</span><br><span class="line">      item.setId(4L);</span><br><span class="line">      item.setTitle(&quot;三星MATE20&quot;);</span><br><span class="line">      item.setCategory(&quot;手机&quot;);</span><br><span class="line">      item.setBrand(&quot;三星&quot;);</span><br><span class="line">      item.setPrice(3100.00);</span><br><span class="line">      item.setImages(&quot;http://image.baidu.com/13123.jpg&quot;);</span><br><span class="line">      itemService.addItem(item);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h6 id="serviceImpl："><a href="#serviceImpl：" class="headerlink" title="serviceImpl："></a>serviceImpl：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private ItemRepository itemRepository;</span><br><span class="line"></span><br><span class="line">public void addItem(Item item)&#123;</span><br><span class="line">    itemRepository.save(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过postman进行测试，访问127.0.0.1:9100查看，即可发现插入成功。</p></blockquote><h4 id="批量新增"><a href="#批量新增" class="headerlink" title="批量新增"></a>批量新增</h4><h5 id="核心代码：-1"><a href="#核心代码：-1" class="headerlink" title="核心代码："></a>核心代码：</h5><h6 id="controller：-1"><a href="#controller：-1" class="headerlink" title="controller："></a>controller：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 批量增加</span><br><span class="line"> * @param</span><br><span class="line"> */</span><br><span class="line">@PostMapping(value = &quot;/items&quot;)</span><br><span class="line">public void addItemList()&#123;</span><br><span class="line">    List&lt;Item&gt; itemList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Item item1 = new Item();</span><br><span class="line">    item1.setId(5L);</span><br><span class="line">    item1.setTitle(&quot;1+7Pro&quot;);</span><br><span class="line">    item1.setCategory(&quot;手机&quot;);</span><br><span class="line">    item1.setBrand(&quot;1+&quot;);</span><br><span class="line">    item1.setPrice(2800.00);</span><br><span class="line">    item1.setImages(&quot;http://image.baidu.com/13123.jpg&quot;);</span><br><span class="line"></span><br><span class="line">    itemList.add(item1);</span><br><span class="line"></span><br><span class="line">    Item item2 = new Item();</span><br><span class="line">    item2.setId(6L);</span><br><span class="line">    item2.setTitle(&quot;红米K20Pro&quot;);</span><br><span class="line">    item2.setCategory(&quot;手机&quot;);</span><br><span class="line">    item2.setBrand(&quot;红米&quot;);</span><br><span class="line">    item2.setPrice(2500.00);</span><br><span class="line">    item2.setImages(&quot;http://image.baidu.com/13123.jpg&quot;);</span><br><span class="line"></span><br><span class="line">    itemList.add(item2);</span><br><span class="line">    itemService.addItemList(itemList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="serviceImpl：-1"><a href="#serviceImpl：-1" class="headerlink" title="serviceImpl："></a>serviceImpl：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addItemList(List&lt;Item&gt; itemList) &#123;</span><br><span class="line">    itemRepository.saveAll(itemList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过Postman测试，访问127.0.0.1:9100查看，即可发现插入成功。</p></blockquote><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><blockquote><p>elasticsearch中没有修改，它修改的原理是先删除再新增。</p></blockquote><blockquote><p>修改和新增是同一个接口，区分的依据就是id。</p></blockquote><h5 id="核心代码：-2"><a href="#核心代码：-2" class="headerlink" title="核心代码："></a>核心代码：</h5><h6 id="controller：-2"><a href="#controller：-2" class="headerlink" title="controller："></a>controller：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 修改：elasticsearch没有修改，它的原理就是先删除再新增，和新增用同一个接口，区别是id</span><br><span class="line"> * @param item</span><br><span class="line"> */</span><br><span class="line">@PutMapping(value = &quot;/items&quot;)</span><br><span class="line">public void editItem(Item item)&#123;</span><br><span class="line">    item = new Item();</span><br><span class="line">    item.setId(5L);</span><br><span class="line">    item.setTitle(&quot;1+7Pro&quot;);</span><br><span class="line">    item.setCategory(&quot;手机&quot;);</span><br><span class="line">    item.setBrand(&quot;一加&quot;);</span><br><span class="line">    item.setPrice(2800.00);</span><br><span class="line">    item.setImages(&quot;http://image.baidu.com/13123.jpg&quot;);</span><br><span class="line">    itemService.editItem(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="serviceImpl：-2"><a href="#serviceImpl：-2" class="headerlink" title="serviceImpl："></a>serviceImpl：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void editItem(Item item) &#123;</span><br><span class="line">    itemRepository.save(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><blockquote><p>ElasticsearchRepository提供了一些基本的查询方法，直接调用即可。</p></blockquote><h5 id="核心代码：-3"><a href="#核心代码：-3" class="headerlink" title="核心代码："></a>核心代码：</h5><h6 id="controller：-3"><a href="#controller：-3" class="headerlink" title="controller："></a>controller：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 查询所有</span><br><span class="line"> */</span><br><span class="line">@GetMapping(value = &quot;/items&quot;)</span><br><span class="line">public void findAllItem()&#123;</span><br><span class="line">    Iterable&lt;Item&gt; list = itemService.findAllItem();</span><br><span class="line"></span><br><span class="line">    for (Item item:list) &#123;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="serviceImpl：-3"><a href="#serviceImpl：-3" class="headerlink" title="serviceImpl："></a>serviceImpl：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Iterable&lt;Item&gt; findAllItem() &#123;</span><br><span class="line">    return itemRepository.findAll(Sort.by(&quot;price&quot;).ascending());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><h5 id="核心代码：-4"><a href="#核心代码：-4" class="headerlink" title="核心代码："></a>核心代码：</h5><h6 id="controller：-4"><a href="#controller：-4" class="headerlink" title="controller："></a>controller：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 分页查询</span><br><span class="line"> * @param page</span><br><span class="line"> * @param size</span><br><span class="line"> */</span><br><span class="line">@GetMapping(value = &quot;/items/&#123;page&#125;/&#123;size&#125;&quot;)</span><br><span class="line">public void findItemByPage(@PathVariable(&quot;page&quot;)int page,@PathVariable(&quot;size&quot;)int size)&#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;Item&gt; items = itemService.searchByPage(page,size);</span><br><span class="line"></span><br><span class="line">    long total = items.getTotalElements();</span><br><span class="line">    System.out.println(&quot;总条数=&quot; + total);</span><br><span class="line">    System.out.println(&quot;总页数=&quot; + items.getTotalPages());</span><br><span class="line">    System.out.println(&quot;当前页：&quot; + items.getNumber());</span><br><span class="line">    System.out.println(&quot;每页大小：&quot; + items.getSize());</span><br><span class="line">    for (Item item : items) &#123;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="serviceImpl：-4"><a href="#serviceImpl：-4" class="headerlink" title="serviceImpl："></a>serviceImpl：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Page&lt;Item&gt; searchByPage(int page, int size) &#123;</span><br><span class="line">    //构建查询条件</span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder();</span><br><span class="line">    //添加基本的分词查询</span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.termQuery(&quot;category&quot;,&quot;手机&quot;));</span><br><span class="line">    //分页</span><br><span class="line">    queryBuilder.withPageable(PageRequest.of(page,size));</span><br><span class="line"></span><br><span class="line">    Page&lt;Item&gt; items = itemRepository.search(queryBuilder.build());</span><br><span class="line"></span><br><span class="line">    return items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序查找"><a href="#排序查找" class="headerlink" title="排序查找"></a>排序查找</h4><h5 id="核心代码：-5"><a href="#核心代码：-5" class="headerlink" title="核心代码："></a>核心代码：</h5><h6 id="controller：-5"><a href="#controller：-5" class="headerlink" title="controller："></a>controller：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 排序查找</span><br><span class="line"> * @param condition 条件</span><br><span class="line"> */</span><br><span class="line">@GetMapping(value = &quot;/items/&#123;condition&#125;&quot;)</span><br><span class="line">public void findItemBySort(@PathVariable(&quot;condition&quot;)String condition)&#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;Item&gt; items = itemService.searchBySort(condition);</span><br><span class="line"></span><br><span class="line">    for (Item item : items) &#123;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="serviceImpl：-5"><a href="#serviceImpl：-5" class="headerlink" title="serviceImpl："></a>serviceImpl：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Page&lt;Item&gt; searchBySort(String condition) &#123;</span><br><span class="line">    //构建查询条件</span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder();</span><br><span class="line">    //添加基本的分词查询</span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.termQuery(&quot;category&quot;,&quot;手机&quot;));</span><br><span class="line">    //排序</span><br><span class="line">    queryBuilder.withSort(SortBuilders.fieldSort(condition).order(SortOrder.ASC));</span><br><span class="line"></span><br><span class="line">    Page&lt;Item&gt; items = itemRepository.search(queryBuilder.build());</span><br><span class="line"></span><br><span class="line">    return items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><h5 id="核心代码：-6"><a href="#核心代码：-6" class="headerlink" title="核心代码："></a>核心代码：</h5><h5 id="controller：-6"><a href="#controller：-6" class="headerlink" title="controller："></a>controller：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据价格区间查询item</span><br><span class="line"> * @param price1</span><br><span class="line"> * @param price2</span><br><span class="line"> */</span><br><span class="line">@GetMapping(value = &quot;/items/between/&#123;price1&#125;/&#123;price2&#125;&quot;)</span><br><span class="line">public void findItemBetweenPrice(@PathVariable(&quot;price1&quot;)double price1,@PathVariable(&quot;price2&quot;)double price2)&#123;</span><br><span class="line">    List&lt;Item&gt; list = itemService.findItemBetweenPrice(price1,price2);</span><br><span class="line"></span><br><span class="line">    for (Item item: list) &#123;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="serviceImpl：-6"><a href="#serviceImpl：-6" class="headerlink" title="serviceImpl："></a>serviceImpl：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public List&lt;Item&gt; findItemBetweenPrice(double price1, double price2) &#123;</span><br><span class="line">    return itemRepository.findByPriceBetween(price1,price2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h5 id="核心代码：-7"><a href="#核心代码：-7" class="headerlink" title="核心代码："></a>核心代码：</h5><h6 id="controller"><a href="#controller" class="headerlink" title="controller:"></a>controller:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除</span><br><span class="line"> * @param item</span><br><span class="line"> */</span><br><span class="line">@DeleteMapping(value = &quot;/items&quot;)</span><br><span class="line">public void delete(Item item)&#123;</span><br><span class="line">    item = new Item();</span><br><span class="line">    item.setId(5L);</span><br><span class="line"></span><br><span class="line">    itemService.deleteItem(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="serviceImpl"><a href="#serviceImpl" class="headerlink" title="serviceImpl:"></a>serviceImpl:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void deleteItem(Item item) &#123;</span><br><span class="line">    itemRepository.delete(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><blockquote><p>聚合可以让我们及其方便的实现对数据的统计、分析。例如：</p><blockquote><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul></blockquote></blockquote><blockquote><p>Elasticsearch中的聚合，包含多种类型，最常用的一个叫桶，一个叫度量。</p></blockquote><h5 id="桶"><a href="#桶" class="headerlink" title="桶"></a>桶</h5><blockquote><p>按照某种方式对数据进行分组，但是不进行计算，所以bucket中会嵌套另一种聚合，那就是度量。</p></blockquote><h5 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h5><blockquote><p>分组完成后，我们一般会对数据进行聚合计算，例如求平均值、最大、最小、求和。这些被称为度量。</p></blockquote><h4 id="聚合为桶"><a href="#聚合为桶" class="headerlink" title="聚合为桶"></a>聚合为桶</h4><h5 id="核心代码：-8"><a href="#核心代码：-8" class="headerlink" title="核心代码："></a>核心代码：</h5><h6 id="controller：-7"><a href="#controller：-7" class="headerlink" title="controller："></a>controller：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 聚合</span><br><span class="line"> * @param aggName</span><br><span class="line"> * @param aggfields</span><br><span class="line"> */</span><br><span class="line">@PutMapping(value = &quot;/items/agg/&#123;aggName&#125;/&#123;aggfields&#125;&quot;)</span><br><span class="line">public void aggItemByCondition(@PathVariable(&quot;aggName&quot;)String aggName,@PathVariable()String aggfields)&#123;</span><br><span class="line">    List&lt;StringTerms.Bucket&gt; buckets  = itemService.aggItemByCondition(aggName,aggfields);</span><br><span class="line"></span><br><span class="line">    for (StringTerms.Bucket bucket : buckets)&#123;</span><br><span class="line">        System.out.println(bucket.getKeyAsString());</span><br><span class="line">        System.out.println(bucket.getDocCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="serviceImpl：-7"><a href="#serviceImpl：-7" class="headerlink" title="serviceImpl："></a>serviceImpl：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public List&lt;StringTerms.Bucket&gt; aggItemByCondition(String aggName,String aggfields) &#123;</span><br><span class="line">    //构建查询条件</span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder();</span><br><span class="line">    //不查询任何结果</span><br><span class="line">    queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;&quot;&quot;&#125;,null));</span><br><span class="line">    //1.创建一个新的聚合，聚合查询为terms，聚合名称为为aggName,聚合字段为aggfields</span><br><span class="line">    queryBuilder.addAggregation(AggregationBuilders.terms(aggName).field(aggfields));</span><br><span class="line">    //2.查询，需要把结果强转成AggregatedPage类型</span><br><span class="line">    AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;)itemRepository.search(queryBuilder.build());</span><br><span class="line">    //3.解析</span><br><span class="line">    //3.1 从结果中取出名为brands的那个集合</span><br><span class="line">    //因为是利用String类型字段进行term聚合，所以结果要转为StringTerm类型</span><br><span class="line">    StringTerms agg = (StringTerms)aggPage.getAggregation(aggName);</span><br><span class="line">    //3.2 获取桶</span><br><span class="line">    List&lt;StringTerms.Bucket&gt; buckets = agg.getBuckets();</span><br><span class="line">    return buckets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>完整代码都上传到本人github仓库了，地址：<a href="https://github.com/quietAny/springboot-elasticsearch" target="_blank" rel="noopener">https://github.com/quietAny/springboot-elasticsearch</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;
      
    
    </summary>
    
      <category term="搜索引擎" scheme="http://www.xingchuan.vip/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="elasticsearch" scheme="http://www.xingchuan.vip/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>22.Elasticsearch(二) MySQL同步数据到ES</title>
    <link href="http://www.xingchuan.vip/22.Elasticsearch(%E4%BA%8C)%20MySQL%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0ES.html"/>
    <id>http://www.xingchuan.vip/22.Elasticsearch(二) MySQL同步数据到ES.html</id>
    <published>2019-08-14T17:12:00.000Z</published>
    <updated>2019-08-16T03:08:21.549Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h3><blockquote><p>本人也是在网上搜寻各种博客，总结了如下几个方案：</p></blockquote><h4 id="双写"><a href="#双写" class="headerlink" title="双写"></a>双写</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote><ul><li>简单</li><li>灵活</li></ul></blockquote><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><blockquote><ul><li>业务代码耦合验证</li><li>如何保证双写成功</li><li>同步双写会增加响应时间</li></ul></blockquote><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><blockquote><ul><li>简单</li><li>业务代码耦合</li><li>需要保证写入MQ成功</li><li>需要考虑异步造成的一致性问题(消费无需和消费时序)</li></ul></blockquote><h4 id="通过logstash-input-jdbc类似的进行同步-个人推荐使用"><a href="#通过logstash-input-jdbc类似的进行同步-个人推荐使用" class="headerlink" title="通过logstash-input-jdbc类似的进行同步(个人推荐使用)"></a>通过logstash-input-jdbc类似的进行同步(个人推荐使用)</h4><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><blockquote><ul><li>定时批量同步</li></ul></blockquote><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><blockquote><ul><li>延时如何控制</li><li>当大表垂直拆分，在ES是一张表的时候不好做数据合并(可以通过sql联合查询)</li><li>对数据库有一定压力(定时轮询新增数据)</li></ul></blockquote><h4 id="通过canal"><a href="#通过canal" class="headerlink" title="通过canal"></a>通过canal</h4><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><blockquote><ul><li>低耦合</li><li>实时性较好</li><li>对主库压力小，不需要回表查</li></ul></blockquote><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><blockquote><ul><li>引入canal会引入更多的组件，例如zk，增加系统复杂性</li><li>如何保证canal集群的稳定性</li><li>canal机器配置需要MySQL的配置差不多，不然主从同步延迟会严重。</li></ul></blockquote><hr><h3 id="通过logstash-input-jdbc进行同步"><a href="#通过logstash-input-jdbc进行同步" class="headerlink" title="通过logstash-input-jdbc进行同步"></a>通过logstash-input-jdbc进行同步</h3><h4 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h4><h5 id="全量同步：全部将数据同步到es，通常是刚建立es，第一次同步时使用。"><a href="#全量同步：全部将数据同步到es，通常是刚建立es，第一次同步时使用。" class="headerlink" title="全量同步：全部将数据同步到es，通常是刚建立es，第一次同步时使用。"></a>全量同步：全部将数据同步到es，通常是刚建立es，第一次同步时使用。</h5><h5 id="增量同步：将后续的更新、插入记录同步到es。"><a href="#增量同步：将后续的更新、插入记录同步到es。" class="headerlink" title="增量同步：将后续的更新、插入记录同步到es。"></a>增量同步：将后续的更新、插入记录同步到es。</h5><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="安装logstash"><a href="#安装logstash" class="headerlink" title="安装logstash"></a>安装logstash</h5><blockquote><p>下载地址：<a href="https://www.elastic.co/cn/downloads/logstash" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/logstash</a></p></blockquote><blockquote><p>无需安装，解压即用。<strong>注意版本号，本人安装的和elasticsearch一样的版本7.1.0.</strong></p></blockquote><h5 id="安装ruby"><a href="#安装ruby" class="headerlink" title="安装ruby"></a>安装ruby</h5><blockquote><p>因为logstash-input-jdbc插件是logstash的一个插件，使用ruby语音开发，所以安装先按照ruby也是为了好使用ruby中的gem安装插件。</p></blockquote><blockquote><p>下载地址：<a href="https://rubyinstaller.org/downloads/" target="_blank" rel="noopener">https://rubyinstaller.org/downloads/</a></p></blockquote><blockquote><p>本人安装的是推荐版本2.5.5-1(x64),下载完成后进行安装。</p></blockquote><blockquote><p>安装好后试下是否安装成功，打开CMD输入：</p></blockquote><p><img src="http://www.qingpingshan.com/uploads/allimg/170906/1RI32459-4.png" alt></p><blockquote><p>然后修改gem的源，可使用以下命令：</p><blockquote><ul><li>查看gem源：gem sources -l</li></ul></blockquote></blockquote><p><img src="http://www.qingpingshan.com/uploads/allimg/170906/1RI3CX-5.png" alt></p><blockquote><blockquote><ul><li>删除默认的源：gem sources –remove https：//rubygems.org/</li></ul></blockquote></blockquote><p><img src="http://www.qingpingshan.com/uploads/allimg/170906/1RI334Z-6.png" alt></p><blockquote><blockquote><ul><li>添加新的源：gem sources -a <a href="http://gems.ruby-china.org/" target="_blank" rel="noopener">http://gems.ruby-china.org/</a></li></ul></blockquote></blockquote><p><img src="http://www.qingpingshan.com/uploads/allimg/170906/1RI31963-7.png" alt></p><blockquote><p>更新完后会，还得修改Gemfile的数据源地址：</p><ul><li>gem install bundler</li><li>bundle config mirror.<a href="https://rubygems.org" target="_blank" rel="noopener">https://rubygems.org</a> <a href="https://gems.ruby-china.org" target="_blank" rel="noopener">https://gems.ruby-china.org</a></li></ul></blockquote><p><img src="http://www.qingpingshan.com/uploads/allimg/170906/1RI31522-8.png" alt></p><h5 id="安装logstash-input-jdbc"><a href="#安装logstash-input-jdbc" class="headerlink" title="安装logstash-input-jdbc"></a>安装logstash-input-jdbc</h5><blockquote><p>打开cmd，进入logstash的bin目录下，执行安装命令： .\logstash-plugin.bat install logstash-input-jdbc</p></blockquote><blockquote><p>等一会后，成功会显示如下<br><img src="http://www.qingpingshan.com/uploads/allimg/170906/1RI36003-10.png" alt></p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote><p>官网文档地址：<a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html</a></p></blockquote><blockquote><p>首先在logst的bin目录下新建一个目录，里面包括了jdbc.conf,jdbc.sql,已经mysql的驱动：</p></blockquote><p><img src="http://www.qingpingshan.com/uploads/allimg/170906/1RI33X1-11.png" alt></p><blockquote><p><strong>jdbc.conf的配置如下：</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    jdbc &#123;</span><br><span class="line">      # mysql 数据库链接,test为数据库名</span><br><span class="line">      jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/test&quot;</span><br><span class="line">      # 用户名和密码</span><br><span class="line">      jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">      jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">      # 驱动</span><br><span class="line">      jdbc_driver_library =&gt; &quot;D:\development\logstash-7.1.0\bin\mysql-connector-java-5.1.46.jar&quot;</span><br><span class="line">      # 驱动类名</span><br><span class="line">      jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">      jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">      jdbc_page_size =&gt; &quot;50000&quot;</span><br><span class="line">      # 执行的sql 文件路径+名称</span><br><span class="line">      statement_filepath =&gt; &quot;D:\development\logstash-7.1.0\bin\jdbc.sql&quot;</span><br><span class="line">      # 设置监听间隔  各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新</span><br><span class="line">      schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">      # 索引类型</span><br><span class="line">      type =&gt; &quot;jdbc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">    json &#123;</span><br><span class="line">        source =&gt; &quot;message&quot;</span><br><span class="line">        remove_field =&gt; [&quot;message&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        # ES的IP地址及端口</span><br><span class="line">        hosts =&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">        # 索引名称</span><br><span class="line">        index =&gt; &quot;user&quot;</span><br><span class="line">        # 自增ID 需要关联的数据库中有有一个id字段，对应索引的id号</span><br><span class="line">        document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    stdout &#123;</span><br><span class="line">        # JSON格式输出</span><br><span class="line">        codec =&gt; json_lines</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面是本人配置，读者可以改为自己的数据库配置和文件路径以及对应es的端口。</p></blockquote><blockquote><p><strong>jdbc.sql配置如下：</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user</span><br></pre></td></tr></table></figure><blockquote><p>这里是本人测试要执行的sql语句，读者可以自定义。</p></blockquote><blockquote><p><strong>注意：这里的jdbc.sql和jdbc.conf文件编码都必须是ANSI</strong></p></blockquote><blockquote><p>配置完成后启动es，创建user索引。通过以下命令启动logstash：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\logstash.bat -f .\mysql\jdbc.conf</span><br></pre></td></tr></table></figure><p><img src="http://www.qingpingshan.com/uploads/allimg/170906/1RI34912-14.png" alt></p><blockquote><p>过一会后就会自动往es添加数据，这样我们就完成了mysql同步数据到es的操作了。</p></blockquote><h4 id="增量新增"><a href="#增量新增" class="headerlink" title="增量新增"></a>增量新增</h4><blockquote><p>需要在jdbc.conf配置文件中做如下修改：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    jdbc &#123;</span><br><span class="line">      # mysql 数据库链接,test为数据库名</span><br><span class="line">      jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/test&quot;</span><br><span class="line">      # 用户名和密码</span><br><span class="line">      jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">      jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">      # 驱动</span><br><span class="line">      jdbc_driver_library =&gt; &quot;D:\development\logstash-7.1.0\bin\mysql-connector-java-5.1.46.jar&quot;</span><br><span class="line">      # 驱动类名</span><br><span class="line">      jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">      #处理中文乱码问题</span><br><span class="line">      codec =&gt; plain &#123; charset =&gt; &quot;UTF-8&quot;&#125;</span><br><span class="line">      #使用其它字段追踪，而不是用时间</span><br><span class="line">      use_column_value =&gt; true</span><br><span class="line">      #追踪的字段</span><br><span class="line">      tracking_column =&gt; id</span><br><span class="line">      record_last_run =&gt; true</span><br><span class="line">      #上一个sql_last_value值的存放文件路径, 必须要在文件中指定字段的初始值    </span><br><span class="line">      last_run_metadata_path =&gt; &quot;D:\development\logstash-7.1.0\bin\station_parameter.txt&quot;</span><br><span class="line">      #开启分页查询</span><br><span class="line">      jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">      jdbc_page_size =&gt; &quot;50000&quot;</span><br><span class="line">      # 执行的sql 文件路径+名称</span><br><span class="line">      statement_filepath =&gt; &quot;D:\development\logstash-7.1.0\bin\jdbc.sql&quot;</span><br><span class="line">      # 设置监听间隔  各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新</span><br><span class="line">      schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">      # 索引类型</span><br><span class="line">      type =&gt; &quot;jdbc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">    json &#123;</span><br><span class="line">        source =&gt; &quot;message&quot;</span><br><span class="line">        remove_field =&gt; [&quot;message&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        # ES的IP地址及端口</span><br><span class="line">        hosts =&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">        # 索引名称</span><br><span class="line">        index =&gt; &quot;user&quot;</span><br><span class="line">        # 自增ID 需要关联的数据库中有有一个id字段，对应索引的id号</span><br><span class="line">        document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    stdout &#123;</span><br><span class="line">        # JSON格式输出</span><br><span class="line">        codec =&gt; json_lines</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打开bin目录下的station_parameter.txt文件</p></blockquote><p><img src="http://www.qingpingshan.com/uploads/allimg/170906/1RI32U2-23.png" alt></p><blockquote><p>这个文件里记录上次执行到的 tracking_column 字段的值,比如上次数据库有 10000 条记录,查询完后该文件中就会有数字 10000 这样的记录,下次执行 SQL 查询可以从 10001 条处开始,我们只需要在 SQL 语句中 WHERE MY_ID &gt; :last_sql_value 即可. 其中 :last_sql_value 取得就是该文件中的值。</p></blockquote><blockquote><p>然后开启爬虫,爬取数据,往数据库里插，logstash会自动的识别到更新，然后导入到ES中！！</p></blockquote><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>如上文件都是我个人的配置，读者可以根据需求更换成自己的配置。</p></blockquote><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><blockquote><p>现在我们解决了mysql同步数据到es的问题，但是我们遇到了新的问题，如何在项目中使用中，下一章我将告诉大家，敬请期待！</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;技术方案&quot;&gt;&lt;a href=&quot;#技术方案&quot; class=&quot;headerlink&quot; title=&quot;技术方案&quot;&gt;&lt;/a&gt;技术方案&lt;/h3&gt;
      
    
    </summary>
    
      <category term="搜索引擎" scheme="http://www.xingchuan.vip/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="java" scheme="http://www.xingchuan.vip/tags/java/"/>
    
      <category term="elasticsearch" scheme="http://www.xingchuan.vip/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>21.Elasticsearch(一) 介绍和安装</title>
    <link href="http://www.xingchuan.vip/21.Elasticsearch(%E4%B8%80)%20%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85.html"/>
    <id>http://www.xingchuan.vip/21.Elasticsearch(一) 介绍和安装.html</id>
    <published>2019-08-14T14:48:00.000Z</published>
    <updated>2019-08-21T09:43:23.508Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><ul><li>基于Lucene的搜索服务器，一个分布式多用户能力的全文搜索引擎，基于RESTful web接口，是当前流行的企业级搜索引擎。</li></ul></blockquote><blockquote><ul><li>官网: <a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">https://www.elastic.co/cn/</a></li></ul></blockquote><blockquote><p>Elastic有一条完整的产品线：Elasticsearch、Kibana、Logstash等，前面说的三个就是大家常说的ELK技术栈。</p></blockquote><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><blockquote><ul><li>分布式,无需人工搭建集群</li><li>Restful风格，一切API都遵循Rest原则，容易上手</li><li>近实时搜索，数据更新在Elasticsearch中几乎是完全同步的。</li></ul></blockquote><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="版本："><a href="#版本：" class="headerlink" title="版本："></a>版本：</h4><blockquote><p>Elasticsearch：7.1.0(最新版为7.3.0，可自行选择)。</p></blockquote><blockquote><p>JDK: 1.8</p></blockquote><h4 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h4><blockquote><p><a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a></p></blockquote><blockquote><p>无需安装，解压即用</p></blockquote><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><blockquote><p>进入elasticsearch/bin 目录，可以看到执行文件<br><img src="https://img-blog.csdn.net/20180929204157472?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMzEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>双击启动后绑定了两个端口：</p><blockquote><ul><li>9300:java程序访问的端口</li><li>9200:浏览器，postman访问端口</li></ul></blockquote></blockquote><hr><h3 id="安装Head插件"><a href="#安装Head插件" class="headerlink" title="安装Head插件"></a>安装Head插件</h3><h4 id="什么是Head"><a href="#什么是Head" class="headerlink" title="什么是Head?"></a>什么是Head?</h4><blockquote><p>一个专门针对于elasticsearch的客户端工具。</p></blockquote><h4 id="下载地址：-1"><a href="#下载地址：-1" class="headerlink" title="下载地址："></a>下载地址：</h4><blockquote><p><a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a></p></blockquote><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><blockquote><ul><li>es5以上的版本安装head需要安装node和grunt</li></ul></blockquote><blockquote><ul><li>第一步：从地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> 下载相应系统的msi，双击安装。<br><img src="https://img-blog.csdn.net/20180929204249755?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMzEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></li></ul></blockquote><blockquote><ul><li>第二步：安装完成后使用cmd进入安装目录执行node -v可查看版本号。<br><img src="https://img-blog.csdn.net/20180929204300102?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMzEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></li></ul></blockquote><blockquote><ul><li>第三步：执行npm install -g grunt-cli 安装grunt，安装后执行grunt -version查看是否安装成功<br><img src="https://img-blog.csdn.net/20180929204300102?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMzEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></li></ul></blockquote><h4 id="配置运行"><a href="#配置运行" class="headerlink" title="配置运行"></a>配置运行</h4><blockquote><ul><li>第一步：进入es安装目录下的config目录，修改elasticsearch.yml文件，在文件末尾加入以下代码。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">node.master: true</span><br><span class="line">node.data: true</span><br></pre></td></tr></table></figure><blockquote><p>然后去掉network.host: 192.168.0.1的注释并改为network.host: 0.0.0.0，去掉cluster.name；node.name；http.port的注释（也就是去掉#）(!!!如果出现bat闪退的现象，注释就别去掉)</p></blockquote><blockquote><ul><li>第二步：双击elasticsearch.bat重启es</li></ul></blockquote><blockquote><ul><li>第三步：在<a href="https://github.com/mobz/elasticsearch-head中下载head插件，选择下载zip" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head中下载head插件，选择下载zip</a></li></ul></blockquote><blockquote><ul><li>第四步：解压到指定文件夹下，D:\environment\elasticsearch-head-master 进入该文件夹，修改D:\environment\elasticsearch-head-master\Gruntfile.js 在对应的位置加上hostname:’*’、</li></ul></blockquote><p><img src="https://img-blog.csdn.net/20180929204324657?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMzEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><blockquote><ul><li>第五步：在D:\environment\elasticsearch-head-master 下执行npm install 安装完成后执行grunt server 或者npm run start 运行head插件，如果不成功重新安装grunt。成功如下</li></ul></blockquote><h2><a href="#" class="headerlink"></a><img src="https://img-blog.csdn.net/20180929204332365?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMzEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></h2><h3 id="安装ik分词器"><a href="#安装ik分词器" class="headerlink" title="安装ik分词器"></a>安装ik分词器</h3><h4 id="什么事ik分词器"><a href="#什么事ik分词器" class="headerlink" title="什么事ik分词器"></a>什么事ik分词器</h4><blockquote><p>IK Analyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。从2006年12月推出1.0版开始， IKAnalyzer已经推出了3个大版本。最初，它是以开源项目Luence为应用主体的，结合词典分词和文法分析算法的中文分词组件。新版本的IK Analyzer 3.0则发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。</p></blockquote><h4 id="下载地址：-2"><a href="#下载地址：-2" class="headerlink" title="下载地址："></a>下载地址：</h4><blockquote><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases、" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases、</a></p></blockquote><blockquote><p>无需安装，解压即可使用,将其改名为ik，并且复制到elasticsearch的解压目录：<br><img src="https://img-blog.csdn.net/2018092920443993?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMzEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>然后重启elasticsearch。</p></blockquote><h4 id="拓展词和停用词"><a href="#拓展词和停用词" class="headerlink" title="拓展词和停用词"></a>拓展词和停用词</h4><blockquote><p>拓展词和停用词文件：</p></blockquote><p><img src="https://img-blog.csdn.net/20180929204457564?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMzEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><h2 id="-1"><a href="#-1" class="headerlink"></a><img src="https://img-blog.csdn.net/2018092920450978?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMzEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>以上就是elasticsearch的简介和安装，最终效果图如下：</p></blockquote><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4005132768,4116972412&fm=26&gp=0.jpg" alt></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><blockquote><p>现在我们已经成功安装了es，可是遇到了es里面没有任何数据的问题，而爬虫爬的数据都在mysql中，如何把mysql数据同步到es，我将在下章博客告诉大家，敬请期待！</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="搜索引擎" scheme="http://www.xingchuan.vip/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="java" scheme="http://www.xingchuan.vip/tags/java/"/>
    
      <category term="elasticsearch" scheme="http://www.xingchuan.vip/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>12.BIO、NIO、AIO的区别</title>
    <link href="http://www.xingchuan.vip/12.BIO%E3%80%81NIO%E3%80%81AIO%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
    <id>http://www.xingchuan.vip/12.BIO、NIO、AIO的区别.html</id>
    <published>2019-08-14T08:29:00.000Z</published>
    <updated>2019-08-16T03:07:05.810Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="同步IO和异步IO"><a href="#同步IO和异步IO" class="headerlink" title="同步IO和异步IO"></a>同步IO和异步IO</h3><blockquote><p>IO操作主要分为两个步骤，发起IO请求和实际IO操作，同步IO和异步IO的区别就在于第二个步骤是否阻塞。</p></blockquote><blockquote><p><strong>同步IO</strong>：实际IO操作阻塞请求进程，即请求进程需要等待或者轮询查看IO操作是否就绪。</p></blockquote><blockquote><p><strong>异步IO</strong>：实际IO操作并不阻塞请求进程，而是由操作系统来进行实际IO操作并将结果返回。</p></blockquote><hr><h3 id="阻塞IO和非阻塞IO"><a href="#阻塞IO和非阻塞IO" class="headerlink" title="阻塞IO和非阻塞IO"></a>阻塞IO和非阻塞IO</h3><blockquote><p>区别在于发起IO请求是否阻</p></blockquote><blockquote><p><strong>阻塞IO</strong>：若发起IO请求后请求线程一直等待实际IO操作完成，则为阻塞IO。</p></blockquote><blockquote><p><strong>非阻塞</strong>：发送IO请求后线程返回而不会一直等待。</p></blockquote><hr><h3 id="BIO、NIO和AIO"><a href="#BIO、NIO和AIO" class="headerlink" title="BIO、NIO和AIO"></a>BIO、NIO和AIO</h3><blockquote><p><strong>BIO</strong>：同步非阻塞式IO，服务器实现模式为一个连接一个线程，即客户端有链接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p></blockquote><blockquote><p><strong>NIO</strong>：同步非阻塞IO，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用路上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p></blockquote><blockquote><p><strong>AIO</strong>：异步非阻塞IO，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由操作系统先完成IO操作后再通知服务器应用来启动线程进行处理。</p></blockquote><hr><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><ul><li>BIO适用于连接数目比较小且固定的架构，该方式对服务器资源要求比较高，JDK1.4以前的唯一选择。</li><li>NIO适用于连接数目多且连接比较短(轻操作)的架构，如聊天服务器，编程复杂，JDK1.4开始支持，比如在Netty框架中使用。</li><li>AIO适用于连接数目多且连接比较长(重操作)的架构，如相册服务器，充分调用操作系统参与并发操作，编程复杂，JDK1.7开始支持</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;同步IO和异步IO&quot;&gt;&lt;a href=&quot;#同步IO和异步IO&quot; class=&quot;headerlink&quot; title=&quot;同步IO和异步IO
      
    
    </summary>
    
      <category term="随记" scheme="http://www.xingchuan.vip/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="io" scheme="http://www.xingchuan.vip/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>14.如何将长URL转换成短URL</title>
    <link href="http://www.xingchuan.vip/14.%E5%A6%82%E4%BD%95%E5%B0%86%E9%95%BFURL%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%ADURL.html"/>
    <id>http://www.xingchuan.vip/14.如何将长URL转换成短URL.html</id>
    <published>2019-08-13T09:48:00.000Z</published>
    <updated>2019-08-16T03:07:20.768Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="什么是短URL？"><a href="#什么是短URL？" class="headerlink" title="什么是短URL？"></a>什么是短URL？</h3><h2 id="顾名思义，就是将长网址缩短到一个很短的网址，用户访问这个短网址可以重定向到原本的长网址，这个可以达到易于记忆、转换的目的，常用于字数限制的微博、二维码等等场景。"><a href="#顾名思义，就是将长网址缩短到一个很短的网址，用户访问这个短网址可以重定向到原本的长网址，这个可以达到易于记忆、转换的目的，常用于字数限制的微博、二维码等等场景。" class="headerlink" title=" 顾名思义，就是将长网址缩短到一个很短的网址，用户访问这个短网址可以重定向到原本的长网址，这个可以达到易于记忆、转换的目的，常用于字数限制的微博、二维码等等场景。"></a> 顾名思义，就是将长网址缩短到一个很短的网址，用户访问这个短网址可以重定向到原本的长网址，这个可以达到易于记忆、转换的目的，常用于字数限制的微博、二维码等等场景。</h2><h3 id="短URL的好处"><a href="#短URL的好处" class="headerlink" title="短URL的好处"></a>短URL的好处</h3><p>节省网址长度，便于社交文化传播，让URL更短小，传播更方便。<br>短网址在我们项目里可以很好的对开放以及URL进行管理，有一部分网址可以会涵盖性、暴力、广告等信息。我们可以通过用户的季报，完全让这个连接将不出现在我们的应用中。<br>方便后台跟踪点击量、地域分布等用户统计。我们可以对一系列的网址进行流量，点击等统计，挖掘出大多数用户的关注点。<br>规避关键词、域名屏蔽手段、隐藏真实地址，适合做付费推广链接。</p><h2 id="在微博或者短信场景，字数限制，用短网址能腾出很多空间。"><a href="#在微博或者短信场景，字数限制，用短网址能腾出很多空间。" class="headerlink" title="  在微博或者短信场景，字数限制，用短网址能腾出很多空间。"></a> 在微博或者短信场景，字数限制，用短网址能腾出很多空间。</h2><h3 id="如何生成短地址URL"><a href="#如何生成短地址URL" class="headerlink" title="如何生成短地址URL"></a>如何生成短地址URL</h3><p>利用发号器，初始值为0，对于每个短连接生成的请求，都递增发号器的值，再将值转换成62进制。<br>将短连接服务器名与发号器的62进制值进行字符串连接，即为短链接的URL，例如：t.cnsBc。</p><h2 id="生成短连接后，需要存储短链接和长链接的映射关系，即sBc-URL-浏览器访问短链接服务器时，根据url取到原始连接，进行302重定向。可以使用Redis或Memcache。"><a href="#生成短连接后，需要存储短链接和长链接的映射关系，即sBc-URL-浏览器访问短链接服务器时，根据url取到原始连接，进行302重定向。可以使用Redis或Memcache。" class="headerlink" title="  生成短连接后，需要存储短链接和长链接的映射关系，即sBc-URL,浏览器访问短链接服务器时，根据url取到原始连接，进行302重定向。可以使用Redis或Memcache。"></a> 生成短连接后，需要存储短链接和长链接的映射关系，即sBc-URL,浏览器访问短链接服务器时，根据url取到原始连接，进行302重定向。可以使用Redis或Memcache。</h2><h3 id="跳转用301还是302？"><a href="#跳转用301还是302？" class="headerlink" title="跳转用301还是302？"></a>跳转用301还是302？</h3><p>301是永久重定向，302是临时重定向。短地址一经生成就不会变化，所以用301是符合http语义的，同时对服务器压力也会减少。但是使用了301，我们就无法统计到短连接被点击的次数了。而这个点击次数就是一个非常有意思的大数据分析数据也，能够分析出的东西非常多，虽然302增加服务器压力，但依旧是个更好的选择。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;什么是短URL？&quot;&gt;&lt;a href=&quot;#什么是短URL？&quot; class=&quot;headerlink&quot; title=&quot;什么是短URL？&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="随记" scheme="http://www.xingchuan.vip/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="http" scheme="http://www.xingchuan.vip/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>13.HTTP长连接和短链接</title>
    <link href="http://www.xingchuan.vip/13.HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5.html"/>
    <id>http://www.xingchuan.vip/13.HTTP长连接和短连接.html</id>
    <published>2019-08-09T16:38:00.000Z</published>
    <updated>2019-08-16T03:07:09.582Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="HTTP协议与TCP-IP的关系"><a href="#HTTP协议与TCP-IP的关系" class="headerlink" title="HTTP协议与TCP/IP的关系"></a>HTTP协议与TCP/IP的关系</h3><blockquote><p>HTTP的长连接和短连接本质上就是TCP的长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。</p></blockquote><hr><h3 id="如何理解HTTP协议是无状态的"><a href="#如何理解HTTP协议是无状态的" class="headerlink" title="如何理解HTTP协议是无状态的"></a>如何理解HTTP协议是无状态的</h3><blockquote><p>指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何关联。</p></blockquote><hr><h3 id="什么是长连接、短连接？"><a href="#什么是长连接、短连接？" class="headerlink" title="什么是长连接、短连接？"></a>什么是长连接、短连接？</h3><blockquote><p><strong>在HTTP/1.0中默认是用的是短连接</strong>。也就是说，游览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或者其他Web页中包含其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。<br>**HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><blockquote><p>当一个页面打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</p></blockquote><hr><h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><h4 id="短连接："><a href="#短连接：" class="headerlink" title="短连接："></a>短连接：</h4><blockquote><p>建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</p></blockquote><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><blockquote><p>建立连接——数据传输…(保持连接)…数据传输——关闭连接</p></blockquote><hr><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="长连接-1"><a href="#长连接-1" class="headerlink" title="长连接"></a>长连接</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote><ul><li>省去较多的TCP建立和关闭的操作，减少浪费，节约时间。</li></ul></blockquote><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><blockquote><ul><li>存活功能的探测时间太长，Client与Server之间的连接如果不一直关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候。</li></ul></blockquote><h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><blockquote><ul><li>对于服务器管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。</li></ul></blockquote><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><blockquote><ul><li>如果客户端请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</li></ul></blockquote><hr><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="长连接-2"><a href="#长连接-2" class="headerlink" title="长连接"></a>长连接</h4><blockquote><ul><li>用于操作频繁，点对点的通讯，而且连接数不能太多情况。比如TCP连接的三次握手。数据库的连接。</li></ul></blockquote><h4 id="短连接-1"><a href="#短连接-1" class="headerlink" title="短连接"></a>短连接</h4><blockquote><ul><li>像WEB网站的http服务一般都用短连接，因此会消耗一定的资源。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;HTTP协议与TCP-IP的关系&quot;&gt;&lt;a href=&quot;#HTTP协议与TCP-IP的关系&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="随记" scheme="http://www.xingchuan.vip/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="http" scheme="http://www.xingchuan.vip/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>20.高性能MySQL(六)</title>
    <link href="http://www.xingchuan.vip/20.%E9%AB%98%E6%80%A7%E8%83%BDMySQL(%E5%85%AD).html"/>
    <id>http://www.xingchuan.vip/20.高性能MySQL(六).html</id>
    <published>2019-08-07T13:36:00.000Z</published>
    <updated>2019-08-16T03:08:12.678Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="一、为什么查询速度会慢"><a href="#一、为什么查询速度会慢" class="headerlink" title="一、为什么查询速度会慢"></a>一、为什么查询速度会慢</h3><blockquote><p>如果把查询看作是是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数。</p></blockquote><blockquote><p>通常来说，查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器时进行解析，生成执行计划，执行，并返回结果给客户端。”执行”是最重要的阶段，包括了大量为检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。</p></blockquote><blockquote><p>完成这些任务的时候，查询需要在不同的地方花费时间，包括网络、CPU计算，生成统计信息和执行计划，锁等待，还有内存操作、CPU操作和内存不足时导致I/O操作消耗时间。</p></blockquote><hr><h3 id="二、慢查询基础：优化数据访问"><a href="#二、慢查询基础：优化数据访问" class="headerlink" title="二、慢查询基础：优化数据访问"></a>二、慢查询基础：优化数据访问</h3><blockquote><p>大部分查询性能低下的原因是访问的数据太多，我们可以用下面两个步骤来分析：</p><blockquote><ul><li>确认应用程序是否在检索大量超过需要的数据。通常访问太多行，但有时候也可能是访问太多列。</li><li>确认MySQL服务层是否在分析大量超过需要的数据行。</li></ul></blockquote></blockquote><h4 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h4><h5 id="查询不需要的记录"><a href="#查询不需要的记录" class="headerlink" title="查询不需要的记录"></a>查询不需要的记录</h5><blockquote><ul><li>例如某新闻网站中取出100条记录，但是页面只显示10条，他们认为MySQL会执行查询，并返回10条数据，然后停止查询，实际情况是MySQL会查出所有结果集，客户端接收全部结果集，然后抛弃大部分数据，最有效的解决方法是在查询后面加LIMIT。</li></ul></blockquote><h5 id="多表联查时返回全部列"><a href="#多表联查时返回全部列" class="headerlink" title="多表联查时返回全部列"></a>多表联查时返回全部列</h5><blockquote><ul><li>例如：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * from a INNER JOIN B on a.id =  b.pid</span><br></pre></td></tr></table></figure><h5 id="总是取出全部列"><a href="#总是取出全部列" class="headerlink" title="总是取出全部列"></a>总是取出全部列</h5><blockquote><ul><li>尽量避免使用SELECT *。</li></ul></blockquote><h5 id="重复查询相同的数据"><a href="#重复查询相同的数据" class="headerlink" title="重复查询相同的数据"></a>重复查询相同的数据</h5><blockquote><ul><li>例如在用户评论的地方需要查询用户头像的URL，那么用户多次评论时候，可能会反复查询这个数据，比较好的方案是当初次查询时把数据缓存起来，需要的时候从缓存中取出。</li></ul></blockquote><h4 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h4><blockquote><p>在确定查询只返回需要的数据后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于MySQL，衡量查询的三个指标如下：</p><blockquote><ul><li>响应时间</li><li>扫描行数</li><li>返回行数<br>三个指标都会记录到MySQL的慢日志中，所以查询慢日志是找出扫描行数过多的查询的好办法。</li></ul></blockquote></blockquote><h5 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h5><blockquote><p>是两个部分之和：服务时间和等待时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间————可能是等I/O操作完成，也可能是等待行锁。</p></blockquote><blockquote><p>当你看到一个查询的响应时间时，先问问自己，这个时间是否在一个合理的值。</p></blockquote><h5 id="扫描的行数和返回的行数"><a href="#扫描的行数和返回的行数" class="headerlink" title="扫描的行数和返回的行数"></a>扫描的行数和返回的行数</h5><blockquote><p>分析查询时，查看该查询扫描的行数是非常有帮助的，理想情况下扫描的行数和返回的行数应该是相同的。实际情况这种情况并不多，在关联查询的时候，通常扫描和返回行数比位1:1-10：1之间。</p></blockquote><h5 id="扫描的行数和访问类型"><a href="#扫描的行数和访问类型" class="headerlink" title="扫描的行数和访问类型"></a>扫描的行数和访问类型</h5><blockquote><p>在EXPLAIN语句中type列反应了方位类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。速度从慢到快，扫描的行数也是从大到小。</p></blockquote><blockquote><p>如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引。</p></blockquote><blockquote><p>一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：</p><blockquote><ul><li>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</li><li>使用索引覆盖扫描来返回记录。直接从索引中过滤不需要的记录并返回命中的结果。</li><li>从数据表中返回数据，然后过滤不满足条件的记录。这在MySQL服务器层完成，需要先从数据表读出记录然后过滤。</li></ul></blockquote></blockquote><blockquote><p>如果发现查询需要扫描大量的数据但是只返回少数的行，那么通常可以尝试下面的技巧去优化它：</p><blockquote><ul><li>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对于行就额可以返回结果了。</li><li>改变库表结构。例如使用单独的汇总表。</li><li>重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。</li></ul></blockquote></blockquote><hr><h3 id="三、重构查询的方式"><a href="#三、重构查询的方式" class="headerlink" title="三、重构查询的方式"></a>三、重构查询的方式</h3><h4 id="一个复杂查询还是多个简单查询"><a href="#一个复杂查询还是多个简单查询" class="headerlink" title="一个复杂查询还是多个简单查询"></a>一个复杂查询还是多个简单查询</h4><blockquote><p>在传统实现中，总是强调数据层完成尽可能多的工作，但是有时候，将一个大查询分解为多个小查询是很有比较的。不弱在应用设计的时候，如果一个查询能够胜任还写成多个独立查询是不明智的。例如，我们看到有些应用对一个数据表做10次独立的查询来返回10行数据，每个查询返回一条结果，查询10次！</p></blockquote><h4 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h4><blockquote><p>对于一个大查询我们需要”分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分的查询结果。</p></blockquote><blockquote><p>删除旧数据就是很好的例子，如果使用一个大的语句一次完成的话，则需要一次锁住很多数据，沾满整个事务日志、耗尽系统资源，阻塞很多小的但很重要的查询。例如：我们每个月运行一次下面的查询：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM messages WHERE created &lt; DATE_SUB(NOW()，INTERVAL 3 MONTH);</span><br></pre></td></tr></table></figure><blockquote><ul><li>那么可以用下面的方法来完成同样的工作：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rows_affected = 0</span><br><span class="line">do&#123;</span><br><span class="line">    rows_affected = do_quert(</span><br><span class="line">        &quot;DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(),INTERVAL  3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">    ) where rows_affected &gt; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一次删除一万行是一个比较搞笑而且对服务器影响最小的做法。同事注意的是，每次删除数据之后，都暂停一会再做下一次删除，这样可以将服务器原来一次的压力分散到一个很长的时间段，就可以大大的降低对服务器的影响，还可以大大减少删除时对锁的持有时间。</p></blockquote><h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><blockquote><p>很多应用都会对关联查询进行分解，可以对每一个表进行一次单表查询，然后将结果在应用中关联。例如，下面这个查询：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT  * FROM tag</span><br><span class="line">    -&gt; JOIN tag_post ON tag_post.tag_id = tag.id</span><br><span class="line">    -&gt; JOIN post ON tag_post.post_id = post.id</span><br><span class="line">    -&gt; WHERE tag.tag = &apos;mysql&apos;;</span><br></pre></td></tr></table></figure><blockquote><p>可以分解为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT * FROM tag WHERE tag=&apos;mysql&apos;</span><br><span class="line">mysql&gt;SELECT * FROM tag_post WHERE tag_id = 1234;</span><br><span class="line">mysql&gt;SELECT * FROM post WHERE </span><br><span class="line">post.id in (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><blockquote><ul><li>让缓存效率更高，可以更方便地缓存单表查询对应的结果对象，比如上面查询的tag已经被缓存了，那么就可以跳过第一个查询，拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。</li><li>执行单个查询可以减少锁竞争。</li><li>做应用层管理，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。</li><li>查询本身效率会提示，上面例子中，使用IN()代替关联查询，可以让MySQL按照ID顺序进行查询。</li><li>减少冗余记录查询，意味着某条记录应用只需要查询一次，而在数据库关联，则可能需要重复地访问一部分数据。</li></ul></blockquote><hr><h3 id="四、查询执行的基础"><a href="#四、查询执行的基础" class="headerlink" title="四、查询执行的基础"></a>四、查询执行的基础</h3><blockquote><p>当向MySQL发送一个请求时，MySQL到底做了什么:</p><blockquote><ul><li>客户端发送一条查询给服务器。</li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li><li>服务端进行SQL解析，预处理，再由优化器生成对应的执行计划。</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。</li><li>将结果返回给客户端。</li></ul></blockquote></blockquote><h4 id="MySQL客户端-服务器通信协议。"><a href="#MySQL客户端-服务器通信协议。" class="headerlink" title="MySQL客户端/服务器通信协议。"></a>MySQL客户端/服务器通信协议。</h4><blockquote><p>协议是”半双工”的，意味着在任何时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，两个动作不能同时发生。</p></blockquote><h5 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h5><blockquote><p>对于一个MySQL连接，或者说一个线程，任何时刻都有一个状态，该状态表示了MySQL当前在什么。使用SOW FULL PROCESSLIST命令可以查看，主要有下面几种状态：</p><blockquote><ul><li>Sleep:<br>线程正在等待客户端发送新的请求。</li><li>Query:线程正在执行查询或者正在将结果返回给客户端。</li><li>Locked:在MySQL服务器层，该线程正在等待表锁</li><li>Analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划。</li><li>Copying to tmp table[on disk]:线程正在执行查询，并且将其结果集都复制到一个临时表，这种状态一般要么是在做GROUP BY操作，要么是文件排序操作，或者是UNION操作。如果后面还有”on disk”标记，那表示MySQL正在将一个内存临时表放到磁盘上。</li><li>Sorting result:线程正在对结果集进行排序。</li><li>Sending data:线程可能在多个状态之间传送数据，或者在生成接过戒，或者在向he护短返回数据。</li></ul></blockquote></blockquote><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><blockquote><p>在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。</p></blockquote><blockquote><p>这个检查是通过对一个大小写敏感的哈希查找实现的，即使有一个字节不同，都不会匹配缓存结果。</p></blockquote><blockquote><p>如果命中了缓存，在返回查询结果之前MySQL会检查一次用户权限，如果没有问题，MySQL会跳过其他所有阶段，直接从缓存中拿到结果返回到客户端。</p></blockquote><h4 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h4><blockquote><p>查询的下一步是将一个SQL转换成一个执行计划，MySQL再依照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析SQL、预处理、优化SQL执行计划，这个过程中出现任何错误都会终止查询。</p></blockquote><h5 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h5><blockquote><p>首先MySQL通过关键字将SQL语句进行解析，并生成一颗对应的”解析树”。使用MySQL语法规则验证和解析查询，比如验证是否使用错误的关键词，或者使用关键词的顺序是否正确，验证引号是否能前后正确匹配。</p></blockquote><blockquote><p>预处理器则根据一些MySQL规则进一步检查解析树是否合法。例如检查数据表和数据列是否存储在，还会解析名字和别名，看它们是否有歧义。</p></blockquote><h5 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h5><blockquote><p>作用是找出这其中最好的执行计划。有很多原因会导致MySQL优化器选择错误的执行计划：</p><blockquote><ul><li>统计信息不准确。</li><li>执行计划中的成本估算不等同于实际执行的成本。</li><li>MySQL的最优可能和你想的最优不一样。</li><li>MySQL从不考虑其他并发执行的查询，这可能会影响到当前查询的速度。</li><li>MySQL也并不是任何时候都是基于成本的优化。</li><li>MySQL不会考虑不受其控制的操作的成本，例如执行存储过程或者用户自定义函数的成本。</li></ul></blockquote></blockquote><blockquote><p>优化策略简单的分为两种，一种是静态优化，一种是动态优化。</p><blockquote><ul><li>静态优化：可以直接对解析树进行分析，并完成优化。例如可以通过一些简单的点出变换将WHERE条件转成另一种等价形式。静态优化不依赖于特别的数值，例如WHERE中带入的一些常数。在第一次完成后就一直有效，既是使用不同参数执行查询页不会发生变化。</li><li>动态优化：和查询的上下文有关，也可能和很多其他因素有关，例如WHERE条件中的取值，索引中条目对于的数据行数等。这需要在每次查询的时候重新评估。</li></ul></blockquote></blockquote><blockquote><p>下面是一些MySQL能够处理的优化类型：</p><blockquote><ul><li>重新定义关联表顺序</li><li>将外连接转化成内连接</li><li>使用等价变换规则</li><li>优化COUNT()、MIN()和MAX()</li><li>预估并转化为常数表达式</li><li>覆盖扫描索引</li><li>子查询优化</li><li>提前终止查询</li><li>等值传播</li><li>列表IN()的比较</li></ul></blockquote></blockquote><h5 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a>数据和索引的统计信息</h5><blockquote><p>因为服务器没有任何统计信息，索引MySQL查询优化器在生成查询的执行计划时，需要向存储引擎获取相应的统计信息。存储引擎则提供给优化器对于的统计信息。包括：每个表或者索引有多少个页面、每个表的索引的基数是多少、数据行和索引长度、索引的分布信息等。</p></blockquote><h5 id="MySQL如何执关联查询"><a href="#MySQL如何执关联查询" class="headerlink" title="MySQL如何执关联查询"></a>MySQL如何执关联查询</h5><blockquote><p>总的来说，MySQL任务任何一个查询都是一次”关联”————并不仅仅是一个查询需要到两个表匹配才叫关联。</p></blockquote><blockquote><p>MySQL执行策略很简单：对于任何关联都执行嵌套虚幻关联操作，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到索引表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。</p></blockquote><h5 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h5><blockquote><p>MySQL优化器最重要的一部分就是关联查询优化，它决定了多个表关联时的顺序。通常多表关联的时候，可以有多种不同的关联顺序来获得相同的执行结果。关联查询优化器则通过评估不同顺序时的成本来选择一个代价最小的关联顺序。</p></blockquote><h5 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h5><blockquote><p>两种排序算法</p><blockquote><ul><li>两次排序算法(旧版本使用)：读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。这里需要进行两次数据传输，即需要从数据表中读取两次数据，第二次读取数据的时候，因为是读取排序列进行排序后的所有记录，这会产生大量的随机I/O，所有两次数据传输的成本非常高。</li><li>优点：在排序的时候存储尽可能少的数据，这就让”排序缓冲区”中可能容纳尽可能多的行数进行排序。</li></ul></blockquote></blockquote><blockquote><blockquote><ul><li>单次传输排序：先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。</li><li>缺点：如果返回的列非常多、非常大、会额外占用大量的空间，而这些列对排序操作本身来说没有任何作用。因为单条排序记录很大，所以可能会有更多的排序块需要合并。</li></ul></blockquote></blockquote><h4 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h4><blockquote><p>在解析和优化阶段，MySQL将生产查询对于的执行计划，MySQL的查询执行引擎则根据这个执行计划来完成整个查询。</p></blockquote><h4 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h4><blockquote><p>最后一个阶段是将结果返回给客户端。如果查询可以被缓存，则会将MySQL在这个阶段也会将结果存放到查询缓存中。</p></blockquote><blockquote><ul><li>MySQL将结果集返回客户端是一个增量、逐步返回的过程。当开始生产第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。<blockquote><ul><li>服务端无需存储太多的结果。也就不会 因为要返回太多结果而消耗太多内存，另外，也让MySQL客户端第一时间获得返回的结果。</li></ul></blockquote></li></ul></blockquote><hr><h3 id="五、MySQL查询优化器的局限性"><a href="#五、MySQL查询优化器的局限性" class="headerlink" title="五、MySQL查询优化器的局限性"></a>五、MySQL查询优化器的局限性</h3><h4 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h4><blockquote><p>MySQL会将相关的外层表压倒子查询中，它认为这样可以更高效地查询到数据行。</p></blockquote><h4 id="UNION的限制"><a href="#UNION的限制" class="headerlink" title="UNION的限制"></a>UNION的限制</h4><blockquote><p>无法限制调教从外层”下推”到内层，这使得原本能够限制部分返回的结果的条件应用到内层查询的优化上。</p></blockquote><blockquote><p>例如：如果想将两个子查询结果联合起来，然后再取前20条记录，那么MySQL会将两个表都存放到同一个临时表中，然后再取出前20行记录：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(SELECT first_name,last_name</span><br><span class="line">FROM sakila.actor ORDER BY last_name) </span><br><span class="line">UNION ALL </span><br><span class="line">(SELECT first_name,last_name </span><br><span class="line">FROM sakila,customer ORDER BY last_name) </span><br><span class="line">LIMIT 20;</span><br></pre></td></tr></table></figure><blockquote><p>这条查询将会把actor中的200条记录和customer表中的599条记录存放在一个临时表，然后再从临时表中取出前20条。可以通过在UNION的两个子查询中分别加上一个LIMIT 20来减少临时表中的数据：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(SELECT first_name,last_name</span><br><span class="line">FROM sakila.actor ORDER BY last_name </span><br><span class="line">LIMIT 20) </span><br><span class="line">UNION ALL </span><br><span class="line">(SELECT first_name,last_name </span><br><span class="line">FROM sakila,customer ORDER BY last_name</span><br><span class="line">LIMIT 20) </span><br><span class="line">LIMIT 20;</span><br><span class="line">#### 索引合并优化</span><br><span class="line">&gt; 当WHERE子句中包含多个复杂条件的时候，MySQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行。</span><br></pre></td></tr></table></figure><h4 id="等值传递"><a href="#等值传递" class="headerlink" title="等值传递"></a>等值传递</h4><blockquote><p>会带来一些意想不到的额外消耗。例如，有一个非常大的IN()列表，而MySQL优化器发现存在WHERE、ON或者USING的子句，将这个列表的值和另一个表的某个列相关联。</p></blockquote><h4 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h4><blockquote><p>MySQL无法利用多核特性来并行执行查询。</p></blockquote><h4 id="哈希关联"><a href="#哈希关联" class="headerlink" title="哈希关联"></a>哈希关联</h4><blockquote><p>MySQL并不支持哈希关联，不过可以通过建立一个哈希索引来曲线的实现哈希关联。如果使用的是Memry存储引擎，则所有都是哈希索引，所以关联的时候也类似于哈希关联。</p></blockquote><h4 id="松散索引扫描"><a href="#松散索引扫描" class="headerlink" title="松散索引扫描"></a>松散索引扫描</h4><blockquote><p>假如我们有如下索引(a,b)，有下面的查询：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT ... FROM tb1 WHERE b BETWEEN 2 AND 3;</span><br></pre></td></tr></table></figure><blockquote><p>因为索引的前导字段是列a,但是在查询中只指定了字段b，MySQL无法使用这个索引，只能通过全表扫描找到匹配的行。</p></blockquote><h4 id="最大值和最小值优化"><a href="#最大值和最小值优化" class="headerlink" title="最大值和最小值优化"></a>最大值和最小值优化</h4><blockquote><p>对于MIN()和MAX()查询，MySQL的优化做的并不好，例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT MIN(actor_id)FROM sakila.actor WHERE first_name = &apos;PENELOPE&apos;;</span><br></pre></td></tr></table></figure><blockquote><p>因为咋first_name字段上并没有索引，因此MySQL读到第一个满足条件的记录的时候，就不是外貌需要找的最小值了。但是主键是严格按照actor_id字段的大小顺序排列的。但是MySQL这只会做全表扫描。一个曲线的优化方法是移除MIN(),然后使用LIMIT来将查询重写如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT actor_id FROM sakila.actor USER INDEX(PRIMARY)</span><br><span class="line">    -&gt;WHERE first_name = &apos;PENELOPE&apos; LIMIT 1;</span><br></pre></td></tr></table></figure><hr><h3 id="六、优化特定类型的查询"><a href="#六、优化特定类型的查询" class="headerlink" title="六、优化特定类型的查询"></a>六、优化特定类型的查询</h3><h4 id="优化COUNT-查询"><a href="#优化COUNT-查询" class="headerlink" title="优化COUNT()查询"></a>优化COUNT()查询</h4><h5 id="COUNT-的作用："><a href="#COUNT-的作用：" class="headerlink" title="COUNT()的作用："></a>COUNT()的作用：</h5><blockquote><ul><li>统计某个列的数量，要求列值是非空的。</li><li>统计行数，当MySQL确认括号内的表达式不可能为空时，实际上就是在统计行数。</li></ul></blockquote><h5 id="关于MyISAM的神话"><a href="#关于MyISAM的神话" class="headerlink" title="关于MyISAM的神话"></a>关于MyISAM的神话</h5><blockquote><ul><li>一个容易产生的误解：MyISAM的COUNT()函数非常快，不过这是有前提条件的，即没有WHERE条件的COUNT(*)才非常快。当图片吗个抠带WHERE子句的结果集行数，可以是统计某个列值的数量时，MyISAM的COUNT()和其他存储引擎没有任何不同。</li></ul></blockquote><h5 id="简单的优化"><a href="#简单的优化" class="headerlink" title="简单的优化"></a>简单的优化</h5><blockquote><p>有时候可以通过使用MyISAM在COUNT(*)全表非常快的这个特性，来加速一些特定条件的COUNT()的查询。例如下面例子中，我们要获得所有ID大于5的城市：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT COUNT(*) FROM world.City WHERE ID &gt; 5;</span><br></pre></td></tr></table></figure><blockquote><p>需要查询4097行数量。如果将条件反转下，先查询ID小于5的城市，然后用总城市数一减就能得到相同的结果，却能让扫描的行数减少到5行内。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT (SELECT COUNT(*) FROM world.City)-COUNT(*)</span><br><span class="line">    -FROM world.City WHERE ID &lt;= 5;</span><br></pre></td></tr></table></figure><h5 id="使用近似值"><a href="#使用近似值" class="headerlink" title="使用近似值"></a>使用近似值</h5><blockquote><p>有些业务场景并不需要完全精确的COUNT值，此时可以用近似值来代替，例如统计当前活跃用户数是多少，这个活跃用户数保存在缓存中，过期时间为30分钟，所以每隔30分钟需要重新计算放入缓存，因此这个活跃用户数本身就不是精确值。</p></blockquote><h5 id="更复杂的优化"><a href="#更复杂的优化" class="headerlink" title="更复杂的优化"></a>更复杂的优化</h5><blockquote><p>除了前面的方法，在MySQL层面上还能做的就是索引覆盖扫描。如果这还不够，就需要考虑修改应用的架构，可以增加汇总表。</p></blockquote><h4 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h4><blockquote><ul><li>确保ON或者USING子句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表A和表B用列c关联的时候，如果优化器的关联顺序是B、A，那么就不需要在B表的对应列上建上索引。没有用到的索引只会带来额外的负担。</li><li>确保任何的GROUP BY和ORDER BY中国的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。</li><li>当升级MySQL的时候需要注意：关联语法、运算符优先级等其他可能会发生变化的地方。</li></ul></blockquote><h4 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h4><blockquote><p>尽可能的使用关联查询来代替</p></blockquote><h4 id="优化GROUP-BY和DISTINCT"><a href="#优化GROUP-BY和DISTINCT" class="headerlink" title="优化GROUP BY和DISTINCT"></a>优化GROUP BY和DISTINCT</h4><blockquote><p>很多情况下。MySQL优化器都会使用索引来优化，如果无法使用索引的时候，GROUP BY使用两种策略来完成：使用临时表或者文件排序来做分组。</p></blockquote><blockquote><p>如果需要对关联查询做分组，并且按照查找表中的某个列进行分组，那么铜牛广场采用查找表的标识符列分组的效率会比其他列更高。例如下面的查询效率不会很好</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT actor.first_name,actor.last_name,COUNT(*)</span><br><span class="line">    -&gt; FROM sakila.film_actor</span><br><span class="line">    -&gt;  INNER JOIN sakila.actor USING(actor_id)</span><br><span class="line">    -&gt;GROUP BY actor.first_name,actor.last_name;</span><br></pre></td></tr></table></figure><blockquote><p>如果查询按照下面的写法效率则会更高：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT actor.first_name,actor.last_name,COUNT(*)</span><br><span class="line">    -&gt; FROM sakila.film_actor</span><br><span class="line">    -&gt;  INNER JOIN sakila.actor USING(actor_id)</span><br><span class="line">    -&gt;GROUP BY film_actor.actor_id;</span><br></pre></td></tr></table></figure><h5 id="优化GROUP-BY-WITH-ROLLUP"><a href="#优化GROUP-BY-WITH-ROLLUP" class="headerlink" title="优化GROUP BY WITH ROLLUP"></a>优化GROUP BY WITH ROLLUP</h5><blockquote><p>分组查询的一个变种就是要求MySQL对返回的分组结果再做一次超级聚合，可以使用WITH ROLLUP子句来实现这种逻辑，但可能会不够优化。尽可能的将WITH ROLLUO功能转移到应用程序中处理。</p></blockquote><h4 id="优化LIMIT分页。"><a href="#优化LIMIT分页。" class="headerlink" title="优化LIMIT分页。"></a>优化LIMIT分页。</h4><blockquote><p>通常使用LIMIT加上偏移量的办法实现，同时加上合适的ORDER BY子句。如果有对应的索引，通常效率会不错。但是如果偏移量非常大的时候，例如LIMIT 1000,20这样的查询，这时候MySQL需要查询10029条记录然后只返回最后20条，前面10000条记录都会被抛弃，这样代价非常高。优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。</p></blockquote><blockquote><p>优化此类分页查询最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。考虑如下查询：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT film_id,description FROM sakili.film ORDER BY title LIMIT 50,5;</span><br></pre></td></tr></table></figure><blockquote><p>如果这个表非常大，那么这个查询最好改写成下面的样子：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT film.film_id,film,description</span><br><span class="line">    -&gt; FROM sakila.film</span><br><span class="line">    -&gt;  INNER JOIN(</span><br><span class="line">    -&gt;      SELECT film_id FROM sakila.film </span><br><span class="line">    -&gt;      ORDER BY title LIMIT 50,5</span><br><span class="line">    -&gt;  ) AS lim USING(film_id);</span><br></pre></td></tr></table></figure><blockquote><p>这里的”延迟关联”将大大提升查询效率它让MySQL扫描尽可能少的页面，获得要访问的记录然后再更加关联列回原表查询需要的所有列。</p></blockquote><blockquote><p>有时候也可以将LIMIT查询转换为已知位置的查询，让MySQL通过范围扫描获得到对于的结果。例如，如果在一个位置列上有索引，并且预先计算出边界值，上面的查询就可以改为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT film_id,description FROM sakila.film</span><br><span class="line">    -&gt; WHERE postion BETWEEN 50 AND 54 ORDER BY postion;</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET。</li></ul></blockquote><h4 id="优化-SQL-CALC-FOUND-ROWS"><a href="#优化-SQL-CALC-FOUND-ROWS" class="headerlink" title="优化 SQL_CALC_FOUND_ROWS"></a>优化 SQL_CALC_FOUND_ROWS</h4><blockquote><p>将具体页数转换成”下一页”按钮，假设每页显示20条记录，那么我们每次查询都用LIMIT返回21条记录并只显示20条，如果21条存在，那么我们就显示”下一页”按钮，否则就说明没有更多的数据，也就无须显示”下一页”按钮了。</p></blockquote><blockquote><p>另一种方法就是获取并缓存较多的数据，例如，缓存1000条数据，然后每次分页都从这个缓存中获取，就可以让应用程序根据结果集的大小采取不同的策略，如果结果集少于1000，就可以在页面上显示所有的分页连接，因为数据都是在换乘站，所以这样的性能不会用问题。</p></blockquote><h4 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h4><blockquote><p>MySQL总是创建并填充临时表的方式来执行UNION查询，因此很多优化策略在UNION查询中没法很好地使用。</p></blockquote><blockquote><p>除非区呃呃是需要服务器消除重复的行，否则就一定要使用UNION ALL，这一点很重要。如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项，这会导致对整个临时表的数据做唯一性检查。这样做的代价非常高。即使有ALL关键字，MySQL仍然会使用临时表存储结果。事实上，MySQL总是很结果放入临时表，然后再读出，再返回给客户端。</p></blockquote><h4 id="静态查询分析"><a href="#静态查询分析" class="headerlink" title="静态查询分析"></a>静态查询分析</h4><blockquote><p>Percona Toolkit中的pt-query-advisor能够解析查询日志、分析查询模式，然后给出所有可能存在潜在问题的查询，并给出足够详细的建议。</p></blockquote><h4 id="使用用户自定义变量"><a href="#使用用户自定义变量" class="headerlink" title="使用用户自定义变量"></a>使用用户自定义变量</h4><blockquote><p>是一个用来存储内容的临时容器，在连接MySQL的整个过程中都存在。可以使用下面的SET和SELECT语句来定义它们：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET @one       :=1;</span><br><span class="line">mysql&gt; SET @min_actor :=(SELECT MIN(actor_id) FROM sakila.actor)；</span><br><span class="line">mysql&gt; SET @last_week := CURRENT_DATE-INTERVAL 1 WEEK;</span><br></pre></td></tr></table></figure><blockquote><p>然后可以再任何可以使用表达式的地方使用这些自定义变量：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT ...WHERE col &lt;= @last_week;</span><br></pre></td></tr></table></figure><h5 id="下面情况无法使用自定义变量"><a href="#下面情况无法使用自定义变量" class="headerlink" title="下面情况无法使用自定义变量"></a>下面情况无法使用自定义变量</h5><blockquote><ul><li>使用自定义变量的查询，无法使用查询缓存。</li><li>不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名和LIMIT子句中。</li><li>用户自定义变量的生命周期是在一个链接中有效，所有不能用它们来做连接间的通信。</li><li>如何使用连接池或者持久化连接，自定义变量可能让看起来毫无关系的代码发生交互。</li><li>不能显式地声明自定义变量的类型。确定未定义变量的具体类型的时机在不同MySQL版本中也可能不一样。如果你希望变量是整数类型，那么最好在初始哈的时候就赋值为0，如果希望是浮点型则赋值为0.0，如果希望是字符串则赋值’’,用户自定义变量的类型在赋值的时候会改变。</li><li>MySQL优化器在某些场景下可能会将这些变量优化掉，这可能会导致代码不按预想的方式运行。</li><li>赋值的顺序和赋值的时间点并不总是固定的，这依赖于优化器的决定。</li><li>赋值符号:=的优先级非常低，所有需要注意，赋值表达式应该使用明确的括号。</li><li>使用未定义变量不会产生任何语法错误。</li></ul></blockquote><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><blockquote><ul><li>查询运行时计算总数和平均值。</li><li>模拟GROUP语句中的函数FIRST()和LAST()。</li><li>对大数据做一些数据计算。</li><li>计算一个大表的MD5散列值。</li><li>编写一个样本处理函数，当样本中的数值超过某个边界值的时候将其变成0。</li><li>模拟读/写游标。</li><li>在SHOW语句的WHERE子句中加入变量值。</li></ul></blockquote><hr><h3 id="七、案例学习"><a href="#七、案例学习" class="headerlink" title="七、案例学习"></a>七、案例学习</h3><h4 id="使用MySQL构建一个队列表"><a href="#使用MySQL构建一个队列表" class="headerlink" title="使用MySQL构建一个队列表"></a>使用MySQL构建一个队列表</h4><blockquote><p>是一种取巧的做法。典型的模式是一个表包含多种类型的记录；未处理记录、已处理记录、正在处理记录等。一个或多个消费者线程在表中查找未处理的记录，然后声称正在处理，当处理完后，再将记录更新成已处状态。</p></blockquote><blockquote><p>通常有两个原因认为这样的处理方式并不合适。</p><blockquote><p><strong>第一</strong> :随着队列表越来越大和索引深度的增加，找到未记录的速度会随之变慢，可以通过将队列表分成两个部分来解决这个问题，就是将已处理记录归档或者存放到历史表。这可以始终保证队列表很小。<br><strong>第二</strong> :一般的处理过程分两步，先找到未处理记录然后加锁。找到记录会增加服务器压力，而加锁操作则会让各个消费者进程增加竞争，因为这是一个串行化的操作。</p></blockquote></blockquote><h5 id="基础原则："><a href="#基础原则：" class="headerlink" title="基础原则："></a>基础原则：</h5><blockquote><ul><li>尽量少做事，可以的话不要做任何事情，除非不得已。否则不要使用轮询，因为这会增加负担。</li><li>尽可能地完成需要做的事情。尽量使用UPDATE代替先SELECT FOR UPDATE再UPDATE的写法，因为事务提交的速度越快，持有的锁时间就越短，保证数据集足够小。</li><li>某些查询是无法优化的；考虑使用不同的查询或者不同的策略去实现相同的目的。</li></ul></blockquote><blockquote><p>有时，最好的办法就是将任务队列从数据库中迁移出来。Redis就是一个很好的队列容器，也可以使用memcached来实现。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、为什么查询速度会慢&quot;&gt;&lt;a href=&quot;#一、为什么查询速度会慢&quot; class=&quot;headerlink&quot; title=&quot;一、为什么
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://www.xingchuan.vip/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>18.高性能MySQL(四)</title>
    <link href="http://www.xingchuan.vip/18.%E9%AB%98%E6%80%A7%E8%83%BDMySQL(%E5%9B%9B).html"/>
    <id>http://www.xingchuan.vip/18.高性能MySQL(四).html</id>
    <published>2019-08-05T15:00:00.000Z</published>
    <updated>2019-08-16T03:08:03.998Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="一、选择优化的数据类型"><a href="#一、选择优化的数据类型" class="headerlink" title="一、选择优化的数据类型"></a>一、选择优化的数据类型</h3><h4 id="基本原则："><a href="#基本原则：" class="headerlink" title="基本原则："></a>基本原则：</h4><h5 id="更小的通常更好"><a href="#更小的通常更好" class="headerlink" title="更小的通常更好"></a>更小的通常更好</h5><blockquote><ul><li>尽可能选择更小的数据类型，通常更快，因为它们占用更少的磁盘、内存和CPU缓存</li></ul></blockquote><h5 id="简单就好"><a href="#简单就好" class="headerlink" title="简单就好"></a>简单就好</h5><blockquote><ul><li>简单的数据类型通常需要更少的CPU周期。例如，整型比字符操作代价更低，因为字符集和校对规则使字符串比整型复杂。</li></ul></blockquote><h5 id="尽量避免NULL"><a href="#尽量避免NULL" class="headerlink" title="尽量避免NULL"></a>尽量避免NULL</h5><blockquote><ul><li>尽可能指定为NOT NULL，因为包含NULL的列优化更难，使得索引、索引统计和值比较都更复杂。NULL值列会使用更多的存储空间，当可为NULL的列被索引时，每个索引记录都需要一个额外的字节。</li></ul></blockquote><blockquote><ul><li>很多MySQL的数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同，活着需要的物理空间不同。</li><li>例如：DATETIME和TIMESAMP列都可以存储相同类型的数据：时间和日起，精确到秒，然而TIMESTAMP只使用DATETIME一半的存储空间，并且会根据时区变化，具有自动更新能力。另一方面，TIMESTAMP允许的时间范围要小的多。</li></ul></blockquote><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><blockquote><ul><li>有两种类型的数字：整数和实数。可以使用：TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT,分别使用8，16，24，32，64位存储空间。</li></ul></blockquote><blockquote><ul><li>有可选的UNSIGNED属性，表示不允许负值。可以使正数的上线提升一倍，例UNSUGNED可存储范围0<del>255，TINYINT的存储范围-128</del>127。</li></ul></blockquote><blockquote><ul><li>可以为整数类型指定宽度，但是没有意义：它不会限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数，对于存储和计算来说，INT(1)和INT(20)是一样的。</li></ul></blockquote><h4 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h4><blockquote><ul><li>是带有小数部分的数字。它们不只是为了存储小数部分，也可以使用DECIMAL存储比BIGINT还大的整数。</li></ul></blockquote><blockquote><ul><li>DECIMAL类型用于存储精确的小数，在MySQL5.0以及更高版本中，服务器自身实现了DECIMAL的高精度运算，最多允许65个数字。</li></ul></blockquote><blockquote><ul><li>有多种方法可以指定浮点列所需要的精度，这会使得MySQL悄悄的选择不同的数据类型，或者在存储时对值进行取舍。这些进度是非标准的，所有我们建议只指定数据类型，不指定精度。MySQL使用DOUBLE作为内部浮点计算的类型。</li></ul></blockquote><blockquote><ul><li>因为需要额外的空间和计算开销，所有应该尽量只在对小数进行精确计算时才是用DECIMAL————例如存储财务数据。但在数量量比较大的时候，可以考虑使用BIGINT代替DECIMAL。将需要储存的货币单位更加小数的位数乘以相应的倍数即可。假设要存储财务数据精确到万分之一分，则可以把所有金额乘以一百万，然后将结果存储在BIGINT里。这样可以同时避免浮点存储计算不精确和DECIMAL精确计算代价高的问题。</li></ul></blockquote><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><h5 id="VARCHAR"><a href="#VARCHAR" class="headerlink" title="VARCHAR"></a>VARCHAR</h5><blockquote><ul><li>VARCHAR类型用于存储可変长字符串，是最常见的字符串类型。它比定长类型要节省空间，因为它仅适用必要的空间。</li></ul></blockquote><blockquote><ul><li>需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255，则只使用1个字节表示，否则使用2个字节。</li></ul></blockquote><blockquote><ul><li>由于行是变长的，在UPDATE时可能使行变得比原来更长，这就导致需要额外的工作。如果一个行占用的空间增长，并且页内没有更多的空间可以存储，在这种情况下，不同的存储引擎的处理方式是不一样的。例如，MyLSAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。</li></ul></blockquote><blockquote><ul><li>使用场景：字符串列的最大长度比平均长度大很多，列的更新很少，所以碎片不是问题。</li></ul></blockquote><h5 id="CHAR"><a href="#CHAR" class="headerlink" title="CHAR"></a>CHAR</h5><blockquote><ul><li>CHAR类型是定长的，当存储CHAR值时，MySQL会删除索引的末尾空格。CHAR值会更加需要采用空格进行填充以方便比较。</li></ul></blockquote><blockquote><ul><li>适合存储很短的字符串。例如存储密码的MD5值，索引值都接近一个长度。对于经常变更的数数据，CHAR也比VARCHAR更好，因为定长的CHAR类型不容易产生碎片。对于非常短的列，CHAR比VARCHAR在存储空间上，例如用CHAR(1)来存储只有Y和N的值，如果采用单字节字符集只需要一个字节，但是VARCHAR(1)缺需要两个字节，因为还有一个记录长度的额外字节。</li></ul></blockquote><h5 id="BLOB和TEXT类型"><a href="#BLOB和TEXT类型" class="headerlink" title="BLOB和TEXT类型"></a>BLOB和TEXT类型</h5><blockquote><ul><li>BLOB和TEXT都是为存储很大的数据库而设计的字符串数据类型，分别采用二进制和字符方式存储。</li></ul></blockquote><blockquote><ul><li>与其他类型不同，MySQL把每个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的”外部”存储区域来进行存储。</li></ul></blockquote><blockquote><p>BLOB和TEXT家族之间仅有的不同是BLOE类型存储的是二进制数据，没有排序规则或字符集，而TEXT类型有字符集和排序规则。</p></blockquote><blockquote><p>MySQL不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些鄋消除排序。</p></blockquote><h5 id="使用枚举-ENUM-代替字符串类型"><a href="#使用枚举-ENUM-代替字符串类型" class="headerlink" title="使用枚举(ENUM)代替字符串类型"></a>使用枚举(ENUM)代替字符串类型</h5><blockquote><ul><li>有时候可以使用枚举列代替常用的字符串操作。枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在内部会将每个值在列表中的位置保存为整数。</li></ul></blockquote><blockquote><ul><li>MySQL会在内部将每个值在列表中的位置保存为整数。尽量避免使用数字作为ENUM枚举常量，这种双重性很容易导致混乱。</li></ul></blockquote><h4 id="时期和时间类型"><a href="#时期和时间类型" class="headerlink" title="时期和时间类型"></a>时期和时间类型</h4><blockquote><ul><li>可以使用许多类型来保存日期和时间值，例如YEAR和DATE。MySQL能存储的最小时间粒度为秒。但是MySQL可以使用为微妙级的粒度进行临时运算，我们会展示怎么绕开这种存储限制。</li></ul></blockquote><h5 id="DATETIME"><a href="#DATETIME" class="headerlink" title="DATETIME"></a>DATETIME</h5><blockquote><ul><li>能保存最大范围的值，从1001年到9999年，精度为秒。它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。</li></ul></blockquote><h5 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h5><blockquote><ul><li>保存了从1970年1月1日以来的描述，它和UNIX时间戳相同。只使用4个字节的存储空间，因此范围比DATETIME小得多：只能表示从1970年到2038年。</li></ul></blockquote><blockquote><ul><li>显示地值也依赖于时区。存储值为0的TIMESTAMP在美国东部时区显示为”1969-12-31 19:00:00”，与格林尼治差5个小时。如果在多个时区存储或者访问数据，TIMESTAMP和DATETIME的行为将很不一样。前者提供的值与时区有关系，后者则保存文本表示的时间和日期。</li></ul></blockquote><blockquote><ul><li>TIMESTAMP在默认情况下，如果插入时没有指定第一个TIMESTAMP列的值，MySQL则设置这个列的值为当前时间。在插入一行记录时，MySQL默认也会更新第一个TIMESTAMP列的值。默认为NOT NULL。</li></ul></blockquote><blockquote><ul><li>除了特殊行为之外，通常也应该尽量使用TIMESTAMP,因此它比DATETINE空间效率更高。</li></ul></blockquote><h4 id="位数据类型"><a href="#位数据类型" class="headerlink" title="位数据类型"></a>位数据类型</h4><h5 id="BIT"><a href="#BIT" class="headerlink" title="BIT"></a>BIT</h5><blockquote><ul><li>可以使用BIT列在一列中存储一个或多个true/false值。BIT(1)定义一个包含单个位的字段，BIT(2)存储2个位。依次类推，BIT列的最大长度是64个位。</li></ul></blockquote><blockquote><ul><li>MySQL把BIT当做字符串类型，而不是数据类型。在数字上下文的场景中检测时，结果将是位字符串转换成的数字。</li></ul></blockquote><blockquote><ul><li>对于大部分应用，最好避免使用这个类型。</li></ul></blockquote><h5 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h5><blockquote><ul><li>如果需要保存很多true/false值，可以考虑合并这些列到一个SET数据类型，它在MySQL内部是以一系列打包的位的集合来表示的。</li></ul></blockquote><h4 id="选择标识符"><a href="#选择标识符" class="headerlink" title="选择标识符"></a>选择标识符</h4><h5 id="整数类型-1"><a href="#整数类型-1" class="headerlink" title="整数类型"></a>整数类型</h5><blockquote><ul><li>标识列最好的选择，因为它们可很快并且使用AUTO_UINCREMENT。</li></ul></blockquote><h5 id="字符串类型-1"><a href="#字符串类型-1" class="headerlink" title="字符串类型"></a>字符串类型</h5><blockquote><ul><li>如果可能，应该避免使用字符串类型作为标识符，因此它们很消耗空间，并且通常比数字类型慢。MyISAM默认对字符串使用压缩索引，这会导致查询慢得多。</li></ul></blockquote><h4 id="特殊类型数据"><a href="#特殊类型数据" class="headerlink" title="特殊类型数据"></a>特殊类型数据</h4><blockquote><ul><li>某些类型的数据并不直接与内存类型一致，低于秒级精度的时间戳就是一个例子，另一个领子是IPV4。</li></ul></blockquote><h3 id="二、MySQL-schema设计中的陷阱"><a href="#二、MySQL-schema设计中的陷阱" class="headerlink" title="二、MySQL schema设计中的陷阱"></a>二、MySQL schema设计中的陷阱</h3><h4 id="太多的列"><a href="#太多的列" class="headerlink" title="太多的列"></a>太多的列</h4><blockquote><ul><li>MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通<br>过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。</li></ul></blockquote><h4 id="太多的关联"><a href="#太多的关联" class="headerlink" title="太多的关联"></a>太多的关联</h4><blockquote><ul><li>Mysql限制了每个关联操作最多只能有61张表，一个粗略的经验法则，如果希望查询执行得快速且并发性好，单个查询最好在12个表内做关联。</li></ul></blockquote><h4 id="全能的枚举"><a href="#全能的枚举" class="headerlink" title="全能的枚举"></a>全能的枚举</h4><blockquote><ul><li>注意防止过度使用枚举，在MySQL中，当需要在枚举列表中则增加一个新的国家时就要做一次ALTER TABLE。</li></ul></blockquote><h4 id="变相的枚举"><a href="#变相的枚举" class="headerlink" title="变相的枚举"></a>变相的枚举</h4><blockquote><ul><li>枚举列允许在列中存储一组定义值中的单个值，集合(SET)则允许在列中存储一组定义值中的一个或多个值。有时候这可能比较容易导致混乱。</li></ul></blockquote><h4 id="非此发明的NULL"><a href="#非此发明的NULL" class="headerlink" title="非此发明的NULL"></a>非此发明的NULL</h4><blockquote><ul><li>我们之前写了避免使用NULL的好处，并且建立尽可能地考虑替代方案，既是需要存储一个事实上的”空值”到表中，也不一定非得使用NULL。也许可以使用0。</li></ul></blockquote><h3 id="三、范式和反范式"><a href="#三、范式和反范式" class="headerlink" title="三、范式和反范式"></a>三、范式和反范式</h3><blockquote><ul><li>对于任何给定的数据通常都有很多种表示方法，从完全的范式化到完全的反范式化，以及两者的折中。在范式化的数据库中，每个事实数据都会出现且并且只出现一次。相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方。</li></ul></blockquote><h4 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h4><h5 id="1NF：无重复的列"><a href="#1NF：无重复的列" class="headerlink" title="1NF：无重复的列"></a>1NF：无重复的列</h5><blockquote><ul><li>无重复的列，表中的每一列都是不可分割的数据基本项，不满足1NF的数据库不是关系型数据库。</li></ul></blockquote><h5 id="2NF：数据完全依赖于主键"><a href="#2NF：数据完全依赖于主键" class="headerlink" title="2NF：数据完全依赖于主键"></a>2NF：数据完全依赖于主键</h5><blockquote><ul><li>不能存在仅依赖于关键一部分的属性。</li></ul></blockquote><h5 id="3NF-属性不传递依赖于其它非主属性"><a href="#3NF-属性不传递依赖于其它非主属性" class="headerlink" title="3NF:属性不传递依赖于其它非主属性"></a>3NF:属性不传递依赖于其它非主属性</h5><blockquote><ul><li>非转件列必须直接依赖于主键而不能传递依赖。即不能是：非主键A依赖于非主键B，非主键B依赖于主键。</li></ul></blockquote><h4 id="范式的优点和缺点"><a href="#范式的优点和缺点" class="headerlink" title="范式的优点和缺点"></a>范式的优点和缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote><ul><li>范式化的更新操作通常比反范式化要快。</li><li>当书记较好地范式化时，就只有很少或者没有重复数据，所有只需要修改更少的数据。</li><li>范式化表通常更小，可以更好地放在内存里，所以只需操作会更快。</li><li>很少有多余的数据意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句。</li></ul></blockquote><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><blockquote><ul><li>通常需要关联，代价昂贵，也可能会使一些索引无效。例如范式化可能将列放在不同的表中，而这些列如果在一个表中本可以属于同一个索引。</li></ul></blockquote><h4 id="反范式的优点和缺点"><a href="#反范式的优点和缺点" class="headerlink" title="反范式的优点和缺点"></a>反范式的优点和缺点</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><blockquote><ul><li>因为数据都在一张表中，可以很好的避免关联。如果不需要关联表，既是是没有索引的全表扫描，也比关联也要快的多，因为这样避免了随机I/O。</li><li>单独的表也能使有效的索引策略。</li></ul></blockquote><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><blockquote><ul><li>有很多重复数据，会占用更多的内存，查询的时候会较多的使用DROUP BY或DISTINCT等耗时耗性能的关键字</li><li>当修改更新数据时候，范式更灵活，反范式要修改全部的数据，且容易出错。</li></ul></blockquote><h4 id="混用范式化和反范式化。"><a href="#混用范式化和反范式化。" class="headerlink" title="混用范式化和反范式化。"></a>混用范式化和反范式化。</h4><h5 id="网上案列"><a href="#网上案列" class="headerlink" title="网上案列"></a>网上案列</h5><blockquote><ul><li>举个例子，要查询社区里面最新的10个帖子，如果按照范式设计，那么将关联两个表，一张是帖子表，另外一张是会员表，整个查询如下：</li></ul></blockquote><blockquote><p>SELECT TOP 10 N.帖子标题, U.会员昵称,N.会员ID FROM 帖子表 N</p></blockquote><blockquote><p>JOIN 会员表 U</p></blockquote><blockquote><p>ON N.会员ID=U.会员ID</p></blockquote><blockquote><p>ORDER BY N.帖子ID DESC</p></blockquote><blockquote><p>这样的查询将产生两个聚集索引扫描，一个在帖子表上，另外一个在会员表上，然后再进行嵌套循环，当数据不多的时候，这样的查询没有问题，当两张 表都是百万数量级的时候，问题出现了，这个查询动不动就是几百毫秒，甚至更慢，这样的查询效率根本不能满足点评网对于网页速度的要求（一般不能超过100 毫秒），怎么办，当然要反范式，在帖子表里面添加冗余字段——会员昵称，这样我们就可以通过下面的查询达到同样的目的：</p></blockquote><blockquote><p>SELECT TOP 10 帖子标题, 会员昵称,会员ID FROM 帖子表 ORDER BY 帖子ID DESC</p></blockquote><blockquote><p>这个查询只需要通过一个聚集索引扫描就可以得到（用到哪个索引还会跟ORDER BY后面的字段有关，例子中用的是Primary Key作为排序的字段，所以用到的是聚集索引扫描），将两个查询放在一起查看执行计划，就会发现，第一个查询开销占了92%，而第二个才8%，也就是说， 第二个查询比起第一个查询，效率上优化了10倍以上，成果显著啊。<br>&gt; 　于是，在点评网的这个阶段，大量的冗余字段出现在表的设计当中，主要集中在会员的昵称以及商户的名称上，一方面，这些信息在其他应用中频繁的用到，另外一方面，这两个信息所在的主表都是特别大的表，做关联查询消耗太大，而且容易造成资源的争夺。</p></blockquote><blockquote><p>但是新的问题随之产生，每当一个会员去更新自己的昵称的时候，我们会执行一个存储过程，这个存储过程的目的就是去更新大量的会员昵称的冗余字 段，这些更新对于一个活跃会员来说，将是非常耗时的，因为需要更新的数据实在太多,而Web 2.0的精髓之一就是个性化，这样的设计对于个性化来说，有着不可调和的矛盾。于是，范式就像王者一样归来了。</p></blockquote><h4 id="王者归来"><a href="#王者归来" class="headerlink" title="王者归来"></a>王者归来</h4><blockquote><p>范式这个王者的归来，也是需要一定的时机的。</p></blockquote><blockquote><p>时机1：网站规模的发展，已经造成反范式的副作用越来越大；</p></blockquote><blockquote><p>时机2：公司规模的发展，已经有足够的财力建立更好的硬件平台；</p></blockquote><blockquote><p>于是，我们选择了Memcached， 一个分布式的缓存系统，我们将会员信息以实体类的方式保存在Memcached里面，只要是可序列化的数据，经过装箱和拆箱，都可以保存到 Memcached中并随时可以快速的访问到这些对象，Memcached可以解决大量数据的缓存并保持多台Web Server得到的缓存数据是一致的，于是，前面那个例子可以通过这样的查询来进行</p></blockquote><blockquote><p>SELECT TOP 10 帖子标题,会员ID FROM 帖子表 ORDER BY 帖子ID DESC</p></blockquote><blockquote><p>然后再通过缓存系统封装的批量读取的方法得到这些会员的昵称，再显示到网页上，于是，访问速度快了，冗余数据没了，只要有一套完善的缓存管理机 制，问题就迎刃而解了。有时候，你还会因为这样的查询得到一些惊喜，因为会员ID是一个整型的字段，当你用一些非PK的字段作为排序的字段时，可以把会员 ID包含在其索引里面（SQL Server 2005新特性），这样在索引扫描后可以避免一次聚集索引扫描，再一次的提高了查询效率。</p></blockquote><blockquote><p>相信对于这个问题的讨论是不会结束的，随着点评网的继续发展，新的问题必然还会产生，互联网就是要随需应变，到时候再来跟大家分享。</p></blockquote><h3 id="四、缓存表和汇总表"><a href="#四、缓存表和汇总表" class="headerlink" title="四、缓存表和汇总表"></a>四、缓存表和汇总表</h3><blockquote><ul><li>术语”缓存表”和”汇总表”没有标准的含义。我们用缓存表来表示存储那些可以比较简单从schema其他表获得数据的表。而汇总表保存的是使用GROUP BY语句聚合数据的表。</li></ul></blockquote><blockquote><ul><li>如果要获得过去24小时准确的消息发送数量，可以以每小时汇总表为基础，把前23个完整的小时的统计表中的计数全部加起来，最后再加上开始阶段和结束阶段不完整的小时内的计数。</li></ul></blockquote><h4 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h4><blockquote><ul><li>许多数据管理系统都提供一个呗称作物化视图的功能，实际上是预先计算并且存储在磁盘上的表，可以通过各种各样的策略刷新和更新。</li></ul></blockquote><blockquote><p>MySQL并不原始支持物化视图，使用开源工具Flexviews。主要有下面部分组成：</p><blockquote><ul><li>变更数据抓取功能，可以读取服务器的二进制日志并解析相关的行变更。</li><li>一系列可以帮助创建和管理视图的定义的存储过程。</li><li>一些可以应用变更到数据库中物化视图的工具。</li></ul></blockquote></blockquote><h4 id="计数器表"><a href="#计数器表" class="headerlink" title="计数器表"></a>计数器表</h4><blockquote><ul><li>计数器表在Web应用中很常见，可以用这种表缓存一个用户的朋友数、文件下载次数等。创建一个表存储计数器通常是个好主意，这样可使计数器表小且快。</li></ul></blockquote><blockquote><p>假设有一个计数器表，只有一行数据，记录网站的点击次数：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE hit_counter(</span><br><span class="line">    -&gt; cnt int unsigned not null</span><br><span class="line">    -&gt;) ENGINE = InnoDB</span><br></pre></td></tr></table></figure><blockquote><p>网站每次点击都会导致对计数器进行更新：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE hit_counter SET cnt = cnt + 1;</span><br></pre></td></tr></table></figure><blockquote><p>问题在于，对于任何想要更新这一行的事务来说，这条记录这条记录上都有一个全局的互斥锁。这会使得这些食物只能进行串行执行。要获得更高的并发更新性能，也可以将计数器保存在多行中，每次随机选择一行进行更新。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE hit_counter(</span><br><span class="line">    -&gt; slot tinyint unsigned not nill primary key.</span><br><span class="line">    -&gt; cnt int unsigned not null</span><br><span class="line">    -&gt;) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><blockquote><p>冉家预先在这张表增加100行数据，现在选择一个随机的槽进行更新：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE hit_counter set cnt = cnt + 1 WHERE slot = RAND() * 100;</span><br></pre></td></tr></table></figure><blockquote><p>想要获得统计结果，需要使用下面这样的聚合查询：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(cnt) FROM hit_counter;</span><br></pre></td></tr></table></figure><h3 id="五、加快ALTER-TABLE操作的速度"><a href="#五、加快ALTER-TABLE操作的速度" class="headerlink" title="五、加快ALTER TABLE操作的速度"></a>五、加快ALTER TABLE操作的速度</h3><blockquote><ul><li>第一种方法：先在一台不提供服务的机器上执行ALTER TABLE操作，然后和听歌服务的主库进行切换</li><li>第二种方法：”影子拷贝”，要求表结构可以创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表。</li></ul></blockquote><blockquote><ul><li>不是所有的ALTER TABLE操作都会引起表重建。例如有两种方法可以改变或者删除一个列的默认值(一种很快，一种很慢)。例如要修改电音的默认组里期限，从三天改到五天，下面是很慢的方式：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE sakila.film</span><br><span class="line">    -&gt; MODIFY COLUMN rental_duration TINYINT(3) NOT NULL DEFAULT 5;</span><br></pre></td></tr></table></figure><blockquote><p>另一种是通过ALTER COLUMN操作来改变列的默认值：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE sakila.filn</span><br><span class="line">    -&gt; ALTER COLUMN rental_duration SET DEFAULT 5;</span><br></pre></td></tr></table></figure><blockquote><p>这种语句会直接修改.frm文件而不涉及表数据。</p></blockquote><h4 id="快速创建MyISAM索引"><a href="#快速创建MyISAM索引" class="headerlink" title="快速创建MyISAM索引"></a>快速创建MyISAM索引</h4><h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><blockquote><ul><li>用需要的表结构创建一张表，但是不包括索引。</li><li>载入数据到表以构建.MYD文件。</li><li>按照需要的结构创建另外一张空表。这次要包含索引。这会创建需要的.frm和.MYI文件。</li><li>获取读锁并刷新表</li><li>重命名第二张表的.frm和.MYI文件，让MySQL认为是第一张表的文件。</li><li>释放读锁</li><li>使用REPAIR TABLE 来重建表的索引，该操作会通过排序来构建索引索引，包括唯一索引。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、选择优化的数据类型&quot;&gt;&lt;a href=&quot;#一、选择优化的数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、选择优
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://www.xingchuan.vip/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>19.高性能MySQL(五)</title>
    <link href="http://www.xingchuan.vip/19.%E9%AB%98%E6%80%A7%E8%83%BDMySQL(%E4%BA%94).html"/>
    <id>http://www.xingchuan.vip/19.高性能MySQL(五).html</id>
    <published>2019-08-02T15:00:00.000Z</published>
    <updated>2019-08-16T03:08:08.331Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="一、索引基础"><a href="#一、索引基础" class="headerlink" title="一、索引基础"></a>一、索引基础</h3><blockquote><ul><li>在MySQL中中，存储引擎用类似的方法使用索引，现在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行，</li><li>索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。</li></ul></blockquote><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><blockquote><ul><li>在MySQL中，索引是在存储引擎层而不是服务器层实现的。所以没有统一标准：不同存储引擎的索引的工作方式并不一样，也不是索引的存储引擎都支持所以类型的索引。既是多个存储引擎支持同一种类型的索引，其底层实现也可能不同。</li></ul></blockquote><h5 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h5><blockquote><ul><li>如果没特别指明类型，一般默认是B-Tree类型。它使用B-Tree数据结构来存储数据，大多数MySQL存储引擎都支持这种索引。Archive引擎是个例外。不过底层的存储引擎也可能使用不同的存储结果，例如NDB集群存储引擎内部实际上使用了T-Tree结构存储这种索引；InnoDB则使用的是B+Tree。</li><li>存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。例如，MyISAM使用前缀压缩技术使得索引更小，但InnoDB按照原书记格式进行存储。再如MyISAM索引通过书记的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。</li><li>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。能够加快访问数据的速度，因为存储引擎不需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这个鞋指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</li><li>叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页。B-Tree对索引列是顺序组织存储的，所有很适合查找范围数据。</li><li>可以使用B-Tree索引的查询类型。B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找，前面所述的索引对如下类型的查询有效。<blockquote><ul><li>全值匹配，指的是和索引中的所有列进行匹配。</li><li>匹配最左前缀，只是索引的第一列。</li><li>匹配列前缀，只匹配某一列的值的开头部分，这里也只使用索引的第一列。</li><li>匹配范围值，可以用于查找某一范围之间的数据，这里也只使用索引的第一列。</li><li>精确匹配某一列并范围匹配另外一列。即第一列全匹配，第二列范围匹配。</li><li>只范围索引的查询，即查询只需要访问索引，而无须访问数据库。</li></ul></blockquote></li><li>因为索引树的节点是有序的，所以除了按值查找伊娃，索引还可以用于查询中的ORDER BY操作。</li></ul></blockquote><h6 id="使用限制："><a href="#使用限制：" class="headerlink" title="使用限制："></a>使用限制：</h6><blockquote><ul><li>如果不是按照索引的最左列开始查找，则无法使用索引。</li><li>不能跳过索引中的列，如果不指定名，则MySQL只能使用索引的第一列。</li><li>如果查询中有某个列的范围查询，则其右边的列都无法使用索引优化查找。</li></ul></blockquote><h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><blockquote><ul><li>基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对索引的索引列计算出一个哈希码，是一个比较小的值，并且不同键值的行计算出的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表保存指向每个数据行的指针。</li><li>因为索引自身只需要存储对应的哈希值，所有索引结构非常紧凑，这也让哈希索引查找的速度非常快。</li></ul></blockquote><h6 id="使用限制：-1"><a href="#使用限制：-1" class="headerlink" title="使用限制："></a>使用限制：</h6><blockquote><ul><li>哈希索引只包含哈希值和行指针，而不存储字段值，索引不能使用索引中的值来避免读取行。</li><li>哈希索引数据并不是按照索引值顺序存储，所以也就无法用于排序。</li><li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例入，在数据列(A,B)上建立哈希索引，如果查询只有数据列A，则无法使用该索引。</li><li>哈希索引只支持等值比较查询，包括=、IN()、&lt;=&gt;。不支持任何范围查询，例入WHERE price &gt; 100。</li><li>访问哈希索引的数据非常快，除非有很多哈希冲突(不同的索引列值却有相同的哈希值)。当发生哈希冲突的试试，存储引擎必须遍历链表中所有的行指针，逐行进行比较，知道找到索引符合条件的行。</li><li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，在摸弍选择性很低(哈希冲突很多)的列上建立哈希索引，那么当从表中删除行时，存储引擎需要遍历对应哈希值的链表中的每一很纠结昂，找到并删除对应行的引用，冲突越多，代价越大。</li></ul></blockquote><blockquote><ul><li>因为这些限制，哈希索引只适合某些特定场合。而一旦适合哈希索引，则它带来的性能提升非常显著。</li></ul></blockquote><blockquote><ul><li>InnoDB引擎有个特殊的功能叫做”自适应哈希索引”。当InnoDB注意到某些索引值被使用的非常频繁时，它会在内存中基于B-Tree索引上再创建一个哈希索引，这样就让B-tree也有了哈希索引的一些优点，比如快速的哈希查找。这是个完全自动、内部的行为，用户无法控制或者配置，只能开启和关闭。</li></ul></blockquote><blockquote><ul><li>创建自定义哈希索引。如果存储引擎不支持哈希索引，则可以模拟像InnoDB一样创建哈希索引，这可以享受一些哈希索引的便利，例如只需要很小的索引就可以为超长的键创建索引。</li><li>思路很简单：在B-Tree基础上创建一个伪哈希索引。这还真正的哈希索引不是一回事。因为还是使用B-Tree进行查找，但是它使用哈希值而不是键本身进行索引查找。只需要在查询的WHERE子句手动指定使用哈希函数。</li><li>唯一缺陷就是需要维护哈希值。可以手动维护，也可以使用触发器实现。</li></ul></blockquote><h5 id="空间数据索引-R-Tree"><a href="#空间数据索引-R-Tree" class="headerlink" title="空间数据索引(R-Tree)"></a>空间数据索引(R-Tree)</h5><blockquote><ul><li>MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀查询，空间索引会从索引维护来索引数据。查询时，可以有效地使用任意纬度来组合查询，必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据。MySQL的GIS支持并不完善，所以大部分人都不会使用这个特性。</li></ul></blockquote><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><blockquote><ul><li>一种特殊类型索引。它查找的是文本中的关键词，而不是直接比较索引中的值，更类似于搜索引擎做的事情，也不是简单的WHERE条件匹配。</li><li>在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。</li></ul></blockquote><hr><h3 id="二、索引的优点"><a href="#二、索引的优点" class="headerlink" title="二、索引的优点"></a>二、索引的优点</h3><blockquote><ul><li>能够让服务器快速定位到表的指定位置，但这不是唯一的作用，根据创建索引的数据结构不同，索引也有一些其他的附加作用。</li></ul></blockquote><blockquote><ul><li>常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只是用索引就能完成全部查询。据此，总结下来有如下三个优点：<blockquote><ul><li>索引大大减少了服务器需要扫描的数据量。</li><li>索引可以帮助服务器避免排序和临时表。</li><li>索引可以将随机I/O变成顺序I/O。</li></ul></blockquote></li></ul></blockquote><hr><h3 id="三、高性能的索引策略"><a href="#三、高性能的索引策略" class="headerlink" title="三、高性能的索引策略"></a>三、高性能的索引策略</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><blockquote><ul><li>如果查询的列不是独立的，则MySQL就不会使用索引。索引列不能是表达式的一部分，也不能是函数的参数。</li><li>例如下面这个查询无法使用actor_id列的索引：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</span><br></pre></td></tr></table></figure><blockquote><ul><li>下面是另一个常见的错误：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT...WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) &lt;= 10;</span><br></pre></td></tr></table></figure><h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><blockquote><ul><li>有时候索引很长的字符串，会让索引变得很大很慢，一个策略就是之前提到过的模拟哈希索引。但有时候这样做还不够，还可以做些什么？</li></ul></blockquote><blockquote><ul><li>通常可以索引开始的部分字符串，可以大大节约索引空间，从而提高索引效率，但是这样会降低索引的选择性。选择性是指，不重复的索引值和数据表的记录总数(#T)的比值，范围从1/#T到1之间。索引的选择性越高，可以让MySQL在查找时过滤掉更多的行。</li></ul></blockquote><blockquote><ul><li>唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</li><li>对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</li></ul></blockquote><blockquote><ul><li>诀窍在于要选择足够长的的前缀以保证较高的选择性，同时又不能太长。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。</li></ul></blockquote><blockquote><ul><li>为了解决前缀的合适长度，需要找到最常见的值的列表，然后额最常见的前缀列表进行比较。下面演示下如何创建前缀索引：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;ALTER TABLE sakila.city_demo ADD KEY(city(7));</span><br></pre></td></tr></table></figure><blockquote><ul><li>前缀索引是一种能够使索引更小、更快的有效方法，但是也有其缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。</li></ul></blockquote><h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><blockquote><ul><li>很多人对多列索引的理解都不够。一个常见的错误就是，每个列创建独立的索引，或者按照错误的顺序创建多列索引。</li></ul></blockquote><blockquote><ul><li>在多条列上建立独立的单列索引大部分情况下都不能提高MySQL的查询性能。在5.9和更新版本中引入了一种叫”索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。</li></ul></blockquote><blockquote><ul><li>在MySQL5.0和更新的版本中，查询能够同时使用这两个单列索引进行扫描，并将结果进行何必。有三个变种：OR条件的联合(union)，AND条件的相交(intersection)，组合前两种情况的联合即相交。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;EXPLAIN SELECT film_id,actor_id FROM sakila,film_actor -&gt;WEHRE actor_id = 1 OR film_id = 1\G</span><br></pre></td></tr></table></figure><blockquote><ul><li>索引合并才做有时候是一种优化的结果，但实际上更多时候说明了表上的索引建得很糟糕：<blockquote><ul><li>当出现服务器对多个索引索引做相交操作，通常意味着需要一个包含所有相关列的索引，而不是多个独立的单列索引。</li><li>当服务器需要对多个索引做联合操作时，通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回大量数据的时候。</li><li>更重要的是，优化器不会把这些计算到”查询成本中”，优化器只关心随机的页面读取。这会使得查询的成本被低估，导致执行该计划还不如走全表扫描。这样不但会消耗更多的CPU和内存资源，还可能会影响查询的并发性。</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>如果在EXPALIN看到有索引合并，应该好好检查下查询和表的结构，看是不是已经是最优的。</li></ul></blockquote><h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><blockquote><ul><li>正确的顺序依赖于使用该索引的查询、并且同事需要考虑如何更好地满足排序和分组的需要。</li></ul></blockquote><blockquote><ul><li>在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列。索引可以按照升序或者降序进行扫描，以满足精确复符合列顺序的ORDER BY、GROUP BY和DISTINCTZ等子句查询的需求。</li></ul></blockquote><h6 id="经验法则："><a href="#经验法则：" class="headerlink" title="经验法则："></a>经验法则：</h6><blockquote><ul><li>将选择性高的列放在索引最全列。当不需要考虑排序或者分组，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化WHERE条件的查找。</li></ul></blockquote><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><blockquote><ul><li>不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上在同一个结果中保存了B-Tree索引和数据行。</li></ul></blockquote><blockquote><ul><li>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。”聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个地方，所以一个表只能由一个聚簇索引。</li></ul></blockquote><blockquote><ul><li>InnoDB通过主键聚集数据，被索引的列就是主键列。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作文聚簇索引。</li></ul></blockquote><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><blockquote><ul><li>可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据也就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每一封邮件都可能导致一次磁盘I/O,</li><li>数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引这种获取数据通常比在非聚簇索引中查找要快。</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li></ul></blockquote><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><blockquote><ul><li>聚簇数据最大限度地提高了I/O秘籍型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。</li><li>插入速度严格依赖插入顺序。</li><li>更新代价太高。</li><li>会产生页分裂问题，导致表占用更多的磁盘空间。</li><li>导致全表扫描变慢。</li><li>二级索引比想象中更大。</li><li>二级索引访问需要两次索引查找。<blockquote><ul><li>二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引找到对应的行。对于InnoDB，自适应哈希索引能够减少这样的重复工作。</li></ul></blockquote></li></ul></blockquote><h5 id="聚簇索引和非聚簇索引区别"><a href="#聚簇索引和非聚簇索引区别" class="headerlink" title="聚簇索引和非聚簇索引区别"></a>聚簇索引和非聚簇索引区别</h5><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1564662853798&di=97a63ab3fb0d5bf79eeb7390b40f9b3d&imgtype=0&src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F201503%2F20180110154804865441.jpg" alt></p><h5 id="在InnoDB表中按主键顺序插入行"><a href="#在InnoDB表中按主键顺序插入行" class="headerlink" title="在InnoDB表中按主键顺序插入行"></a>在InnoDB表中按主键顺序插入行</h5><blockquote><ul><li>尽量使用自增主键，保证数据行按照顺序插入，如果使用UUIP作为聚簇索引，会使聚簇索引的插入变得完全随机，不仅花费时间更长，索引占用空间更大，因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便问新的行分配空间</li></ul></blockquote><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><blockquote><ul><li>如果一个索引包含(或者说覆盖)所有需要查询的字段的值，我们称之为覆盖索引。</li></ul></blockquote><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote><ul><li>索引条目通常远小于数据行大小，所以如果只需要读取索引，那MYSQL就会极大地减少数据访问量，这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝数。对于I/O密集型的应用也有帮助，因为索引比数据更小，更容易全部放在内存中。</li><li>因为索引是按照列值顺序存储的，索引对于I/O密集型的范围查询会比随机从磁盘中读取每一行数据的I/O要少得多。</li><li>由于InnoDB的聚簇索引，覆盖索引对InnDB表非常有用。InnDB的二索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</li></ul></blockquote><blockquote><ul><li>不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值。</li></ul></blockquote><h5 id="索引无法覆盖查询原因"><a href="#索引无法覆盖查询原因" class="headerlink" title="索引无法覆盖查询原因"></a>索引无法覆盖查询原因</h5><blockquote><ul><li>没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。</li><li>MySQL不能再索引中执行LIKE操作。这是底层存储引擎API的限制。</li></ul></blockquote><blockquote><ul><li>可以使用延迟关联解决上述问题，因为延迟了对列的访问，在查询第一阶段MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的prod_id,然后 根据这些prod_id值在外层查询匹配获取需要的所有列值。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * </span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt;  JOIN(</span><br><span class="line">    -&gt;      SELECT prod_id    </span><br><span class="line">    -&gt;      FROM products</span><br><span class="line">    -&gt;      WHERE actor=&apos;SEAN CARREY&apos; AND title LIKE &apos;%APOLLP%&apos;</span><br><span class="line">    -&gt;  )As t1 ON(t1.prod_id = products.pro_id)\G</span><br></pre></td></tr></table></figure><h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><blockquote><p>MySQL有两种方式可以生产有序的结果:通过排序操作；或者按照索引顺序扫描，如果EXPLAIN出来的type列的值为”index”。</p></blockquote><blockquote><ul><li>扫描索引本身是很快的，因为只需要从一条索引记录移动到警戒着的下一条记录。但是如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就回标查询一股对应的行。</li></ul></blockquote><blockquote><ul><li>MySQL可以使用同一个索引既满足排序，又用于查找行，如果可能，尽量同时满足这两种任务。</li></ul></blockquote><blockquote><ul><li>只有当索引的列顺序和ORDER BY子句顺序完全以组织，并且所有列的排序方向都一样，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。OEDER BY子句和查找型查询的限制是一样：需要满足索引的最左前缀的要求，否则MySQL都需要执行排序操作，而无法利用索引排序(当导出量为常量时，可以不用满足)。</li></ul></blockquote><h4 id="压缩-前缀压缩-索引"><a href="#压缩-前缀压缩-索引" class="headerlink" title="压缩(前缀压缩)索引"></a>压缩(前缀压缩)索引</h4><blockquote><ul><li>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放在内存中，这些情况下能极大地提高性能。默认只压缩字符串，但是通过参数设置也可以对整数进行压缩。</li></ul></blockquote><blockquote><ul><li>MyISAM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分。</li><li>例如，索引块的第一个值是”perform”，第二个值是”performance”，那么第二个压缩后的结果为”7,ance”。</li></ul></blockquote><blockquote><ul><li>因为每个压缩前缀都依赖前面的值，MyISAM无法在索引块通过二分查找只能从头扫描，正序扫描还不错，不建议倒序扫描。</li></ul></blockquote><h4 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h4><blockquote><ul><li>重复索引是指在相同列上按照相同的顺序创建的相同类型的索引。应该避免这样创建索引，发现后也应该立即删除。</li></ul></blockquote><blockquote><ul><li>冗余索引和重复索引有一些不同。如果创建了索引(A,B),再创建索引(A)就是冗余索引，因为这只是前一个索引的前缀索引。因此索引(A,B)也可以当做索引(A)来使用。但是如果创建索引(B,A),则不是冗余索引。</li></ul></blockquote><blockquote><ul><li>大多数情况下都不需要冗余索引，应该尽量拓展已有的索引而不是创建新的索引。但有时候出于性能方面的考虑需要冗余索引，因为拓展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。<br>例如，如果在索引列上有一个索引，现在需要额外增加一个很长的VARCHAR列来拓展该索引，那么性能可能会急剧下降。特别是有查询把这个索引当作覆盖索引。</li></ul></blockquote><h4 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h4><blockquote><ul><li>除了冗余索引和重复索引，可能还有还有一些服务器永远不用的索引。建议删除，通常有两个方法可以定位：<blockquote><ul><li>在Percona Server或者MariaDB中先打开userstates服务器变量，然后让服务器正常运行一段时间，再通过查询INFORMATION_SCHEMA.INDEX_STATISTICS就是查到每个索引的使用频率</li><li>使用Percona Toolkit中的pt-index-usage，该工具可以读取查询日志，并对日志中的每个查询进行EXPLAIN操作，然后打印出相关索引和查询的报告。</li></ul></blockquote></li></ul></blockquote><h4 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h4><blockquote><ul><li>索引可以让查询锁定更少的行，虽然InnnoDB的行锁效率很高，内存也使用的少，但是锁定行的时候仍然会带来额外的开销；其次，锁定超过需要的行会增加锁争用并减少并发性。</li></ul></blockquote><blockquote><ul><li>InnoDB只有在访问行的时候才会对其加锁，而索引能减少InooDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎能够过滤掉索引不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检查到数据并返回给服务器以后，MySQL服务器才能应用WHERE子句，这时候已经无法避免行锁定了：InnoDB已经锁定这些行，到适当的时候才能释放。</li></ul></blockquote><hr><h3 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h3><h5 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h5><blockquote><ul><li>设计一个在线约会网站，用户信息表有很多列，包括国家、地区、城市、性别、眼睛颜色等。网站必须支持上面这些特征的各种组合来搜索用户，还必须允许根据用户的最后在线时间、其他会员对用户的评分等对用户进行排序并对结果进行限制。</li></ul></blockquote><h4 id="支持多种过滤条件"><a href="#支持多种过滤条件" class="headerlink" title="支持多种过滤条件"></a>支持多种过滤条件</h4><blockquote><ul><li>首先看看哪些列拥有很多不同的取值，哪些列在WHERE子句中出现得最频繁。在更多不同值的列上创建索引的选择性会更好。</li></ul></blockquote><blockquote><ul><li>country列的选择性通常不高，但可能很多查询都会用到。sex列的选择性肯定很低，但也会在很多查询中用到。所以考虑到使用的频率，还是建议在创建不同组合索引的时候将(sex,country)列作为前缀。</li></ul></blockquote><blockquote><ul><li>即使没有使用sex列也可以通过这个”诀窍”绕过：如果某个查询不限制性别，那么可以通过在查询条件中新增AND SEX IN(‘m’,’f’)来让MySQL选择该索引。</li></ul></blockquote><blockquote><ul><li>age列总是放在索引最后面，我们总是尽可能让MySQL使用更多的索引列，因为查询只能使用索引的最左前缀，直到遇到一个范围条件列。</li></ul></blockquote><h4 id="避免多个范围条件"><a href="#避免多个范围条件" class="headerlink" title="避免多个范围条件"></a>避免多个范围条件</h4><blockquote><ul><li>假设我们有一个last_online列并希望通过下面的查询显示在过去几周上线过的用户：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WHERE eye_color IN(&apos;brown&apos;,&apos;blue&apos;,&apos;hazel&apos;)</span><br><span class="line">    AND hair_color IN(&apos;black&apos;,&apos;red&apos;,&apos;blonde&apos;,&apos;brown&apos;)</span><br><span class="line">    AND sex IN(&apos;M&apos;,&apos;F&apos;)</span><br><span class="line">    AND last_online &gt; DATE_SUB(NOW(),INTERVAL 7 DAY)</span><br><span class="line">    AND age BETWEEN 18 AND 25</span><br></pre></td></tr></table></figure><blockquote><ul><li>这样查询有个问题：它有两个范围条件，last_online列和age列，MySQL可以使用last_online列索引或者age列索引，但无法同时使用他们。</li></ul></blockquote><h5 id="什么是范围查询？"><a href="#什么是范围查询？" class="headerlink" title="什么是范围查询？"></a>什么是范围查询？</h5><blockquote><ul><li>EXPLAIN很难区分MySQL是要查询范围值还是查询列表值，EXPLAIN会使用同样的词’rang’来描述这两种情况。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;EXPLAIN SELECT actor_id FROM sakila.actor</span><br><span class="line">    -&gt;WHERE actor_id &gt; 45\G</span><br><span class="line">*************** 1. row ***************</span><br><span class="line">             id: 1</span><br><span class="line">    select_type：SIMPLE</span><br><span class="line">          table：actor</span><br><span class="line">           type：range</span><br><span class="line">           </span><br><span class="line">但是下面这条查询呢？</span><br><span class="line">mysql&gt;EXPLAIN SELECT actor_id FROM sakila.actor</span><br><span class="line">    -&gt;WHERE actor_id IN(1，4，99)\G</span><br><span class="line">*************** 1. row ***************</span><br><span class="line">             id: 1</span><br><span class="line">    select_type：SIMPLE</span><br><span class="line">          table：actor</span><br><span class="line">           type：range</span><br></pre></td></tr></table></figure><blockquote><ul><li>第一个是范围查询，第二个是多个等值查询，对于范围查询，MySQL无法再使用范围后的其他索引列了，但是对于”多个等值条件查询”则没有这个限制。</li></ul></blockquote><h4 id="优化排序"><a href="#优化排序" class="headerlink" title="优化排序"></a>优化排序</h4><blockquote><ul><li>限制用户能够翻页的数量</li><li>使用延迟关联，通过使用覆盖索引查询返回需要主键，再根据这些主键关联原表获得所需要的行。</li></ul></blockquote><h5 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nysql&gt;SELECT &lt;cols&gt; FROM profiles INNER JOIN(</span><br><span class="line">    -&gt;  SELECT &lt;primary key cols&gt; FROM profiles</span><br><span class="line">    -&gt;  WHERE x.sex = &apos;M&apos; ORDER BY rating LIMIT 100009,10</span><br><span class="line">    -&gt; ) AS x USING(&lt;primary key cols&gt;)</span><br></pre></td></tr></table></figure><hr><h3 id="五、维护索引和表"><a href="#五、维护索引和表" class="headerlink" title="五、维护索引和表"></a>五、维护索引和表</h3><h4 id="找到并修复损坏的表"><a href="#找到并修复损坏的表" class="headerlink" title="找到并修复损坏的表"></a>找到并修复损坏的表</h4><blockquote><ul><li>对于MyISAM存储引擎，表损坏通常是系统崩溃导致的。损坏的索引会到导致查询返回错误的结果或者莫须有的主键冲突等问题,可以通过两个指令来解决问题：<blockquote><ul><li>CHECK TABLE：检查表是否发生损坏。</li><li>REPAIR TABLE：修复损坏的表。</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>如果InooDB引擎的表出现了损坏，那一定是发生了严重的错误。需要立刻调查原因，最重要的是找出什么导致了损坏，而不是简简单单的修复。可以通过设置innodb_force_recovery参数进入InnoDB的强制恢复模式来修复数据，也可以使用开源的InnoDB数据恢复箱。</li></ul></blockquote><h4 id="更新索引统计信息"><a href="#更新索引统计信息" class="headerlink" title="更新索引统计信息"></a>更新索引统计信息</h4><blockquote><ul><li>MySQL的查询优化器会通过两个API来了解存储引擎的索引值的分布信息，以决定如何使用索引。</li></ul></blockquote><h5 id="records-in-rang"><a href="#records-in-rang" class="headerlink" title="records_in_rang()"></a>records_in_rang()</h5><blockquote><ul><li>通过向存储引擎传入两个边界值获取在这个范围大概有多少条记录，对于某些存储引擎 ，该接口返回精确值，例如:MyISAM；对于另一些存储引擎则是一个估算值，例如:InnoDB.</li></ul></blockquote><h5 id="info-该接口返回各种类型的数据，包括索引的基数。"><a href="#info-该接口返回各种类型的数据，包括索引的基数。" class="headerlink" title="info(),该接口返回各种类型的数据，包括索引的基数。"></a>info(),该接口返回各种类型的数据，包括索引的基数。</h5><h4 id="减少索引和数据的碎片"><a href="#减少索引和数据的碎片" class="headerlink" title="减少索引和数据的碎片"></a>减少索引和数据的碎片</h4><blockquote><ul><li>B-Tree索引可能会碎片化，这会降低查询的效率。碎片化的索引可能会以很差或者无序的方式存储在磁盘上。</li><li>表的数据也可能碎片化，常见的有三种类型：</li></ul></blockquote><h5 id="行碎片"><a href="#行碎片" class="headerlink" title="行碎片"></a>行碎片</h5><blockquote><ul><li>数据行被存储为多个地方的多个片段中，即使查询只从索引中访问一行记录，行碎片也会导致性能下降。</li></ul></blockquote><h5 id="行间碎片"><a href="#行间碎片" class="headerlink" title="行间碎片"></a>行间碎片</h5><blockquote><ul><li>指逻辑上顺序的页，或者行在磁盘上不是顺畅存储的。行间碎片对诸如全表扫描和去除索引扫描之类的操作有很大的影响，因为这些操作原本能够从磁盘上顺序存储的数据中收益。</li></ul></blockquote><h5 id="剩余空间碎片"><a href="#剩余空间碎片" class="headerlink" title="剩余空间碎片"></a>剩余空间碎片</h5><blockquote><ul><li>指数据页中有大量的空余时间。这会导致服务器读取大量不需要的数据，从而造成浪费。</li></ul></blockquote><blockquote><ul><li>对于MyISAM表，三种情况都有可能发生。但InnoDB不会出现短小的行碎片，会移动短小的行并重写到一个片段中。</li></ul></blockquote><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><blockquote><ul><li>可以通过执行OPTIMIZE TABLE或者导出再导入1的方式来重新整理数据。对于MyISAM,可以通过排序算法重建索引的方式来消除碎片。对于新版InnoDB，新增了”在线”添加和删除索引的功能，可以通过先删除，然后再重新创建索引的方式来消除索引的碎片化。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、索引基础&quot;&gt;&lt;a href=&quot;#一、索引基础&quot; class=&quot;headerlink&quot; title=&quot;一、索引基础&quot;&gt;&lt;/a&gt;一、索
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://www.xingchuan.vip/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>17.高性能MySQL(三)</title>
    <link href="http://www.xingchuan.vip/17.%E9%AB%98%E6%80%A7%E8%83%BDMySQL(%E4%B8%89).html"/>
    <id>http://www.xingchuan.vip/17.高性能MySQL(三).html</id>
    <published>2019-07-31T17:26:00.000Z</published>
    <updated>2019-08-16T03:07:58.281Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="一、性能优化简介"><a href="#一、性能优化简介" class="headerlink" title="一、性能优化简介"></a>一、性能优化简介</h3><blockquote><ul><li>性能定义为完成某件任务所需要的时间度量，换句话说，性能即响应时间，通过任务和时间而不是资源来测量性能。数据库服务器的目的是执行SQL语句，所有它关注的任务是查询或者语句，如SELECT、UPDATE、DELETE等。数据库服务器的性能用查询的响应时间来度量，单位是每个查询花费的时间。</li><li>如果你认为性能优化是降低CPU利用率，那么可以减少对资源的使用，那么打错特错，资源是用来消耗并用来工作的，所有有时候消耗更多的资源能够加快查询速度。</li><li>如果把性能优化仅仅看成提升每秒查询量，这其实只是吞吐量优化。吞吐量替身可以看做性能优化的副产品。</li><li>当优化时，应该把精力和时间都来测量响应时间花在哪里，对症下药的解决方案也就比较明了了。</li><li>有两种比较常见的情况会导致不合适额测量：<blockquote><ul><li>在错误的时间启动和停止测量</li><li>测量的是聚合后的信息，而不是目标活动本身。</li></ul></blockquote></li><li>例如，一个常见的错误哦是先查看慢查询，然后又去排查整个服务器的情况来判断问题在哪里。如果确认有慢查询，那么就应该测试慢查询，而不是测量整个服务器。测量的应该是慢查询的开始时间到结束时间，而不是查询之前或查询之后的时间。</li><li>完成一项任务所需要的时间可以分成两个部分：执行时间和等待时间。如果要优化执行时间，最好的方法就是通过测量定位不同的子任务花费的时间，然后优化去掉一些子任务、降低子任务的执行频率或者提升子任务的效率。而优化任务的等待时间相对于复杂一些，因为等待有可能是由其他系统间接影响导致，任务之间也可能由于争用磁盘或者CPU自由而相互影响。</li></ul></blockquote><h4 id="通过性能剖析进行优化"><a href="#通过性能剖析进行优化" class="headerlink" title="通过性能剖析进行优化"></a>通过性能剖析进行优化</h4><blockquote><ul><li>性能剖析是测量和分析时间花费在哪里的主要方法。一般有两个步骤：测量任务所花费的时间；然后对结果进行统计和排序，将重要的任务排到前面。</li><li>性能剖析工具的方式基本相同，在任务开始时启动计时器，在任务结束时停止计时器，然后用结束时间减去启动时间得到响应时间。也有工具会记录任务的父任务。结果数据用来绘制调用关系图。</li><li>实际讨论两种类型的性能剖析:基于执行时间的分析和基于等待的分析。基于执行时间的分析研究的是什么任务的执行时间最长，而基于等待的分析这是判断任务在什么地方被阻塞的时间最长。</li><li>如果任务执行时间是因为消耗了太多的资源且大部分时间花费在执行上，等待时间不多，这种情况基于等待的分析作用就不大，反之亦然。如果都不确定，那么都试试。</li><li>当基于执行时间的分析发现一个任务需要花费太多时间的时候，应该深入分析下，可能会发现某些”执行时间”实际上是在等待，比如等待I/O完成。</li></ul></blockquote><h4 id="理解性能剖析"><a href="#理解性能剖析" class="headerlink" title="理解性能剖析"></a>理解性能剖析</h4><blockquote><p>mysql的性能剖析将最重要的任务展示在前面，如下：</p></blockquote><h5 id="值得优化的查询"><a href="#值得优化的查询" class="headerlink" title="值得优化的查询"></a>值得优化的查询</h5><blockquote><ul><li>性能剖析不会自动给出那些查询值得优化，一些只占总响应时间比重很小的时间是不值得优化的，对一个占总响应时间不超过5%的查询进行优化，无论如何收益也不会超过5%。如果花费了1000美元去优化一个任务，但业务的收入没有任何增加，那么可以说反而导致业务被逆优化了1000美元。如果优化的成本大于利益，就应当停止优化。</li></ul></blockquote><h5 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h5><blockquote><ul><li>某些任务即使没有出现在性能剖析输出的前面也需要优化。比如某些任务执行次数很少，的但每次执行都非常慢，严重影响用户体验。因为其执行频率低，所以总得响应时间占比并不突出。</li></ul></blockquote><h5 id="未知的未知"><a href="#未知的未知" class="headerlink" title="未知的未知"></a>未知的未知</h5><blockquote><ul><li>性能剖析工具会显示可能的”丢失的时间”,指的是任务的总 时间和实际测量到的时间之间的差，这可能是有些任务没有测量到，也可 能睡测量的误差和精度问题，如果发生这类问题，必须引起重视。</li></ul></blockquote><h5 id="被掩藏的细节"><a href="#被掩藏的细节" class="headerlink" title="被掩藏的细节"></a>被掩藏的细节</h5><blockquote><ul><li>性能剖析无法显示所有的响应时间的分布，只相信平均值是非常危险的，它会隐藏很多信息，而且无法表达全部情况。应该输出更多响应时间的信息，比如直方图、百分比、标准差、偏差指数等。</li></ul></blockquote><hr><h3 id="二、对应用程序进行性能剖析"><a href="#二、对应用程序进行性能剖析" class="headerlink" title="二、对应用程序进行性能剖析"></a>二、对应用程序进行性能剖析</h3><blockquote><ul><li>对系统进行性能剖析建议自上而下地进行，这样可以追踪自用户发起到服务器响应的整个流程。虽然性能问题大多数情况下都和数据库有关，但应用导致的性能问题也不少。性能瓶颈可能有很多影响因素：<blockquote><ul><li>外部资源，比如调用了外部的Web服务或者搜索引擎。</li><li>应用需要处理大量的数据，比如分析一个超大的XML文件。</li><li>在循环中执行昂贵的操作，比如滥用正则表达式。</li><li>使用了低效的算法，比如使用暴力搜索算法来查找列表中的项</li></ul></blockquote></li></ul></blockquote><hr><h3 id="三、剖析MySQL查询"><a href="#三、剖析MySQL查询" class="headerlink" title="三、剖析MySQL查询"></a>三、剖析MySQL查询</h3><h4 id="剖析服务器负载"><a href="#剖析服务器负载" class="headerlink" title="剖析服务器负载"></a>剖析服务器负载</h4><blockquote><ul><li>服务器端的剖析很有价值，因为在服务器端可以有效地审计效率低下的查询。定位和优化”坏”查询能够线束的提升应用的性能，也能解决某些特定的难题。还可以降低服务器的整体压力。这样所有的查询都将因为减少了对共享资源的争用而受益，可以退出或者避免升级更昂贵的硬件的需求，还可以发现和定位糟糕的用户体验，比如某些极端情况。</li></ul></blockquote><h5 id="捕获MySQL的查询到日志文件中"><a href="#捕获MySQL的查询到日志文件中" class="headerlink" title="捕获MySQL的查询到日志文件中"></a>捕获MySQL的查询到日志文件中</h5><blockquote><ul><li>在当前版本中，慢查询日志是开销最低，精度最高的测量查询时间的空间，不需要担心开启慢查询会带来额外的I/O开销。如果长期开启慢查询日志，注意要部署日志轮转工具。或者不要长期启动慢查询日志，只在需要收集负载样本的期间开启即可。</li><li>有时因为某些原因如权限不足等，无法在服务器上记录查询，有两种替代技术：<blockquote><ul><li>通过 –processlist选项不断查看SHOW FULL PROCESSLIST的输出，济洛路查询一次出现的时间和消失时间。某些情况精度足够发现问题，但是无法捕获所有的查询。</li><li>通过抓取TCP网络包，然后根据MySQL的客户端/服务端通信协议进行解析。可以先通过tcpdump将网络包数据保存到磁盘，然后使用pt-query-digest的–type=tcpdump选项来解析并分析查询。精度高，可以捕获所有查询，还可以解析更高级的协议特性，比如可以解析二进制协议，从而创建并执行服务端预解析的语句及压缩协议。</li></ul></blockquote></li></ul></blockquote><h5 id="分析查询日志"><a href="#分析查询日志" class="headerlink" title="分析查询日志"></a>分析查询日志</h5><blockquote><ul><li>强烈建议从现在开始就利用慢查询日志捕获服务器上的所有查询，并且进行分析。可以再一些典型的时间窗口如业务高峰期的一个小时内记录查询。如果业务趋势比较均衡，那么一分钟甚至更短的时间内捕获需要优化的低效查询也是可行的。</li><li>不要直接打开慢查询日志进行分析，应该先生成一个剖析报告，建议使用哪个pt-query-digest，是分析MySQL查询日志最有力的工具，可以将查询报告保存到数据库中，以及追踪工作负载随时间的变化。</li></ul></blockquote><h4 id="剖析单条查询"><a href="#剖析单条查询" class="headerlink" title="剖析单条查询"></a>剖析单条查询</h4><h5 id="使用SHOW-PROFILE"><a href="#使用SHOW-PROFILE" class="headerlink" title="使用SHOW PROFILE"></a>使用SHOW PROFILE</h5><blockquote><ul><li>默认禁用，可以通过服务器变量在会话级(连接)别动态地修改。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET profiling = 1;</span><br></pre></td></tr></table></figure><blockquote><ul><li>然后，在服务器上执行的所有语句，都会测量其耗费时间和其他一些查询执行状态变更相关的数据库。当一条查询提交给服务器时，，此工具会记录剖析信息到一张临时表，并且给查询赋予一个从1开始的证书标识符。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//查询列表</span><br><span class="line">mysql&gt; SHOW PROFILES;</span><br><span class="line">+---------+----------+-----------------------+</span><br><span class="line">|Query_ID | Duration | Query                 |</span><br><span class="line">+---------+----------+-----------------------+</span><br><span class="line">| 1       |0.16767900| SELECT * FROM mytable |</span><br><span class="line">+---------+----------+-----------------------+</span><br><span class="line">//查询queryid为1</span><br><span class="line">mysql&gt; SHOW PROFILE FOR QUERY 1;</span><br><span class="line">+--------------+----------+</span><br><span class="line">|Status        | Duration |</span><br><span class="line">+--------------+----------+</span><br><span class="line">|strating      | 0.000082 |</span><br><span class="line">+--------------+----------+</span><br><span class="line">|Opening talbe | 0.000459 |</span><br><span class="line">+--------------+----------+</span><br><span class="line">|............. | ........ |</span><br></pre></td></tr></table></figure><blockquote><ul><li>可以帮我们精准的定位到哪些活动花费的时间最多，从而针对性的优化。</li></ul></blockquote><h5 id="使用-SHOW-STATUS"><a href="#使用-SHOW-STATUS" class="headerlink" title="使用 SHOW STATUS"></a>使用 SHOW STATUS</h5><blockquote><ul><li>该命令返回了一些计数器。既有服务器级别的全局计数器，也有基于某个连接的会话级别的计数器，在会话开始的时为0，每提交一条查询增加1。</li><li>是一个有用的工具，但并不是一款剖析工具，大部分结果都只是一个计数器。</li></ul></blockquote><h5 id="使用慢查询日志"><a href="#使用慢查询日志" class="headerlink" title="使用慢查询日志"></a>使用慢查询日志</h5><blockquote><ul><li>慢查询日志中包含了SHOW PROFILE和SHOW STATUS所有的输出，并且还有更多的信息。所有通过pt-query-digest发现”坏”查询后，会在慢查询日志中可以获得足够有用的信息。查看报告时，其标题部分一般会有如下输出</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Query 1 ： 0 QPS,0x concurrency，ID 0xEE758C5EOD7EADEE at byte 3214____</span><br></pre></td></tr></table></figure><blockquote><ul><li>可以通过这里的字节偏移值(3214)直接跳转到日志的对应部分</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -c +3214 /path/to/query.log | head -n100</span><br></pre></td></tr></table></figure><h5 id="使用Performance-Schema"><a href="#使用Performance-Schema" class="headerlink" title="使用Performance Schema"></a>使用Performance Schema</h5><blockquote><ul><li>新特性，mysql5.5中还不支持查询界别的剖析信息。</li></ul></blockquote><h4 id="使用性能剖析"><a href="#使用性能剖析" class="headerlink" title="使用性能剖析"></a>使用性能剖析</h4><blockquote><ul><li>当获得服务器或者查询的剖析报告后，怎么使用？好的剖析报告能够把潜在的问题直接显示粗来，但最终的解决方案还需要用户来决定。优化查询时，用户需要对服务器如何执行查询有较深的了解。剖析报告尽可能多的收集需要的信息、给出诊断问题的正确方向，以及为其他诸如EXPALIN等工具提供基础信息</li></ul></blockquote><hr><h3 id="四、诊断间歇性问题"><a href="#四、诊断间歇性问题" class="headerlink" title="四、诊断间歇性问题"></a>四、诊断间歇性问题</h3><blockquote><ul><li>间歇性的问题比如系统偶尔停顿或者慢查询，很难诊断，有些幻影问题只有在没注意到的时候发送，而且很难复现。尽量不要使用试错的方式来解决问题，这种方式有很大的风险，因为结果可能会变得更坏，这也是一种令人沮丧且低效的方式。</li></ul></blockquote><h4 id="单条查询问题还是服务器问题"><a href="#单条查询问题还是服务器问题" class="headerlink" title="单条查询问题还是服务器问题"></a>单条查询问题还是服务器问题</h4><blockquote><ul><li>首先确定这是单条查询问题还是服务器问题，如果服务器上所有的程序都突然变慢，又突然变好，每一条查询页都变慢了，那么慢查询可能就不一定是原因，而是由于其他问题导致的结果。反过来说，如果服务器整体运行没有问题，只有某条查询偶尔变慢，则需要将注意力放到这条特定的查询上面。大多数情况都可以通过三种技术来解决。</li></ul></blockquote><h5 id="使用-SHOW-GLOBAL-STATUS"><a href="#使用-SHOW-GLOBAL-STATUS" class="headerlink" title="使用 SHOW GLOBAL STATUS"></a>使用 SHOW GLOBAL STATUS</h5><blockquote><ul><li>以较高的频率比如一秒执行一次SHOW GLOBAL STATUS命令捕获数据，问题出现时，则可以通过某些计数器(比如Threads_running、Threads_connected、Questions和Queries)的”尖刺”或则”凹陷“来发现，这个方法比较简单，所有人都可以使用，对服务器影响小。</li><li>这个命令每秒输出一行数据，可以运行几个小时或者几天，然后将结果绘制成图形，可以有效方便的发现啥是否有趋势的突变。也可以尽可能长时间的运行此命令，直到发现问题再回头来看输出结果。大多数情况下，通过输出结果都可以更明确的定位问题。</li></ul></blockquote><h5 id="使用-SHOW-PROCESSLIST"><a href="#使用-SHOW-PROCESSLIST" class="headerlink" title="使用 SHOW PROCESSLIST"></a>使用 SHOW PROCESSLIST</h5><blockquote><ul><li>通过不停地捕获SHOW PROCESSLIST的输出，来观察是否有大量线程处理不正常的状态或者右其他不正常的特征。</li><li>使用SHOW PROCESSLIST命令时，在尾部加上\G可以垂直的方式输出结果。</li></ul></blockquote><h5 id="使用查询日志"><a href="#使用查询日志" class="headerlink" title="使用查询日志"></a>使用查询日志</h5><blockquote><ul><li>如果需要通过查询日志发现问题，需要开启慢查询日志并且在全局级别设置time为0，并且要确认所有的连接都采用了新的设置，这可能需要重置所有连接以使新的全局设置生效。</li><li>要注意找到吞吐量突然下降时间段的日志。查询是在完成阶段才写入到慢查询日志的，所所以会堆积造成大量查询处于完成阶段。直到阻塞其他查询的资源占用者释放资源后，其他的查询才能执行完成。这种特征的好处是，当遇到吞吐量突然下降时，可以归咎于吞吐量下降后完成的第一个查询</li></ul></blockquote><h5 id="理解发现的问题"><a href="#理解发现的问题" class="headerlink" title="理解发现的问题"></a>理解发现的问题</h5><blockquote><ul><li>可视化的数据最具有说服力，在实际情况中，利用上面的工具诊断时，可能会产生大量的输出结果。可以选用gnuplot或者R，或者其他绘图工具将结果绘制成图形。</li><li>建议诊断问题时先使用前两种方法：SHOW STATUS和SHOW PROCESSLIST。这两种方法开销很低，可以通过简单的shell脚本或者反复执行的查询来交互式地收集数据，分析慢查询日志则相对要困难一点，经常会发现蛛丝马迹，但仔细研究时可能又消失，1这样我们很容易会认为其实没有问题。</li></ul></blockquote><h4 id="捕获诊断数据"><a href="#捕获诊断数据" class="headerlink" title="捕获诊断数据"></a>捕获诊断数据</h4><blockquote><ul><li>当出现间歇性问题时，需要尽可能地多收集所有的数据，而不只是问题出现时的数据，虽然这样会收集大量的诊断数据，但总比真正能够诊断问题的数据没有被收集到的情况要好。</li><li>开始之前，要搞清楚两件事情：<blockquote><ul><li>一个可靠且实时的”触发器”，也就是能够区分出什么时候问题出现的方法。</li><li>一个手机诊断数据的工具。</li></ul></blockquote></li></ul></blockquote><h5 id="诊断触发器"><a href="#诊断触发器" class="headerlink" title="诊断触发器"></a>诊断触发器</h5><blockquote><ul><li>非常重要，这是在问题出现时能够捕获数据的基础，有两个常见的问题可能会导致无法达到预期的结果：误报或者漏检。<blockquote><ul><li>误报是指收集了很多诊断数据，但期间其实没有发生问题，这可能浪费时间，而令人沮丧。</li><li>漏检则是指在问题出现时没有捕获到数据，错失了机会，一样浪费时间。</li></ul></blockquote></li><li>好的触发器标准是什么？Threads_running的趋势在出现问题时会比较敏感，而没有问题时则比较平稳。SHOW PROCESSLIST中线程的异常状态尖峰也是个不错的指标。</li><li>选择一个合适的阈值很重要，既要足够高，以确保在正常时不会触发；又不能太高，要确保问题发生时不会错过。</li></ul></blockquote><h5 id="需要收集什么样的数据"><a href="#需要收集什么样的数据" class="headerlink" title="需要收集什么样的数据"></a>需要收集什么样的数据</h5><blockquote><ul><li>尽可能收集所有能收集的数据，但只在需要的时间段内手机。包括系统的状态、CPU利用率、磁盘使用率和可用空间、ps的输出采样、内存利用率、已经可以从MySQL获得的信息，例如SHOW STATUS、SHOW PROCESSLIST和SHOW INNODB STATUS。</li><li>执行时间包括用于工作的时间和等待的时间。当一个未知问题发生时，一般来说有两种可能：服务器需要做大量的工作，从而导致大量消耗CPU；或者在等待某些资源被释放。所以需要用不同的方法收集诊断数据，来确认是何种原因。</li></ul></blockquote><h5 id="解释结果数据"><a href="#解释结果数据" class="headerlink" title="解释结果数据"></a>解释结果数据</h5><blockquote><ul><li>第一，检查问题是否真的发生，因为有很多样本数据需要检查，如果是误报就会白白浪费大量的时间。第二，是否有非常明显的跳跃性变化。</li><li>查看异常的查询或事务的行为，以及异常的服务器内部行为通常都是最有收获的。查询或事务的行为可以显示是否是由于使用服务器的方式导致的问题：性能低下的SQL查询、使用不当的索引、设计糟糕的数据库逻辑架构等。通过抓取TCP流量或者SHOW PROCESSLIST输出，可以获得查询和事务出现的地方，从而知道用户对数据库进行了什么操作。</li><li>如果遇到无法解释的错误，则最好将收集到的所有数据打包，提交给技术支持人员进行分析。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、性能优化简介&quot;&gt;&lt;a href=&quot;#一、性能优化简介&quot; class=&quot;headerlink&quot; title=&quot;一、性能优化简介&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://www.xingchuan.vip/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>16.高性能MySQL(二)</title>
    <link href="http://www.xingchuan.vip/16.%E9%AB%98%E6%80%A7%E8%83%BDMySQL(%E4%BA%8C).html"/>
    <id>http://www.xingchuan.vip/16.高性能MySQL(二).html</id>
    <published>2019-07-31T10:10:00.000Z</published>
    <updated>2019-08-16T03:07:54.016Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="一、什么是基准测试？"><a href="#一、什么是基准测试？" class="headerlink" title="一、什么是基准测试？"></a>一、什么是基准测试？</h3><blockquote><ul><li>是mysql新手和专家都需要掌握的技能。简单来说，基准测试是针对系统设计的一种压力测试。通常是为了掌握系统的行为。但也有其他原因，如重现某个系统状态，或者是做新硬件的可靠性测试。</li></ul></blockquote><hr><h3 id="二、为什么需要基准测试？"><a href="#二、为什么需要基准测试？" class="headerlink" title="二、为什么需要基准测试？"></a>二、为什么需要基准测试？</h3><blockquote><ul><li>是唯一方便有效的、可以学习系统在给定的工作负载下会发生什么的方法。</li><li>可以观察系统在不同压力下的行为，评估系统的荣来，掌握哪些是重要变化，或者观察系统如何处理不同的数据。</li><li>可以在系统实际负载之外创造一些虚构场景进行测试，可以完成以下工作，或者更多：<blockquote><ul><li>验证基于系统的假设，确认这些假设是否符合实际情况。</li><li>重现系统中的某些异常行为，以解决这些异常。</li><li>测试系统当前的运行状态。</li><li>模拟比当前系统更高的负载，以找出系统随着压力增加而可能遇到的扩展性瓶颈。</li><li>规划未来业务增长。</li><li>测试应用适应可变环境的能力。</li><li>测试不同的硬件、软件和操作系统配置。</li><li>证明新采购的设备是否配置正确。</li></ul></blockquote></li><li>主要问题在于其不是真实压力的测试，真实压力复杂多变，基准测试较为简单，所以使用真实压力测试，可能难以从结果中分析出确切的结论。</li><li>我们只能进行大概的测试，来确定系统大致的余量有多少。要尽量简单直接，结果之间容易比较，成本底且易于执行。</li></ul></blockquote><hr><h3 id="三、基准测试的策略"><a href="#三、基准测试的策略" class="headerlink" title="三、基准测试的策略"></a>三、基准测试的策略</h3><blockquote><ul><li>主要有两种主要的策略，：一个针对整个系统的整体测试，另外是单独测试mysql。这两个策略也被称为集成式以及单组件式基准测试。</li></ul></blockquote><h4 id="集成测试："><a href="#集成测试：" class="headerlink" title="集成测试："></a>集成测试：</h4><blockquote><ul><li>测试整个应用系统，包括web服务器、应用代码、网络和数据库是非常有用的，因为用户关注的并不仅仅是mysql本身的性能，而是应用整体的性能。</li><li>mysql并非应用的瓶颈。通过整体测试可以揭示这一点。</li><li>整体应用的集成式测试更能揭示应用的真实表现。而单独组件的测试很难做到这一点。</li></ul></blockquote><h4 id="单组件测试"><a href="#单组件测试" class="headerlink" title="单组件测试"></a>单组件测试</h4><blockquote><ul><li>需要比较不同的schema或查询的性能。</li><li>针对应用中某个棘突问题的测试。<br>为了避免漫长的基准测试，可以通过一个短期的基准测试，做快速的”周期循环”，来检测出某些调整后的效果、</li></ul></blockquote><hr><h3 id="四、测试指标"><a href="#四、测试指标" class="headerlink" title="四、测试指标"></a>四、测试指标</h3><h4 id="吞吐量："><a href="#吞吐量：" class="headerlink" title="吞吐量："></a>吞吐量：</h4><blockquote><ul><li>单位时间内事务的处理树。经典的数据库应用测试指标。主要针对在线事务处理(OLTP的吞吐量,非常适用于多用户的交互式应用。</li><li>单位是每秒事务(TPS)，有些也采用每分钟事务(TPM)。</li></ul></blockquote><h4 id="响应时间或者延迟"><a href="#响应时间或者延迟" class="headerlink" title="响应时间或者延迟"></a>响应时间或者延迟</h4><blockquote><ul><li>用于测试任务所需的整体时间。测试单位可能是微秒、毫秒、秒或者分钟，可以计算出平均响应时间、最小响应时间、最大响应时间和所占百分比，通过使用百分比响应时间来代替最大响应时间。</li><li>使用图表有助于理解测试结果。可以将测试结果绘制成折线图或者散点图。</li></ul></blockquote><h4 id="并发性"><a href="#并发性" class="headerlink" title="并发性:"></a>并发性:</h4><blockquote><ul><li>一个非常重要又经常被误解和误用的指标。Web服务器的并发性不等同于数据库的并发性，而仅仅指表示会话存储机制可以处理多少数据的能力。Web服务器的并发性更准确的度量指标，应该是在任意时间有多少同时发生的并发请求。</li><li>需要关注的是正在工作中的并发操作，或者是同事工作中的线程数或者连接数。当并发性增加时，需要测量吞吐量是否下降，响应时间是否增长，如果是这样，应用可能就无法处理峰值压力。</li></ul></blockquote><h4 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h4><blockquote><ul><li>给系统增加一倍的工作，在理想情况下就能获得两倍的结果，或者说给系统增加一倍的资源(比如两倍的CPU树)，就可以获得两倍的吞吐量。大多数系统无法做到如此理想的线性拓展，随着压力变化。吞吐量和性能都可能越来越差。</li></ul></blockquote><hr><h3 id="五、基准测试方法"><a href="#五、基准测试方法" class="headerlink" title="五、基准测试方法"></a>五、基准测试方法</h3><blockquote><ul><li>这部分不做过多解释，如果是DBA或者测试可以阅读书籍详细观看。主要有五个流程：</li></ul></blockquote><h4 id="设计和规划基准测试"><a href="#设计和规划基准测试" class="headerlink" title="设计和规划基准测试"></a>设计和规划基准测试</h4><blockquote><ul><li>首先获得需要生产数据集的快照。</li><li>针对数据运行查询，建立一个单元测试集作为初步的测试，并运行多边，更好的方法是选择一个有代表性的时间段，比如高峰期一小时，或者一整天，记录生产系统所有查询。如果时间段比较小。可以选择多个时间段，这样有助于覆盖整个系统的活动状态，例如每周报表查询、或者非峰值时间运行的批处理作业。</li><li>可以在不同级别记录查询。例如，如果是集成式基准测试，可以记录Web服务器上的HTTP请求，也可以打开mysql的查询日志。</li></ul></blockquote><h4 id="基准测试应该运行多长时间"><a href="#基准测试应该运行多长时间" class="headerlink" title="基准测试应该运行多长时间"></a>基准测试应该运行多长时间</h4><blockquote><ul><li>应该运行足够长的时间，需要等待系统处于稳定状态，而达到稳定状态需要非常多的时间。</li></ul></blockquote><h4 id="获取系统性能和状态"><a href="#获取系统性能和状态" class="headerlink" title="获取系统性能和状态"></a>获取系统性能和状态</h4><h4 id="获得准确的测试结果集"><a href="#获得准确的测试结果集" class="headerlink" title="获得准确的测试结果集"></a>获得准确的测试结果集</h4><h4 id="运行基准测试并分析结果"><a href="#运行基准测试并分析结果" class="headerlink" title="运行基准测试并分析结果"></a>运行基准测试并分析结果</h4><hr><h3 id="六、基准测试工具"><a href="#六、基准测试工具" class="headerlink" title="六、基准测试工具"></a>六、基准测试工具</h3><h4 id="ab"><a href="#ab" class="headerlink" title="ab"></a>ab</h4><blockquote><ul><li>是一个Apache HTTP服务器基准测试工具。它可以测试HTTP服务器每秒最多可以处理多少请求。如何测试的是Web应用服务，这个结果可以转成整个应用每秒可以满足多少请求，非常简单但用途有限，只能针对单URL进行测试。</li></ul></blockquote><h4 id="http-load"><a href="#http-load" class="headerlink" title="http_load"></a>http_load</h4><blockquote><ul><li>也被设计为Web服务器进行测试，但比ab更加灵活，可以通过一个输入文件提供多高URL，http_load在这些URL中随机选择进行测试。也可以定制http_load,使其按照时间的比率进行从厕所，而不仅仅是测试最大请求处理能力。</li></ul></blockquote><h4 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h4><blockquote><ul><li>是一个Java应用程序，可以加载其他应用并测试其性能。它虽然是设计用来测试Web应用的，但也可以用户测试其他诸如FTP服务器器，或者通过JDBC进行数据库查询测试。</li><li>比ab和http_load的复杂的多，可以通过控制预热时间等参数，更加灵活地模拟真实用户的访问。拥有绘图接口，还可以对测试进行金鸡路，然后离线重演测试结果。</li></ul></blockquote><h4 id="mysqlslap"><a href="#mysqlslap" class="headerlink" title="mysqlslap"></a>mysqlslap</h4><blockquote><ul><li>可以模拟服务器的负载，并输出计时信息，测试时可以执行并发连接数，并指定SQL语句。如果没有指定SQL语句。会自动生成查询schema的SELECT语句。</li></ul></blockquote><h4 id="MySQL-Benchmark-Suite-sql-bench"><a href="#MySQL-Benchmark-Suite-sql-bench" class="headerlink" title="MySQL Benchmark Suite(sql-bench)"></a>MySQL Benchmark Suite(sql-bench)</h4><blockquote><ul><li>单线程，用于测试服务器执行查询的速度，可以用于不同数据库服务器上进行比较测试。单用户模式，测试数据集很小且用户无法使用指定的数据。</li></ul></blockquote><h4 id="Super-Smack"><a href="#Super-Smack" class="headerlink" title="Super Smack"></a>Super Smack</h4><blockquote><ul><li>用于mysql和PostgerSQL的基准测试工具。可以提供压力测试和负载生成，可以模拟多用户访问，可以加载测试数据到数据库，并支持使用随机填充测试表。</li></ul></blockquote><h4 id="sysbench"><a href="#sysbench" class="headerlink" title="sysbench"></a>sysbench</h4><blockquote><ul><li>多线程系统压测工具，可以根据影响数据库服务器性能的各种因素来评估系统的性能。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、什么是基准测试？&quot;&gt;&lt;a href=&quot;#一、什么是基准测试？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是基准
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://www.xingchuan.vip/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>15.高性能MySQL(一)</title>
    <link href="http://www.xingchuan.vip/15.%E9%AB%98%E6%80%A7%E8%83%BDMySQL(%E4%B8%80).html"/>
    <id>http://www.xingchuan.vip/15.高性能MySQL(一).html</id>
    <published>2019-07-30T15:17:00.000Z</published>
    <updated>2019-08-16T03:07:49.779Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="一、逻辑架构"><a href="#一、逻辑架构" class="headerlink" title="一、逻辑架构"></a>一、逻辑架构</h3><h4 id="1-连接管理与安全性"><a href="#1-连接管理与安全性" class="headerlink" title="1. 连接管理与安全性"></a>1. 连接管理与安全性</h4><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1564459328961&di=ebd13e527e39953dd5f33f73bfd7df6b&imgtype=0&src=http%3A%2F%2Fwww.manongjc.com%2Fimages%2F51jb%2F1530849075153a0x8m49a075.png" alt="架构图"></p><h5 id="第一层"><a href="#第一层" class="headerlink" title="第一层:"></a>第一层:</h5><blockquote><ul><li>大多基于网络客户端/服务器的工具或者服务都有类似的架构，比如连接处理，授权认证，安全等等。</li></ul></blockquote><h5 id="第二层："><a href="#第二层：" class="headerlink" title="第二层："></a>第二层：</h5><blockquote><ul><li>mysql核心功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数。所有的跨存储引擎功能都在这一层实现，比如触发器、存储过程、视图等。</li></ul></blockquote><h5 id="第三层："><a href="#第三层：" class="headerlink" title="第三层："></a>第三层：</h5><blockquote><ul><li>包含存储引擎，负责mysql中的数据的存储和提取。不会解析sql，不同存储引擎也不会相互通信，只是简单的响应上层服务器的请求。</li></ul></blockquote><h4 id="2-优化与执行"><a href="#2-优化与执行" class="headerlink" title="2.优化与执行"></a>2.优化与执行</h4><blockquote><ul><li>每个客户端连接都会在服务器进程中都有一个线程，这个连接的查询只会在这个单独的线程中执行，服务器会缓存线程，不需要新建和销毁。</li></ul></blockquote><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步:"></a>第一步:</h5><blockquote><ul><li>当客户端连接到服务器时，服务器对其进行认证，基于用户名，密码，原始主机信息，连接成功后，会继续验证该客户端是否有执行某个特定查询的权限。</li></ul></blockquote><h5 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h5><blockquote><ul><li>认证通过后，mysql会解析查询，并创建内部数据结构，对其进行优化，包括重写查询，决定表的读取顺序，以及选择合适的索引。用户可以通过关键字(hint)提示优化器，也可以通过explain请求服务器解释优化过程。</li></ul></blockquote><h5 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h5><blockquote><ul><li>对于select查询，在解析查询之前，服务器会先检查查询缓存，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。</li></ul></blockquote><hr><h3 id="二、并发控制"><a href="#二、并发控制" class="headerlink" title="二、并发控制"></a>二、并发控制</h3><h4 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1.读写锁"></a>1.读写锁</h4><blockquote><ul><li>在处理并发读或者写的时候，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。通常被称为共享锁和排他锁，也叫读锁和写锁。</li></ul></blockquote><h5 id="读锁-共享锁-："><a href="#读锁-共享锁-：" class="headerlink" title="读锁(共享锁)："></a>读锁(共享锁)：</h5><blockquote><ul><li>读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源。而互不干扰。</li></ul></blockquote><h5 id="写锁-排它锁-："><a href="#写锁-排它锁-：" class="headerlink" title="写锁(排它锁)："></a>写锁(排它锁)：</h5><blockquote><ul><li>一个写锁会阻塞其他的写锁和读锁，这个处于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的统一资源。</li><li>在实际数据库系统中，锁时时刻刻都在发生，当某个用户正在修改一部分数据时，mysql会通过锁定防止其他用户读取统一数据。</li></ul></blockquote><h4 id="2-锁粒度"><a href="#2-锁粒度" class="headerlink" title="2.锁粒度"></a>2.锁粒度</h4><blockquote><ul><li>提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。而加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁是否已经被解除、释放锁都会增加系统开销。</li><li>所谓所策略，就是在锁的开销和数据的安全性之间寻找平衡，一般都是在表上施加行级锁。</li></ul></blockquote><h5 id="表锁："><a href="#表锁：" class="headerlink" title="表锁："></a>表锁：</h5><blockquote><ul><li>最基本的锁策略，并且是开销最小的策略，它会锁住整张表。一个用户在对表进行写操作(插入、删除、更新等)前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取用户才能获取读锁，读锁之间是不相互阻塞的。</li><li>特定场景中，表锁也可能有良好的性能。例如，READ LOCAL表锁支持某些类型的并发操作。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列前面，反之不不能。</li></ul></blockquote><h5 id="行级锁："><a href="#行级锁：" class="headerlink" title="行级锁："></a>行级锁：</h5><blockquote><ul><li>可以最大程度地支持并发处理(同时也带来了最大的锁开销)。众所周知，在InnoDB和XtraDB，以及其他的一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而mysql服务器层没有实现。</li></ul></blockquote><hr><h3 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h3><blockquote><ul><li>事务就是一组原子性的sql操作，或者说一个独立的工作单元。如果数据库引擎能够成功的对数据库应用该组操作的全部语句，那么就执行该组操作，如果其他有任何一条语句因为崩溃或者其他原因无法执行，那么所有语句都不会执行。</li><li>一句话总结：事务内的语句，要么全部执行成功，要么全部执行失败.</li></ul></blockquote><h4 id="1-ACID"><a href="#1-ACID" class="headerlink" title="1.ACID:"></a>1.ACID:</h4><h5 id="原子性-atomicity"><a href="#原子性-atomicity" class="headerlink" title="原子性(atomicity):"></a>原子性(atomicity):</h5><blockquote><ul><li>一个事务必须被视为一个不可分割的最小工作单元，不可能只执行其中的一部分，这就是事务的原子性。</li></ul></blockquote><h5 id="一致性-consistency-："><a href="#一致性-consistency-：" class="headerlink" title="一致性(consistency)："></a>一致性(consistency)：</h5><blockquote><ul><li>数据库总是从一个一致性的状态转换到另外一个一致性的状态，事务中的操作要么全部执行成功，要么全部失败回滚。</li></ul></blockquote><h5 id="隔离性-isolation"><a href="#隔离性-isolation" class="headerlink" title="隔离性(isolation)"></a>隔离性(isolation)</h5><blockquote><ul><li>一个事务所做的修改在最终提交之前，对其他事务是不可见的。</li></ul></blockquote><h5 id="持久性-durability"><a href="#持久性-durability" class="headerlink" title="持久性(durability)"></a>持久性(durability)</h5><blockquote><ul><li>一旦事务提交，对其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</li></ul></blockquote><h4 id="2-隔离级别："><a href="#2-隔离级别：" class="headerlink" title="2.隔离级别："></a>2.隔离级别：</h4><h5 id="READ-UNCOMMITTED-未提交读-："><a href="#READ-UNCOMMITTED-未提交读-：" class="headerlink" title="READ UNCOMMITTED(未提交读)："></a>READ UNCOMMITTED(未提交读)：</h5><blockquote><ul><li>在未提交读级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也称为脏读。这个级别会导致很多问题，从性能上来说，不会比其他级别好太多，缺缺乏其他级别的很多好处，一般很少使用。</li></ul></blockquote><h5 id="READ-COMMITTED-提交读-不可重复读"><a href="#READ-COMMITTED-提交读-不可重复读" class="headerlink" title="READ COMMITTED(提交读/不可重复读)"></a>READ COMMITTED(提交读/不可重复读)</h5><blockquote><ul><li>解决了脏读的问题。大多数数据默认的隔离级别，mysql不是。简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都不可见的。两次执行同样的查询，可能会得到不一样的结果，产生了不可重复读的问题。</li></ul></blockquote><h5 id="REPEATABLE-READ-可重复读-："><a href="#REPEATABLE-READ-可重复读-：" class="headerlink" title="REPEATABLE READ(可重复读)："></a>REPEATABLE READ(可重复读)：</h5><blockquote><ul><li>解决了脏读和不可重复读的问题。mysql的默认隔离级别，该级别保证了再同一事务中多次读取同样记录的结果是一致的。但是无法解决幻读的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另一个事务又会在该范围内插入新的记录，当之前的事务再次读取该范围内的技术时，会产生幻行。InnoDB和XtraDB存储引擎通过多版本并发控制，解决幻读问题。</li></ul></blockquote><h5 id="SERIALIZABLE-可串行化-："><a href="#SERIALIZABLE-可串行化-：" class="headerlink" title="SERIALIZABLE(可串行化)："></a>SERIALIZABLE(可串行化)：</h5><blockquote><ul><li>最高的隔离级别，通过强制事务串行执行，避免了前面说的幻读的问题，会在读取的每一行都加上所，所以可能导致大量的超时和锁争用的问题。实际中很少用到，只有在非常需要确保数据的一致性而且没有并发的情况下，才考虑采用该级别。</li></ul></blockquote><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1564467235392&di=3e5ee36282c1ebfe80e5fb74fe6cd529&imgtype=jpg&src=http%3A%2F%2Fimg3.imgtn.bdimg.com%2Fit%2Fu%3D3830690663%2C1874983557%26fm%3D214%26gp%3D0.jpg" alt></p><h4 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h4><blockquote><ul><li>两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多高事务试图以不同的顺序锁定资源时，就可能产生死锁。多个1事务同事锁定同一个资源时，也会产生死锁。</li></ul></blockquote><h5 id="如何解决死锁？"><a href="#如何解决死锁？" class="headerlink" title="如何解决死锁？"></a>如何解决死锁？</h5><blockquote><ul><li>数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如InnoDB存储引擎，越能检测出死锁的循环依赖，并立即返回一个错误。这种解决方法很有效。</li><li>另一种解决方式，就是当查询的时候达到锁等待超时的设定后放弃锁请求，这种方法不太好。</li><li>InnoDB目前处理死锁的方法是，将持有最少行级排它锁的事务进行回滚。</li><li>死锁发生后，只有部分或者完全回滚其中的一个事务，才能打破死锁。大多数情况下只需要重新执行因死锁回滚的1事务即可。</li></ul></blockquote><h4 id="4-事务日志"><a href="#4-事务日志" class="headerlink" title="4.事务日志"></a>4.事务日志</h4><blockquote><ul><li>提高事务效率，使用时，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不需要每次都将修改的数据本社持久到磁盘。事务日志采用追加的方式，因此写日志的操作是在磁盘上一小块区域内的顺序I/O，事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘，通常称为预写式日志，修改数据需要写两次磁盘。</li><li>如果日志持久化但是数据没有写回磁盘时，系统奔溃，存储引擎在重启后能够自动恢复这部分被修改的数据。</li></ul></blockquote><h4 id="5-mysql中的事务"><a href="#5-mysql中的事务" class="headerlink" title="5.mysql中的事务"></a>5.mysql中的事务</h4><blockquote><ul><li>提供两种事务型的存储引擎：InnoDB和NDB Cluster。</li><li>默认采用自动提交模式，如果不是显式地开始一个事务，则每个查询都被当做一个事务执行提交操作。</li><li>InnoDB采用的是两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会被释放，并且所有的锁是在同一时刻被释放。</li></ul></blockquote><hr><h3 id="四、多版本并发控制-MVCC"><a href="#四、多版本并发控制-MVCC" class="headerlink" title="四、多版本并发控制(MVCC)"></a>四、多版本并发控制(MVCC)</h3><blockquote><ul><li>以InnoDB为主，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。当然存储的不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询道德每行记录的版本号进行比较。<br>下面看一下，在可重复读的级别下，MVCC具体操作。</li></ul></blockquote><h4 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1.SELECT"></a>1.SELECT</h4><blockquote><ul><li>InnoDB会根据以下两个条件检查每行记录：<blockquote><ul><li>a.InnoDB只查找版本早于当前事务版本的数据行(也就是行的系统版本号小于或者等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过得。</li><li>b.行的删除版本要么未定义，要么大于当前事务版本。这样可以确保事务读到的行，在失误开始之前未被删除。</li></ul></blockquote></li><li>只有符合符合上述两个条件的记录，才能返回作为查询结果。</li></ul></blockquote><h4 id="2-INSERT"><a href="#2-INSERT" class="headerlink" title="2.INSERT"></a>2.INSERT</h4><blockquote><ul><li>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</li></ul></blockquote><h4 id="3-DELETE"><a href="#3-DELETE" class="headerlink" title="3.DELETE"></a>3.DELETE</h4><blockquote><ul><li>InnoDB为删除的的每一行保存当前系统版本号作为行删除标识。</li></ul></blockquote><h4 id="4-UPDATE"><a href="#4-UPDATE" class="headerlink" title="4.UPDATE"></a>4.UPDATE</h4><blockquote><ul><li>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。、</li></ul></blockquote><h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4><blockquote><ul><li>保存这两个额外的系统版本号，使大多数读操作都可以不用加锁，操作简单，性能很好，能够保证只会读到符合标准的行。不足在于每个记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</li><li>mysql只在可重复读和提交读两个隔离机制下工作。</li></ul></blockquote><hr><h3 id="五、存储引擎"><a href="#五、存储引擎" class="headerlink" title="五、存储引擎"></a>五、存储引擎</h3><h4 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1.InnoDB"></a>1.InnoDB</h4><blockquote><ul><li>mysql默认的事务型引擎，数据存储在表空间，它是InnoDB管理的黑盒子，由一系列的数据文件组成，可以将每个表的数据和索引存放在单独文件中。</li><li>采用MVCC来支持高并发，并且实现1李四光标准的隔离级别，默认是可重复读，并且可以通过间隙锁策略防止幻读的出现。间隙锁使得InooDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻影行的插入。</li><li>表基于聚簇索引建立，对主键查询有很高的性能，不过它的耳机索引中必须包含主键列。所以主键列很大的话，其他索引都会很大。如果表索引较多，主键应当尽可能的小。</li><li>内如做了很多优化，包括从磁盘读取数据时采用的可预测性玉都，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区。</li></ul></blockquote><h4 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2.MyISAM"></a>2.MyISAM</h4><blockquote><ul><li>mysql5.1版本以前的默认索引，提供大量特性，包括全文索引、压缩、空间函数，但是不支持事务和行级锁，崩溃后无法安全修复对于只读的数据，或者表比较小、可以忍受修复操作，可以使用MyISAM。</li></ul></blockquote><h5 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h5><blockquote><ul><li>加锁与并发<blockquote><ul><li>针对整张表加锁，而不是针对行，读取时会读到所有表加共享锁，写入时则对表加排他。但是在标有读取查询的同时，也可以往表里插入新的数据。</li></ul></blockquote></li><li>修复<blockquote><ul><li>可以收工或者自动执行检查和修复操作，执行表的修复可能导致一些数据丢失，而且修复操作非常慢，可以通过CHECK TABLE mytalbe检查表的错误，如果有错误，可以通过执行REPAIR TABLE mytalbe 进行修复。</li></ul></blockquote></li><li>索引特性<blockquote><ul><li>既是是BLOB和TEXT等长字段，也可以基于前500个字符创建索引，MyISAM也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。</li></ul></blockquote></li><li>延迟更新索引<blockquote><ul><li>创建表时如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引2块写入磁盘，极大的提升写入性能，但是数据库或系统崩溃会造成索引损坏。</li></ul></blockquote></li></ul></blockquote><h4 id="3-mysql内建的其他存储引擎"><a href="#3-mysql内建的其他存储引擎" class="headerlink" title="3.mysql内建的其他存储引擎"></a>3.mysql内建的其他存储引擎</h4><h5 id="Archive引擎"><a href="#Archive引擎" class="headerlink" title="Archive引擎"></a>Archive引擎</h5><blockquote><ul><li>只支持INSERT和SELECT操作。</li></ul></blockquote><h5 id="Blackhole引擎"><a href="#Blackhole引擎" class="headerlink" title="Blackhole引擎"></a>Blackhole引擎</h5><blockquote><ul><li>，没有实现任何的存储机制，它会丢弃索引插入的数据，不做任何保存。</li></ul></blockquote><h5 id="CSV引擎"><a href="#CSV引擎" class="headerlink" title="CSV引擎"></a>CSV引擎</h5><blockquote><ul><li>可以将普通的CSV文件作为mysql的表来处理，但这种表不支持索引。</li></ul></blockquote><h5 id="Federated引擎"><a href="#Federated引擎" class="headerlink" title="Federated引擎"></a>Federated引擎</h5><blockquote><ul><li>方位其他mysql服务器的一个代理，它会创建一个到远程mysql服务器的客户端连接，并将查询传输到远程服务器执行，然后提取或者发送需要的数据。</li></ul></blockquote><h5 id="Memory引擎"><a href="#Memory引擎" class="headerlink" title="Memory引擎"></a>Memory引擎</h5><blockquote><ul><li>如果需要快速地访问数据，并且这些数据不会被修改，重启后丢失也没有关系，则使用Memory表是非常有用的。至少比MyISAM表快一个数量级，因为所有数据数据都保存在内存中，不需要进行磁盘I/O。</li></ul></blockquote><h5 id="Merge引擎"><a href="#Merge引擎" class="headerlink" title="Merge引擎"></a>Merge引擎</h5><blockquote><ul><li>是MyLSAM引擎的变种，由多个MyISAM表合并而来的虚拟表，引入分区后，该引擎已经被放弃。</li></ul></blockquote><h5 id="NDB集群引擎"><a href="#NDB集群引擎" class="headerlink" title="NDB集群引擎"></a>NDB集群引擎</h5><blockquote><ul><li>mysql服务器，NDB集群存储引擎，以及分布式的、share-nothing的、容灾的、高可用的NDB数据库的组合，被称为msql集群。</li></ul></blockquote><h4 id="4-选择合适的存储引擎"><a href="#4-选择合适的存储引擎" class="headerlink" title="4.选择合适的存储引擎"></a>4.选择合适的存储引擎</h4><blockquote><ul><li>大多数情况下，InooDB都是正确的选择，所以在mysql5.5版本后将InnoDB作为默认的存储引擎了，。简单归纳一句话：”除非需要用到某些InnoDB不具备的特性，并没有其他办法代替，否则都应该优先选择InnoDB”。例如用到全文索引，建议优先考虑InnoDB加上Sphinx的组合，而不是支持全文索引的MyISAM。</li></ul></blockquote><h4 id="5-转换表的引擎"><a href="#5-转换表的引擎" class="headerlink" title="5.转换表的引擎"></a>5.转换表的引擎</h4><h5 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h5><blockquote><ul><li>将表从一个引擎修改为另一个引擎最简单的方法就是使用ALTER TABLE语句</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE mytable ENGINE = InnoDB;</span><br></pre></td></tr></table></figure><blockquote><ul><li>需要执行很长时间，原表会加上读锁，会失去和原引擎先关的所有特性。</li></ul></blockquote><h5 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h5><blockquote><ul><li>使用mysqldump工具将数据到处到文件，然后修改文件中CREATE TABLE语句的存储引擎选择，注意同时修改表名。同时要注意mysqldump默认会自动在CREATE TABLE语句前面加上DROP TABLEy语句，不注意这一点可能会导致数据丢失。</li></ul></blockquote><h5 id="创建与查询"><a href="#创建与查询" class="headerlink" title="创建与查询"></a>创建与查询</h5><blockquote><ul><li>综合了第一种和第二张方法，不需要导出整个表数据，而是先创建一个新的存储引擎的表，然后利用INSERT—-SELECT语法来导数据：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;CREATE TABLE innodb_table  LIKE myisam_table;</span><br><span class="line">mysql&gt;ALTER TABLE innodb_table=InnoDB;</span><br><span class="line">mysql&gt;INSERT INTO innodb_table SELECT * FROM myisam_table;</span><br></pre></td></tr></table></figure><blockquote><ul><li>数据量很大，可以考虑做分批处理，针对每一段时间只需事务提交操作，以避免大事务产生过多的uudo。假设有主键字段id，重复运行以下语句(最小值x和最大值y)将数据导入新表：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">mysql&gt; INSERT INTO innodb_table SELECT * FROM myisam_table-&gt; WHERE id BETWEEN x AND y;</span><br><span class="line">mysql&gt; COMMIT;</span><br></pre></td></tr></table></figure><blockquote><ul><li>这样操作完成以后，新表是原表的一个全量复制，原表还在，如果需要可以删除原表。如果有必要，可以在执行的过程中对原表加锁，以确保新表和原表的数据一致。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、逻辑架构&quot;&gt;&lt;a href=&quot;#一、逻辑架构&quot; class=&quot;headerlink&quot; title=&quot;一、逻辑架构&quot;&gt;&lt;/a&gt;一、逻
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://www.xingchuan.vip/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>7.UML类图</title>
    <link href="http://www.xingchuan.vip/7.UML%E7%B1%BB%E5%9B%BE.html"/>
    <id>http://www.xingchuan.vip/7.UML类图.html</id>
    <published>2019-07-29T15:30:00.000Z</published>
    <updated>2019-08-16T03:06:43.834Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="一、什么是UML图？"><a href="#一、什么是UML图？" class="headerlink" title="一、什么是UML图？"></a>一、什么是UML图？</h3><blockquote><ul><li>UML（Unified Modeling Language）是一种统一建模语言，为面向对象开发系统的产品进行说明、可视化、和编制文档的一种标准语言。UML图分为用例视图、设计视图、进程视图、实现视图和拓扑视图，又可以静动分为静态视图和动态视图。静态图分为：用例图，类图，对象图，包图，构件图，部署图。动态图分为：状态图，活动图，协作图，序列图。</li></ul></blockquote><hr><h3 id="二、UML类图"><a href="#二、UML类图" class="headerlink" title="二、UML类图"></a>二、UML类图</h3><blockquote><ul><li>用户根据用例图抽象成类，描述类的内部结构和类与类之间的关系，是一种静态结构图。 在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。</li></ul></blockquote><blockquote><ul><li>各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</li></ul></blockquote><h4 id="泛化："><a href="#泛化：" class="headerlink" title="泛化："></a>泛化：</h4><blockquote><ul><li>是一种继承关系，指定了子类如何继承父类的所有特征和行为。</li><li>实现+空心三角箭头表示。</li></ul></blockquote><h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><blockquote><ul><li>是一种类与接口的关系，表示类是接口所有特征和行为的实现。</li><li>虚线+空心三角箭头表示。</li></ul></blockquote><h4 id="关联："><a href="#关联：" class="headerlink" title="关联："></a>关联：</h4><blockquote><ul><li>是一种拥有关系，它使一个类知道另一个类的属性和方法。可以是单向也可以是双向。</li><li>双向关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</li></ul></blockquote><h4 id="聚合："><a href="#聚合：" class="headerlink" title="聚合："></a>聚合：</h4><blockquote><ul><li>是整体与部分的关系，且部分可以离开整体而单独存在。</li><li>实线+空心菱形表示</li></ul></blockquote><h4 id="组合："><a href="#组合：" class="headerlink" title="组合："></a>组合：</h4><blockquote><ul><li>是整体与部分的存在，但是部分不能离开整体而单独存在。</li><li>实现+实心菱形表示</li></ul></blockquote><h4 id="依赖："><a href="#依赖：" class="headerlink" title="依赖："></a>依赖：</h4><blockquote><ul><li>是一种使用的关系，一个类的实现需要另一个类的协助，尽量避免双向协助。</li><li>带箭头的虚线，指向被使用者</li></ul></blockquote><hr><h3 id="三、示例图"><a href="#三、示例图" class="headerlink" title="三、示例图"></a>三、示例图</h3><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2055311077,4220686053&fm=26&gp=0.jpg" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、什么是UML图？&quot;&gt;&lt;a href=&quot;#一、什么是UML图？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是UM
      
    
    </summary>
    
      <category term="随记" scheme="http://www.xingchuan.vip/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://www.xingchuan.vip/tags/java/"/>
    
      <category term="设计模式" scheme="http://www.xingchuan.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>6.一句话设计模式</title>
    <link href="http://www.xingchuan.vip/6.%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://www.xingchuan.vip/6.一句话设计模式.html</id>
    <published>2019-07-29T13:50:00.000Z</published>
    <updated>2019-08-16T03:06:39.772Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="创造类"><a href="#创造类" class="headerlink" title="创造类"></a>创造类</h3><h4 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h4><blockquote><ul><li>确保一个类只有一个实例，而且自行实例化并像整个系统提供这个实例。私有化构造方法，提供公共方法获得实例。</li></ul></blockquote><h4 id="工厂方法模式："><a href="#工厂方法模式：" class="headerlink" title="工厂方法模式："></a>工厂方法模式：</h4><blockquote><ul><li>定义一个用于创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的实例化延迟到了子类。</li></ul></blockquote><h4 id="抽象工厂模式："><a href="#抽象工厂模式：" class="headerlink" title="抽象工厂模式："></a>抽象工厂模式：</h4><blockquote><ul><li>为创建一组相关的或者相互依赖的的对象提供一个接口，而无需指定他们的具体类。</li></ul></blockquote><h4 id="建造者模式："><a href="#建造者模式：" class="headerlink" title="建造者模式："></a>建造者模式：</h4><blockquote><ul><li>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</li></ul></blockquote><h4 id="原型模式："><a href="#原型模式：" class="headerlink" title="原型模式："></a>原型模式：</h4><blockquote><ul><li>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。实现Cloneable接口，重写clone方法。</li></ul></blockquote><h4 id="迭代器模式：提供一个方法访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节。Java中已经默认实现，使用foreach即可。"><a href="#迭代器模式：提供一个方法访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节。Java中已经默认实现，使用foreach即可。" class="headerlink" title="迭代器模式：提供一个方法访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节。Java中已经默认实现，使用foreach即可。"></a>迭代器模式：提供一个方法访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节。Java中已经默认实现，使用foreach即可。</h4><hr><h3 id="行为类"><a href="#行为类" class="headerlink" title="行为类"></a>行为类</h3><h4 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h4><blockquote><ul><li>把一个请求或者操作封装在命令对象中，命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和回复功能。</li></ul></blockquote><h4 id="解释器模式："><a href="#解释器模式：" class="headerlink" title="解释器模式："></a>解释器模式：</h4><blockquote><ul><li>给定一种语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</li></ul></blockquote><h4 id="责任链模式："><a href="#责任链模式：" class="headerlink" title="责任链模式："></a>责任链模式：</h4><blockquote><ul><li>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者1之间的解耦关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</li></ul></blockquote><h4 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h4><blockquote><ul><li>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知被自动更新。</li></ul></blockquote><h4 id="中介者模式："><a href="#中介者模式：" class="headerlink" title="中介者模式："></a>中介者模式：</h4><blockquote><ul><li>用一个中介对象封装一系列对象的交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立的改变它们之间的交互。</li></ul></blockquote><h4 id="备忘录模式："><a href="#备忘录模式：" class="headerlink" title="备忘录模式："></a>备忘录模式：</h4><blockquote><ul><li>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到原先保存的状态。</li></ul></blockquote><h4 id="状态模式："><a href="#状态模式：" class="headerlink" title="状态模式："></a>状态模式：</h4><blockquote><ul><li>当一个对象内在状态改变时允许其改变行为，这个对象看起来像是改变了其类。</li></ul></blockquote><h4 id="策略模式："><a href="#策略模式：" class="headerlink" title="策略模式："></a>策略模式：</h4><blockquote><ul><li>定义一组算法，将每个算法都封装起来，并且可以使他们之间可以相互转换。</li></ul></blockquote><h4 id="模板方法模式："><a href="#模板方法模式：" class="headerlink" title="模板方法模式："></a>模板方法模式：</h4><blockquote><ul><li>定义一个操作中的算法骨架，而将一些步骤延伸到子类，使得子类可以不改变一个算法结构即可重定义该算法的某些特定步骤。</li></ul></blockquote><h4 id="访问者模式："><a href="#访问者模式：" class="headerlink" title="访问者模式："></a>访问者模式：</h4><blockquote><ul><li>封装一些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定于作用于这些元素的新操作。</li></ul></blockquote><hr><h3 id="结构类"><a href="#结构类" class="headerlink" title="结构类"></a>结构类</h3><h4 id="适配器模式："><a href="#适配器模式：" class="headerlink" title="适配器模式："></a>适配器模式：</h4><blockquote><ul><li>将一个类的接口变换成客户端所期待的另一个接口，从而使本因接口不必配而无法工作的两个类能够在一起工作。</li></ul></blockquote><h4 id="组合模式："><a href="#组合模式：" class="headerlink" title="组合模式："></a>组合模式：</h4><blockquote><ul><li>将对象组合成树形结构以表示”部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</li></ul></blockquote><h4 id="代理模式；"><a href="#代理模式；" class="headerlink" title="代理模式；"></a>代理模式；</h4><blockquote><ul><li>为其他对象提供一种代理以控制这个对象的访问。</li></ul></blockquote><h4 id="桥梁模式："><a href="#桥梁模式：" class="headerlink" title="桥梁模式："></a>桥梁模式：</h4><blockquote><ul><li>将抽象和实现解耦，使得两者可以独立的变化。</li></ul></blockquote><h4 id="装饰模式："><a href="#装饰模式：" class="headerlink" title="装饰模式："></a>装饰模式：</h4><blockquote><ul><li>动态的给一个对象添加一些额外的职责，就增加功能来说，它相比生成子类更为灵活</li></ul></blockquote><h4 id="门面模式："><a href="#门面模式：" class="headerlink" title="门面模式："></a>门面模式：</h4><blockquote><ul><li>要求一个子系统的外部与内部得同学都必须通过一个统一的对象进行，门面模式提供一个搞层次的接口，使得子系统更易于使用。</li></ul></blockquote><h4 id="享元模式："><a href="#享元模式：" class="headerlink" title="享元模式："></a>享元模式：</h4><blockquote><ul><li>使用共享对象可以有效的支持大量的细粒度的对象。</li></ul></blockquote><hr><h4 id="代码相关链接："><a href="#代码相关链接：" class="headerlink" title="代码相关链接："></a>代码相关链接：</h4><h5 id="《大话设计模式》-《设计模式之禅》"><a href="#《大话设计模式》-《设计模式之禅》" class="headerlink" title="《大话设计模式》 《设计模式之禅》"></a><a href="https://github.com/quietAny/BigTalkDesign" target="_blank" rel="noopener">《大话设计模式》</a> <a href="https://github.com/quietAny/ZenOfDesign" target="_blank" rel="noopener">《设计模式之禅》</a></h5><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;创造类&quot;&gt;&lt;a href=&quot;#创造类&quot; class=&quot;headerlink&quot; title=&quot;创造类&quot;&gt;&lt;/a&gt;创造类&lt;/h3&gt;&lt;h4 
      
    
    </summary>
    
      <category term="随记" scheme="http://www.xingchuan.vip/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://www.xingchuan.vip/tags/java/"/>
    
      <category term="设计模式" scheme="http://www.xingchuan.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>9.Resful相关</title>
    <link href="http://www.xingchuan.vip/9.Resful%E7%9B%B8%E5%85%B3.html"/>
    <id>http://www.xingchuan.vip/9.Resful相关.html</id>
    <published>2019-07-26T12:26:00.000Z</published>
    <updated>2019-08-16T03:06:51.150Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --><h3 id="一、什么是Resful？"><a href="#一、什么是Resful？" class="headerlink" title="一、什么是Resful？"></a>一、什么是Resful？</h3><blockquote><ul><li>RESTful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</li></ul></blockquote><hr><h3 id="二、常用方法："><a href="#二、常用方法：" class="headerlink" title="二、常用方法："></a>二、常用方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /blog/getArticles --&gt; GET /blog/Articles 获取所有文章</span><br><span class="line">GET /blog/addArticles --&gt; POST /blog/Articles 添加一篇文章</span><br><span class="line">GET /blog/editArticles --&gt; PUT /blog/Articles 修改一篇文章 </span><br><span class="line">GET /rest/api/deleteArticles?id=1 --&gt; DELETE /blog/Articles/1 删除一篇文章</span><br></pre></td></tr></table></figure><hr><h3 id="三、一句话总结！"><a href="#三、一句话总结！" class="headerlink" title="三、一句话总结！"></a>三、一句话总结！</h3><blockquote><ul><li>URL定位资源,HTTP动词描述操作。</li></ul></blockquote><hr><h3 id="四、如何在resful传入多个参数？"><a href="#四、如何在resful传入多个参数？" class="headerlink" title="四、如何在resful传入多个参数？"></a>四、如何在resful传入多个参数？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PutMapping(value = &quot;wx/createCustomer/&#123;number&#125;/&#123;nickName&#125;.do&quot;)</span><br></pre></td></tr></table></figure><hr><h3 id="五、-PathVariable-和-RequestParam区别："><a href="#五、-PathVariable-和-RequestParam区别：" class="headerlink" title="五、@PathVariable 和 @RequestParam区别："></a>五、@PathVariable 和 @RequestParam区别：</h3><blockquote><ul><li>@PathVariable用来绑定url模板变量值，获取url请求中的动态参数</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/zyh/&#123;type&#125;&quot;)</span><br><span class="line">  public String zyh(@PathVariable(value = &quot;type&quot;) int type) throws UnsupportedEncodingException &#123;</span><br><span class="line">    String url = &quot;http://wx.diyfintech.com/zyhMain/&quot; + type;</span><br><span class="line">    if (type != 1 &amp;&amp; type != 2) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;参数错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    String encodeUrl = URLEncoder.encode(url, &quot;utf-8&quot;);</span><br><span class="line">    String redirectUrl = MessageFormat.format(OAUTH_URL, WxConfig.zyhAppId, encodeUrl, &quot;snsapi_userinfo&quot;, UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;));</span><br><span class="line">    return &quot;redirect:&quot; + redirectUrl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>@RequestParam控制层用来获取参数</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/wx&quot;)</span><br><span class="line">public class WxController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private WxService wxService;</span><br><span class="line">    private static final Log log= LogFactory.getLog(WxController.class);</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/service&quot;,method = RequestMethod.GET)</span><br><span class="line">    public void acceptWxValid(@RequestParam String signature, @RequestParam String timestamp, @RequestParam String nonce,</span><br><span class="line">                              @RequestParam String echostr, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">            out.print(echostr);</span><br><span class="line">        &#125;else</span><br><span class="line">            out.print(&quot;fail&quot;);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 30 2019 16:32:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、什么是Resful？&quot;&gt;&lt;a href=&quot;#一、什么是Resful？&quot; class=&quot;headerlink&quot; title=&quot;一、什
      
    
    </summary>
    
      <category term="随记" scheme="http://www.xingchuan.vip/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://www.xingchuan.vip/tags/java/"/>
    
      <category term="面试" scheme="http://www.xingchuan.vip/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
