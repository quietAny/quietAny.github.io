<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>行川居</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xingchuan.vip/"/>
  <updated>2019-08-02T07:51:57.940Z</updated>
  <id>http://xingchuan.vip/</id>
  
  <author>
    <name>川总</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高性能MySQL(五)</title>
    <link href="http://xingchuan.vip/%E9%AB%98%E6%80%A7%E8%83%BDMysql(%E4%BA%94).html"/>
    <id>http://xingchuan.vip/高性能Mysql(五).html</id>
    <published>2019-08-02T15:00:00.000Z</published>
    <updated>2019-08-02T07:51:57.940Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、索引基础"><a href="#一、索引基础" class="headerlink" title="一、索引基础"></a>一、索引基础</h3><blockquote><ul><li>在MySQL中中，存储引擎用类似的方法使用索引，现在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行，</li><li>索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。</li></ul></blockquote><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><blockquote><ul><li>在MySQL中，索引是在存储引擎层而不是服务器层实现的。所以没有统一标准：不同存储引擎的索引的工作方式并不一样，也不是索引的存储引擎都支持所以类型的索引。既是多个存储引擎支持同一种类型的索引，其底层实现也可能不同。</li></ul></blockquote><h5 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h5><blockquote><ul><li>如果没特别指明类型，一般默认是B-Tree类型。它使用B-Tree数据结构来存储数据，大多数MySQL存储引擎都支持这种索引。Archive引擎是个例外。不过底层的存储引擎也可能使用不同的存储结果，例如NDB集群存储引擎内部实际上使用了T-Tree结构存储这种索引；InnoDB则使用的是B+Tree。</li><li>存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。例如，MyISAM使用前缀压缩技术使得索引更小，但InnoDB按照原书记格式进行存储。再如MyISAM索引通过书记的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。</li><li>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。能够加快访问数据的速度，因为存储引擎不需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这个鞋指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</li><li>叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页。B-Tree对索引列是顺序组织存储的，所有很适合查找范围数据。</li><li>可以使用B-Tree索引的查询类型。B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找，前面所述的索引对如下类型的查询有效。<blockquote><ul><li>全值匹配，指的是和索引中的所有列进行匹配。</li><li>匹配最左前缀，只是索引的第一列。</li><li>匹配列前缀，只匹配某一列的值的开头部分，这里也只使用索引的第一列。</li><li>匹配范围值，可以用于查找某一范围之间的数据，这里也只使用索引的第一列。</li><li>精确匹配某一列并范围匹配另外一列。即第一列全匹配，第二列范围匹配。</li><li>只范围索引的查询，即查询只需要访问索引，而无须访问数据库。</li></ul></blockquote></li><li>因为索引树的节点是有序的，所以除了按值查找伊娃，索引还可以用于查询中的ORDER BY操作。</li></ul></blockquote><h6 id="使用限制："><a href="#使用限制：" class="headerlink" title="使用限制："></a>使用限制：</h6><blockquote><ul><li>如果不是按照索引的最左列开始查找，则无法使用索引。</li><li>不能跳过索引中的列，如果不指定名，则MySQL只能使用索引的第一列。</li><li>如果查询中有某个列的范围查询，则其右边的列都无法使用索引优化查找。</li></ul></blockquote><h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><blockquote><ul><li>基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对索引的索引列计算出一个哈希码，是一个比较小的值，并且不同键值的行计算出的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表保存指向每个数据行的指针。</li><li>因为索引自身只需要存储对应的哈希值，所有索引结构非常紧凑，这也让哈希索引查找的速度非常快。</li></ul></blockquote><h6 id="使用限制：-1"><a href="#使用限制：-1" class="headerlink" title="使用限制："></a>使用限制：</h6><blockquote><ul><li>哈希索引只包含哈希值和行指针，而不存储字段值，索引不能使用索引中的值来避免读取行。</li><li>哈希索引数据并不是按照索引值顺序存储，所以也就无法用于排序。</li><li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例入，在数据列(A,B)上建立哈希索引，如果查询只有数据列A，则无法使用该索引。</li><li>哈希索引只支持等值比较查询，包括=、IN()、&lt;=&gt;。不支持任何范围查询，例入WHERE price &gt; 100。</li><li>访问哈希索引的数据非常快，除非有很多哈希冲突(不同的索引列值却有相同的哈希值)。当发生哈希冲突的试试，存储引擎必须遍历链表中所有的行指针，逐行进行比较，知道找到索引符合条件的行。</li><li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，在摸弍选择性很低(哈希冲突很多)的列上建立哈希索引，那么当从表中删除行时，存储引擎需要遍历对应哈希值的链表中的每一很纠结昂，找到并删除对应行的引用，冲突越多，代价越大。</li></ul></blockquote><blockquote><ul><li>因为这些限制，哈希索引只适合某些特定场合。而一旦适合哈希索引，则它带来的性能提升非常显著。</li></ul></blockquote><blockquote><ul><li>InnoDB引擎有个特殊的功能叫做”自适应哈希索引”。当InnoDB注意到某些索引值被使用的非常频繁时，它会在内存中基于B-Tree索引上再创建一个哈希索引，这样就让B-tree也有了哈希索引的一些优点，比如快速的哈希查找。这是个完全自动、内部的行为，用户无法控制或者配置，只能开启和关闭。</li></ul></blockquote><blockquote><ul><li>创建自定义哈希索引。如果存储引擎不支持哈希索引，则可以模拟像InnoDB一样创建哈希索引，这可以享受一些哈希索引的便利，例如只需要很小的索引就可以为超长的键创建索引。</li><li>思路很简单：在B-Tree基础上创建一个伪哈希索引。这还真正的哈希索引不是一回事。因为还是使用B-Tree进行查找，但是它使用哈希值而不是键本身进行索引查找。只需要在查询的WHERE子句手动指定使用哈希函数。</li><li>唯一缺陷就是需要维护哈希值。可以手动维护，也可以使用触发器实现。</li></ul></blockquote><h5 id="空间数据索引-R-Tree"><a href="#空间数据索引-R-Tree" class="headerlink" title="空间数据索引(R-Tree)"></a>空间数据索引(R-Tree)</h5><blockquote><ul><li>MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀查询，空间索引会从索引维护来索引数据。查询时，可以有效地使用任意纬度来组合查询，必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据。MySQL的GIS支持并不完善，所以大部分人都不会使用这个特性。</li></ul></blockquote><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><blockquote><ul><li>一种特殊类型索引。它查找的是文本中的关键词，而不是直接比较索引中的值，更类似于搜索引擎做的事情，也不是简单的WHERE条件匹配。</li><li>在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。</li></ul></blockquote><hr><h3 id="二、索引的优点"><a href="#二、索引的优点" class="headerlink" title="二、索引的优点"></a>二、索引的优点</h3><blockquote><ul><li>能够让服务器快速定位到表的指定位置，但这不是唯一的作用，根据创建索引的数据结构不同，索引也有一些其他的附加作用。</li></ul></blockquote><blockquote><ul><li>常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只是用索引就能完成全部查询。据此，总结下来有如下三个优点：<blockquote><ul><li>索引大大减少了服务器需要扫描的数据量。</li><li>索引可以帮助服务器避免排序和临时表。</li><li>索引可以将随机I/O变成顺序I/O。</li></ul></blockquote></li></ul></blockquote><hr><h3 id="三、高性能的索引策略"><a href="#三、高性能的索引策略" class="headerlink" title="三、高性能的索引策略"></a>三、高性能的索引策略</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><blockquote><ul><li>如果查询的列不是独立的，则MySQL就不会使用索引。索引列不能是表达式的一部分，也不能是函数的参数。</li><li>例如下面这个查询无法使用actor_id列的索引：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</span><br></pre></td></tr></table></figure><blockquote><ul><li>下面是另一个常见的错误：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT...WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) &lt;= 10;</span><br></pre></td></tr></table></figure><h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><blockquote><ul><li>有时候索引很长的字符串，会让索引变得很大很慢，一个策略就是之前提到过的模拟哈希索引。但有时候这样做还不够，还可以做些什么？</li></ul></blockquote><blockquote><ul><li>通常可以索引开始的部分字符串，可以大大节约索引空间，从而提高索引效率，但是这样会降低索引的选择性。选择性是指，不重复的索引值和数据表的记录总数(#T)的比值，范围从1/#T到1之间。索引的选择性越高，可以让MySQL在查找时过滤掉更多的行。</li></ul></blockquote><blockquote><ul><li>唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</li><li>对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</li></ul></blockquote><blockquote><ul><li>诀窍在于要选择足够长的的前缀以保证较高的选择性，同时又不能太长。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。</li></ul></blockquote><blockquote><ul><li>为了解决前缀的合适长度，需要找到最常见的值的列表，然后额最常见的前缀列表进行比较。下面演示下如何创建前缀索引：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;ALTER TABLE sakila.city_demo ADD KEY(city(7));</span><br></pre></td></tr></table></figure><blockquote><ul><li>前缀索引是一种能够使索引更小、更快的有效方法，但是也有其缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。</li></ul></blockquote><h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><blockquote><ul><li>很多人对多列索引的理解都不够。一个常见的错误就是，每个列创建独立的索引，或者按照错误的顺序创建多列索引。</li></ul></blockquote><blockquote><ul><li>在多条列上建立独立的单列索引大部分情况下都不能提高MySQL的查询性能。在5.9和更新版本中引入了一种叫”索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。</li></ul></blockquote><blockquote><ul><li>在MySQL5.0和更新的版本中，查询能够同时使用这两个单列索引进行扫描，并将结果进行何必。有三个变种：OR条件的联合(union)，AND条件的相交(intersection)，组合前两种情况的联合即相交。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;EXPLAIN SELECT film_id,actor_id FROM sakila,film_actor -&gt;WEHRE actor_id = 1 OR film_id = 1\G</span><br></pre></td></tr></table></figure><blockquote><ul><li>索引合并才做有时候是一种优化的结果，但实际上更多时候说明了表上的索引建得很糟糕：<blockquote><ul><li>当出现服务器对多个索引索引做相交操作，通常意味着需要一个包含所有相关列的索引，而不是多个独立的单列索引。</li><li>当服务器需要对多个索引做联合操作时，通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回大量数据的时候。</li><li>更重要的是，优化器不会把这些计算到”查询成本中”，优化器只关心随机的页面读取。这会使得查询的成本被低估，导致执行该计划还不如走全表扫描。这样不但会消耗更多的CPU和内存资源，还可能会影响查询的并发性。</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>如果在EXPALIN看到有索引合并，应该好好检查下查询和表的结构，看是不是已经是最优的。</li></ul></blockquote><h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><blockquote><ul><li>正确的顺序依赖于使用该索引的查询、并且同事需要考虑如何更好地满足排序和分组的需要。</li></ul></blockquote><blockquote><ul><li>在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列。索引可以按照升序或者降序进行扫描，以满足精确复符合列顺序的ORDER BY、GROUP BY和DISTINCTZ等子句查询的需求。</li></ul></blockquote><h6 id="经验法则："><a href="#经验法则：" class="headerlink" title="经验法则："></a>经验法则：</h6><blockquote><ul><li>将选择性高的列放在索引最全列。当不需要考虑排序或者分组，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化WHERE条件的查找。</li></ul></blockquote><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><blockquote><ul><li>不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上在同一个结果中保存了B-Tree索引和数据行。</li></ul></blockquote><blockquote><ul><li>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。”聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个地方，所以一个表只能由一个聚簇索引。</li></ul></blockquote><blockquote><ul><li>InnoDB通过主键聚集数据，被索引的列就是主键列。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作文聚簇索引。</li></ul></blockquote><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><blockquote><ul><li>可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据也就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每一封邮件都可能导致一次磁盘I/O,</li><li>数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引这种获取数据通常比在非聚簇索引中查找要快。</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li></ul></blockquote><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><blockquote><ul><li>聚簇数据最大限度地提高了I/O秘籍型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。</li><li>插入速度严格依赖插入顺序。</li><li>更新代价太高。</li><li>会产生页分裂问题，导致表占用更多的磁盘空间。</li><li>导致全表扫描变慢。</li><li>二级索引比想象中更大。</li><li>二级索引访问需要两次索引查找。<blockquote><ul><li>二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引找到对应的行。对于InnoDB，自适应哈希索引能够减少这样的重复工作。</li></ul></blockquote></li></ul></blockquote><h5 id="聚簇索引和非聚簇索引区别"><a href="#聚簇索引和非聚簇索引区别" class="headerlink" title="聚簇索引和非聚簇索引区别"></a>聚簇索引和非聚簇索引区别</h5><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1564662853798&di=97a63ab3fb0d5bf79eeb7390b40f9b3d&imgtype=0&src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F201503%2F20180110154804865441.jpg" alt></p><h5 id="在InnoDB表中按主键顺序插入行"><a href="#在InnoDB表中按主键顺序插入行" class="headerlink" title="在InnoDB表中按主键顺序插入行"></a>在InnoDB表中按主键顺序插入行</h5><blockquote><ul><li>尽量使用自增主键，保证数据行按照顺序插入，如果使用UUIP作为聚簇索引，会使聚簇索引的插入变得完全随机，不仅花费时间更长，索引占用空间更大，因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便问新的行分配空间</li></ul></blockquote><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><blockquote><ul><li>如果一个索引包含(或者说覆盖)所有需要查询的字段的值，我们称之为覆盖索引。</li></ul></blockquote><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote><ul><li>索引条目通常远小于数据行大小，所以如果只需要读取索引，那MYSQL就会极大地减少数据访问量，这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝数。对于I/O密集型的应用也有帮助，因为索引比数据更小，更容易全部放在内存中。</li><li>因为索引是按照列值顺序存储的，索引对于I/O密集型的范围查询会比随机从磁盘中读取每一行数据的I/O要少得多。</li><li>由于InnoDB的聚簇索引，覆盖索引对InnDB表非常有用。InnDB的二索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</li></ul></blockquote><blockquote><ul><li>不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值。</li></ul></blockquote><h5 id="索引无法覆盖查询原因"><a href="#索引无法覆盖查询原因" class="headerlink" title="索引无法覆盖查询原因"></a>索引无法覆盖查询原因</h5><blockquote><ul><li>没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。</li><li>MySQL不能再索引中执行LIKE操作。这是底层存储引擎API的限制。</li></ul></blockquote><blockquote><ul><li>可以使用延迟关联解决上述问题，因为延迟了对列的访问，在查询第一阶段MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的prod_id,然后 根据这些prod_id值在外层查询匹配获取需要的所有列值。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * </span><br><span class="line">    -&gt; FROM products</span><br><span class="line">    -&gt;  JOIN(</span><br><span class="line">    -&gt;      SELECT prod_id    </span><br><span class="line">    -&gt;      FROM products</span><br><span class="line">    -&gt;      WHERE actor=&apos;SEAN CARREY&apos; AND title LIKE &apos;%APOLLP%&apos;</span><br><span class="line">    -&gt;  )As t1 ON(t1.prod_id = products.pro_id)\G</span><br></pre></td></tr></table></figure><h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><blockquote><p>MySQL有两种方式可以生产有序的结果:通过排序操作；或者按照索引顺序扫描，如果EXPLAIN出来的type列的值为”index”。</p></blockquote><blockquote><ul><li>扫描索引本身是很快的，因为只需要从一条索引记录移动到警戒着的下一条记录。但是如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就回标查询一股对应的行。</li></ul></blockquote><blockquote><ul><li>MySQL可以使用同一个索引既满足排序，又用于查找行，如果可能，尽量同时满足这两种任务。</li></ul></blockquote><blockquote><ul><li>只有当索引的列顺序和ORDER BY子句顺序完全以组织，并且所有列的排序方向都一样，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。OEDER BY子句和查找型查询的限制是一样：需要满足索引的最左前缀的要求，否则MySQL都需要执行排序操作，而无法利用索引排序(当导出量为常量时，可以不用满足)。</li></ul></blockquote><h4 id="压缩-前缀压缩-索引"><a href="#压缩-前缀压缩-索引" class="headerlink" title="压缩(前缀压缩)索引"></a>压缩(前缀压缩)索引</h4><blockquote><ul><li>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放在内存中，这些情况下能极大地提高性能。默认只压缩字符串，但是通过参数设置也可以对整数进行压缩。</li></ul></blockquote><blockquote><ul><li>MyISAM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分。</li><li>例如，索引块的第一个值是”perform”，第二个值是”performance”，那么第二个压缩后的结果为”7,ance”。</li></ul></blockquote><blockquote><ul><li>因为每个压缩前缀都依赖前面的值，MyISAM无法在索引块通过二分查找只能从头扫描，正序扫描还不错，不建议倒序扫描。</li></ul></blockquote><h4 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h4><blockquote><ul><li>重复索引是指在相同列上按照相同的顺序创建的相同类型的索引。应该避免这样创建索引，发现后也应该立即删除。</li></ul></blockquote><blockquote><ul><li>冗余索引和重复索引有一些不同。如果创建了索引(A,B),再创建索引(A)就是冗余索引，因为这只是前一个索引的前缀索引。因此索引(A,B)也可以当做索引(A)来使用。但是如果创建索引(B,A),则不是冗余索引。</li></ul></blockquote><blockquote><ul><li>大多数情况下都不需要冗余索引，应该尽量拓展已有的索引而不是创建新的索引。但有时候出于性能方面的考虑需要冗余索引，因为拓展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。<br>例如，如果在索引列上有一个索引，现在需要额外增加一个很长的VARCHAR列来拓展该索引，那么性能可能会急剧下降。特别是有查询把这个索引当作覆盖索引。</li></ul></blockquote><h4 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h4><blockquote><ul><li>除了冗余索引和重复索引，可能还有还有一些服务器永远不用的索引。建议删除，通常有两个方法可以定位：<blockquote><ul><li>在Percona Server或者MariaDB中先打开userstates服务器变量，然后让服务器正常运行一段时间，再通过查询INFORMATION_SCHEMA.INDEX_STATISTICS就是查到每个索引的使用频率</li><li>使用Percona Toolkit中的pt-index-usage，该工具可以读取查询日志，并对日志中的每个查询进行EXPLAIN操作，然后打印出相关索引和查询的报告。</li></ul></blockquote></li></ul></blockquote><h4 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h4><blockquote><ul><li>索引可以让查询锁定更少的行，虽然InnnoDB的行锁效率很高，内存也使用的少，但是锁定行的时候仍然会带来额外的开销；其次，锁定超过需要的行会增加锁争用并减少并发性。</li></ul></blockquote><blockquote><ul><li>InnoDB只有在访问行的时候才会对其加锁，而索引能减少InooDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎能够过滤掉索引不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检查到数据并返回给服务器以后，MySQL服务器才能应用WHERE子句，这时候已经无法避免行锁定了：InnoDB已经锁定这些行，到适当的时候才能释放。</li></ul></blockquote><hr><h3 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h3><h5 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h5><blockquote><ul><li>设计一个在线约会网站，用户信息表有很多列，包括国家、地区、城市、性别、眼睛颜色等。网站必须支持上面这些特征的各种组合来搜索用户，还必须允许根据用户的最后在线时间、其他会员对用户的评分等对用户进行排序并对结果进行限制。</li></ul></blockquote><h4 id="支持多种过滤条件"><a href="#支持多种过滤条件" class="headerlink" title="支持多种过滤条件"></a>支持多种过滤条件</h4><blockquote><ul><li>首先看看哪些列拥有很多不同的取值，哪些列在WHERE子句中出现得最频繁。在更多不同值的列上创建索引的选择性会更好。</li></ul></blockquote><blockquote><ul><li>country列的选择性通常不高，但可能很多查询都会用到。sex列的选择性肯定很低，但也会在很多查询中用到。所以考虑到使用的频率，还是建议在创建不同组合索引的时候将(sex,country)列作为前缀。</li></ul></blockquote><blockquote><ul><li>即使没有使用sex列也可以通过这个”诀窍”绕过：如果某个查询不限制性别，那么可以通过在查询条件中新增AND SEX IN(‘m’,’f’)来让MySQL选择该索引。</li></ul></blockquote><blockquote><ul><li>age列总是放在索引最后面，我们总是尽可能让MySQL使用更多的索引列，因为查询只能使用索引的最左前缀，直到遇到一个范围条件列。</li></ul></blockquote><h4 id="避免多个范围条件"><a href="#避免多个范围条件" class="headerlink" title="避免多个范围条件"></a>避免多个范围条件</h4><blockquote><ul><li>假设我们有一个last_online列并希望通过下面的查询显示在过去几周上线过的用户：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WHERE eye_color IN(&apos;brown&apos;,&apos;blue&apos;,&apos;hazel&apos;)</span><br><span class="line">    AND hair_color IN(&apos;black&apos;,&apos;red&apos;,&apos;blonde&apos;,&apos;brown&apos;)</span><br><span class="line">    AND sex IN(&apos;M&apos;,&apos;F&apos;)</span><br><span class="line">    AND last_online &gt; DATE_SUB(NOW(),INTERVAL 7 DAY)</span><br><span class="line">    AND age BETWEEN 18 AND 25</span><br></pre></td></tr></table></figure><blockquote><ul><li>这样查询有个问题：它有两个范围条件，last_online列和age列，MySQL可以使用last_online列索引或者age列索引，但无法同时使用他们。</li></ul></blockquote><h5 id="什么是范围查询？"><a href="#什么是范围查询？" class="headerlink" title="什么是范围查询？"></a>什么是范围查询？</h5><blockquote><ul><li>EXPLAIN很难区分MySQL是要查询范围值还是查询列表值，EXPLAIN会使用同样的词’rang’来描述这两种情况。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;EXPLAIN SELECT actor_id FROM sakila.actor</span><br><span class="line">    -&gt;WHERE actor_id &gt; 45\G</span><br><span class="line">*************** 1. row ***************</span><br><span class="line">             id: 1</span><br><span class="line">    select_type：SIMPLE</span><br><span class="line">          table：actor</span><br><span class="line">           type：range</span><br><span class="line">           </span><br><span class="line">但是下面这条查询呢？</span><br><span class="line">mysql&gt;EXPLAIN SELECT actor_id FROM sakila.actor</span><br><span class="line">    -&gt;WHERE actor_id IN(1，4，99)\G</span><br><span class="line">*************** 1. row ***************</span><br><span class="line">             id: 1</span><br><span class="line">    select_type：SIMPLE</span><br><span class="line">          table：actor</span><br><span class="line">           type：range</span><br></pre></td></tr></table></figure><blockquote><ul><li>第一个是范围查询，第二个是多个等值查询，对于范围查询，MySQL无法再使用范围后的其他索引列了，但是对于”多个等值条件查询”则没有这个限制。</li></ul></blockquote><h4 id="优化排序"><a href="#优化排序" class="headerlink" title="优化排序"></a>优化排序</h4><blockquote><ul><li>限制用户能够翻页的数量</li><li>使用延迟关联，通过使用覆盖索引查询返回需要主键，再根据这些主键关联原表获得所需要的行。</li></ul></blockquote><h5 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nysql&gt;SELECT &lt;cols&gt; FROM profiles INNER JOIN(</span><br><span class="line">    -&gt;  SELECT &lt;primary key cols&gt; FROM profiles</span><br><span class="line">    -&gt;  WHERE x.sex = &apos;M&apos; ORDER BY rating LIMIT 100009,10</span><br><span class="line">    -&gt; ) AS x USING(&lt;primary key cols&gt;)</span><br></pre></td></tr></table></figure><hr><h3 id="五、维护索引和表"><a href="#五、维护索引和表" class="headerlink" title="五、维护索引和表"></a>五、维护索引和表</h3><h4 id="找到并修复损坏的表"><a href="#找到并修复损坏的表" class="headerlink" title="找到并修复损坏的表"></a>找到并修复损坏的表</h4><blockquote><ul><li>对于MyISAM存储引擎，表损坏通常是系统崩溃导致的。损坏的索引会到导致查询返回错误的结果或者莫须有的主键冲突等问题,可以通过两个指令来解决问题：<blockquote><ul><li>CHECK TABLE：检查表是否发生损坏。</li><li>REPAIR TABLE：修复损坏的表。</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>如果InooDB引擎的表出现了损坏，那一定是发生了严重的错误。需要立刻调查原因，最重要的是找出什么导致了损坏，而不是简简单单的修复。可以通过设置innodb_force_recovery参数进入InnoDB的强制恢复模式来修复数据，也可以使用开源的InnoDB数据恢复箱。</li></ul></blockquote><h4 id="更新索引统计信息"><a href="#更新索引统计信息" class="headerlink" title="更新索引统计信息"></a>更新索引统计信息</h4><blockquote><ul><li>MySQL的查询优化器会通过两个API来了解存储引擎的索引值的分布信息，以决定如何使用索引。</li></ul></blockquote><h5 id="records-in-rang"><a href="#records-in-rang" class="headerlink" title="records_in_rang()"></a>records_in_rang()</h5><blockquote><ul><li>通过向存储引擎传入两个边界值获取在这个范围大概有多少条记录，对于某些存储引擎 ，该接口返回精确值，例如:MyISAM；对于另一些存储引擎则是一个估算值，例如:InnoDB.</li></ul></blockquote><h5 id="info-该接口返回各种类型的数据，包括索引的基数。"><a href="#info-该接口返回各种类型的数据，包括索引的基数。" class="headerlink" title="info(),该接口返回各种类型的数据，包括索引的基数。"></a>info(),该接口返回各种类型的数据，包括索引的基数。</h5><h4 id="减少索引和数据的碎片"><a href="#减少索引和数据的碎片" class="headerlink" title="减少索引和数据的碎片"></a>减少索引和数据的碎片</h4><blockquote><ul><li>B-Tree索引可能会碎片化，这会降低查询的效率。碎片化的索引可能会以很差或者无序的方式存储在磁盘上。</li><li>表的数据也可能碎片化，常见的有三种类型：</li></ul></blockquote><h5 id="行碎片"><a href="#行碎片" class="headerlink" title="行碎片"></a>行碎片</h5><blockquote><ul><li>数据行被存储为多个地方的多个片段中，即使查询只从索引中访问一行记录，行碎片也会导致性能下降。</li></ul></blockquote><h5 id="行间碎片"><a href="#行间碎片" class="headerlink" title="行间碎片"></a>行间碎片</h5><blockquote><ul><li>指逻辑上顺序的页，或者行在磁盘上不是顺畅存储的。行间碎片对诸如全表扫描和去除索引扫描之类的操作有很大的影响，因为这些操作原本能够从磁盘上顺序存储的数据中收益。</li></ul></blockquote><h5 id="剩余空间碎片"><a href="#剩余空间碎片" class="headerlink" title="剩余空间碎片"></a>剩余空间碎片</h5><blockquote><ul><li>指数据页中有大量的空余时间。这会导致服务器读取大量不需要的数据，从而造成浪费。</li></ul></blockquote><blockquote><ul><li>对于MyISAM表，三种情况都有可能发生。但InnoDB不会出现短小的行碎片，会移动短小的行并重写到一个片段中。</li></ul></blockquote><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><blockquote><ul><li>可以通过执行OPTIMIZE TABLE或者导出再导入1的方式来重新整理数据。对于MyISAM,可以通过排序算法重建索引的方式来消除碎片。对于新版InnoDB，新增了”在线”添加和删除索引的功能，可以通过先删除，然后再重新创建索引的方式来消除索引的碎片化。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、索引基础&quot;&gt;&lt;a href=&quot;#一、索引基础&quot; class=&quot;headerlink&quot; title=&quot;一、索引基础&quot;&gt;&lt;/a&gt;一、索
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://xingchuan.vip/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>高性能MySQL(三)</title>
    <link href="http://xingchuan.vip/%E9%AB%98%E6%80%A7%E8%83%BDMySQL(%E4%B8%89).html"/>
    <id>http://xingchuan.vip/高性能MySQL(三).html</id>
    <published>2019-07-31T17:26:00.000Z</published>
    <updated>2019-07-31T10:04:18.246Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、性能优化简介"><a href="#一、性能优化简介" class="headerlink" title="一、性能优化简介"></a>一、性能优化简介</h3><blockquote><ul><li>性能定义为完成某件任务所需要的时间度量，换句话说，性能即响应时间，通过任务和时间而不是资源来测量性能。数据库服务器的目的是执行SQL语句，所有它关注的任务是查询或者语句，如SELECT、UPDATE、DELETE等。数据库服务器的性能用查询的响应时间来度量，单位是每个查询花费的时间。</li><li>如果你认为性能优化是降低CPU利用率，那么可以减少对资源的使用，那么打错特错，资源是用来消耗并用来工作的，所有有时候消耗更多的资源能够加快查询速度。</li><li>如果把性能优化仅仅看成提升每秒查询量，这其实只是吞吐量优化。吞吐量替身可以看做性能优化的副产品。</li><li>当优化时，应该把精力和时间都来测量响应时间花在哪里，对症下药的解决方案也就比较明了了。</li><li>有两种比较常见的情况会导致不合适额测量：<blockquote><ul><li>在错误的时间启动和停止测量</li><li>测量的是聚合后的信息，而不是目标活动本身。</li></ul></blockquote></li><li>例如，一个常见的错误哦是先查看慢查询，然后又去排查整个服务器的情况来判断问题在哪里。如果确认有慢查询，那么就应该测试慢查询，而不是测量整个服务器。测量的应该是慢查询的开始时间到结束时间，而不是查询之前或查询之后的时间。</li><li>完成一项任务所需要的时间可以分成两个部分：执行时间和等待时间。如果要优化执行时间，最好的方法就是通过测量定位不同的子任务花费的时间，然后优化去掉一些子任务、降低子任务的执行频率或者提升子任务的效率。而优化任务的等待时间相对于复杂一些，因为等待有可能是由其他系统间接影响导致，任务之间也可能由于争用磁盘或者CPU自由而相互影响。</li></ul></blockquote><h4 id="通过性能剖析进行优化"><a href="#通过性能剖析进行优化" class="headerlink" title="通过性能剖析进行优化"></a>通过性能剖析进行优化</h4><blockquote><ul><li>性能剖析是测量和分析时间花费在哪里的主要方法。一般有两个步骤：测量任务所花费的时间；然后对结果进行统计和排序，将重要的任务排到前面。</li><li>性能剖析工具的方式基本相同，在任务开始时启动计时器，在任务结束时停止计时器，然后用结束时间减去启动时间得到响应时间。也有工具会记录任务的父任务。结果数据用来绘制调用关系图。</li><li>实际讨论两种类型的性能剖析:基于执行时间的分析和基于等待的分析。基于执行时间的分析研究的是什么任务的执行时间最长，而基于等待的分析这是判断任务在什么地方被阻塞的时间最长。</li><li>如果任务执行时间是因为消耗了太多的资源且大部分时间花费在执行上，等待时间不多，这种情况基于等待的分析作用就不大，反之亦然。如果都不确定，那么都试试。</li><li>当基于执行时间的分析发现一个任务需要花费太多时间的时候，应该深入分析下，可能会发现某些”执行时间”实际上是在等待，比如等待I/O完成。</li></ul></blockquote><h4 id="理解性能剖析"><a href="#理解性能剖析" class="headerlink" title="理解性能剖析"></a>理解性能剖析</h4><blockquote><p>mysql的性能剖析将最重要的任务展示在前面，如下：</p></blockquote><h5 id="值得优化的查询"><a href="#值得优化的查询" class="headerlink" title="值得优化的查询"></a>值得优化的查询</h5><blockquote><ul><li>性能剖析不会自动给出那些查询值得优化，一些只占总响应时间比重很小的时间是不值得优化的，对一个占总响应时间不超过5%的查询进行优化，无论如何收益也不会超过5%。如果花费了1000美元去优化一个任务，但业务的收入没有任何增加，那么可以说反而导致业务被逆优化了1000美元。如果优化的成本大于利益，就应当停止优化。</li></ul></blockquote><h5 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h5><blockquote><ul><li>某些任务即使没有出现在性能剖析输出的前面也需要优化。比如某些任务执行次数很少，的但每次执行都非常慢，严重影响用户体验。因为其执行频率低，所以总得响应时间占比并不突出。</li></ul></blockquote><h5 id="未知的未知"><a href="#未知的未知" class="headerlink" title="未知的未知"></a>未知的未知</h5><blockquote><ul><li>性能剖析工具会显示可能的”丢失的时间”,指的是任务的总 时间和实际测量到的时间之间的差，这可能是有些任务没有测量到，也可 能睡测量的误差和精度问题，如果发生这类问题，必须引起重视。</li></ul></blockquote><h5 id="被掩藏的细节"><a href="#被掩藏的细节" class="headerlink" title="被掩藏的细节"></a>被掩藏的细节</h5><blockquote><ul><li>性能剖析无法显示所有的响应时间的分布，只相信平均值是非常危险的，它会隐藏很多信息，而且无法表达全部情况。应该输出更多响应时间的信息，比如直方图、百分比、标准差、偏差指数等。</li></ul></blockquote><hr><h3 id="二、对应用程序进行性能剖析"><a href="#二、对应用程序进行性能剖析" class="headerlink" title="二、对应用程序进行性能剖析"></a>二、对应用程序进行性能剖析</h3><blockquote><ul><li>对系统进行性能剖析建议自上而下地进行，这样可以追踪自用户发起到服务器响应的整个流程。虽然性能问题大多数情况下都和数据库有关，但应用导致的性能问题也不少。性能瓶颈可能有很多影响因素：<blockquote><ul><li>外部资源，比如调用了外部的Web服务或者搜索引擎。</li><li>应用需要处理大量的数据，比如分析一个超大的XML文件。</li><li>在循环中执行昂贵的操作，比如滥用正则表达式。</li><li>使用了低效的算法，比如使用暴力搜索算法来查找列表中的项</li></ul></blockquote></li></ul></blockquote><hr><h3 id="三、剖析MySQL查询"><a href="#三、剖析MySQL查询" class="headerlink" title="三、剖析MySQL查询"></a>三、剖析MySQL查询</h3><h4 id="剖析服务器负载"><a href="#剖析服务器负载" class="headerlink" title="剖析服务器负载"></a>剖析服务器负载</h4><blockquote><ul><li>服务器端的剖析很有价值，因为在服务器端可以有效地审计效率低下的查询。定位和优化”坏”查询能够线束的提升应用的性能，也能解决某些特定的难题。还可以降低服务器的整体压力。这样所有的查询都将因为减少了对共享资源的争用而受益，可以退出或者避免升级更昂贵的硬件的需求，还可以发现和定位糟糕的用户体验，比如某些极端情况。</li></ul></blockquote><h5 id="捕获MySQL的查询到日志文件中"><a href="#捕获MySQL的查询到日志文件中" class="headerlink" title="捕获MySQL的查询到日志文件中"></a>捕获MySQL的查询到日志文件中</h5><blockquote><ul><li>在当前版本中，慢查询日志是开销最低，精度最高的测量查询时间的空间，不需要担心开启慢查询会带来额外的I/O开销。如果长期开启慢查询日志，注意要部署日志轮转工具。或者不要长期启动慢查询日志，只在需要收集负载样本的期间开启即可。</li><li>有时因为某些原因如权限不足等，无法在服务器上记录查询，有两种替代技术：<blockquote><ul><li>通过 –processlist选项不断查看SHOW FULL PROCESSLIST的输出，济洛路查询一次出现的时间和消失时间。某些情况精度足够发现问题，但是无法捕获所有的查询。</li><li>通过抓取TCP网络包，然后根据MySQL的客户端/服务端通信协议进行解析。可以先通过tcpdump将网络包数据保存到磁盘，然后使用pt-query-digest的–type=tcpdump选项来解析并分析查询。精度高，可以捕获所有查询，还可以解析更高级的协议特性，比如可以解析二进制协议，从而创建并执行服务端预解析的语句及压缩协议。</li></ul></blockquote></li></ul></blockquote><h5 id="分析查询日志"><a href="#分析查询日志" class="headerlink" title="分析查询日志"></a>分析查询日志</h5><blockquote><ul><li>强烈建议从现在开始就利用慢查询日志捕获服务器上的所有查询，并且进行分析。可以再一些典型的时间窗口如业务高峰期的一个小时内记录查询。如果业务趋势比较均衡，那么一分钟甚至更短的时间内捕获需要优化的低效查询也是可行的。</li><li>不要直接打开慢查询日志进行分析，应该先生成一个剖析报告，建议使用哪个pt-query-digest，是分析MySQL查询日志最有力的工具，可以将查询报告保存到数据库中，以及追踪工作负载随时间的变化。</li></ul></blockquote><h4 id="剖析单条查询"><a href="#剖析单条查询" class="headerlink" title="剖析单条查询"></a>剖析单条查询</h4><h5 id="使用SHOW-PROFILE"><a href="#使用SHOW-PROFILE" class="headerlink" title="使用SHOW PROFILE"></a>使用SHOW PROFILE</h5><blockquote><ul><li>默认禁用，可以通过服务器变量在会话级(连接)别动态地修改。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET profiling = 1;</span><br></pre></td></tr></table></figure><blockquote><ul><li>然后，在服务器上执行的所有语句，都会测量其耗费时间和其他一些查询执行状态变更相关的数据库。当一条查询提交给服务器时，，此工具会记录剖析信息到一张临时表，并且给查询赋予一个从1开始的证书标识符。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//查询列表</span><br><span class="line">mysql&gt; SHOW PROFILES;</span><br><span class="line">+---------+----------+-----------------------+</span><br><span class="line">|Query_ID | Duration | Query                 |</span><br><span class="line">+---------+----------+-----------------------+</span><br><span class="line">| 1       |0.16767900| SELECT * FROM mytable |</span><br><span class="line">+---------+----------+-----------------------+</span><br><span class="line">//查询queryid为1</span><br><span class="line">mysql&gt; SHOW PROFILE FOR QUERY 1;</span><br><span class="line">+--------------+----------+</span><br><span class="line">|Status        | Duration |</span><br><span class="line">+--------------+----------+</span><br><span class="line">|strating      | 0.000082 |</span><br><span class="line">+--------------+----------+</span><br><span class="line">|Opening talbe | 0.000459 |</span><br><span class="line">+--------------+----------+</span><br><span class="line">|............. | ........ |</span><br></pre></td></tr></table></figure><blockquote><ul><li>可以帮我们精准的定位到哪些活动花费的时间最多，从而针对性的优化。</li></ul></blockquote><h5 id="使用-SHOW-STATUS"><a href="#使用-SHOW-STATUS" class="headerlink" title="使用 SHOW STATUS"></a>使用 SHOW STATUS</h5><blockquote><ul><li>该命令返回了一些计数器。既有服务器级别的全局计数器，也有基于某个连接的会话级别的计数器，在会话开始的时为0，每提交一条查询增加1。</li><li>是一个有用的工具，但并不是一款剖析工具，大部分结果都只是一个计数器。</li></ul></blockquote><h5 id="使用慢查询日志"><a href="#使用慢查询日志" class="headerlink" title="使用慢查询日志"></a>使用慢查询日志</h5><blockquote><ul><li>慢查询日志中包含了SHOW PROFILE和SHOW STATUS所有的输出，并且还有更多的信息。所有通过pt-query-digest发现”坏”查询后，会在慢查询日志中可以获得足够有用的信息。查看报告时，其标题部分一般会有如下输出</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Query 1 ： 0 QPS,0x concurrency，ID 0xEE758C5EOD7EADEE at byte 3214____</span><br></pre></td></tr></table></figure><blockquote><ul><li>可以通过这里的字节偏移值(3214)直接跳转到日志的对应部分</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -c +3214 /path/to/query.log | head -n100</span><br></pre></td></tr></table></figure><h5 id="使用Performance-Schema"><a href="#使用Performance-Schema" class="headerlink" title="使用Performance Schema"></a>使用Performance Schema</h5><blockquote><ul><li>新特性，mysql5.5中还不支持查询界别的剖析信息。</li></ul></blockquote><h4 id="使用性能剖析"><a href="#使用性能剖析" class="headerlink" title="使用性能剖析"></a>使用性能剖析</h4><blockquote><ul><li>当获得服务器或者查询的剖析报告后，怎么使用？好的剖析报告能够把潜在的问题直接显示粗来，但最终的解决方案还需要用户来决定。优化查询时，用户需要对服务器如何执行查询有较深的了解。剖析报告尽可能多的收集需要的信息、给出诊断问题的正确方向，以及为其他诸如EXPALIN等工具提供基础信息</li></ul></blockquote><hr><h3 id="四、诊断间歇性问题"><a href="#四、诊断间歇性问题" class="headerlink" title="四、诊断间歇性问题"></a>四、诊断间歇性问题</h3><blockquote><ul><li>间歇性的问题比如系统偶尔停顿或者慢查询，很难诊断，有些幻影问题只有在没注意到的时候发送，而且很难复现。尽量不要使用试错的方式来解决问题，这种方式有很大的风险，因为结果可能会变得更坏，这也是一种令人沮丧且低效的方式。</li></ul></blockquote><h4 id="单条查询问题还是服务器问题"><a href="#单条查询问题还是服务器问题" class="headerlink" title="单条查询问题还是服务器问题"></a>单条查询问题还是服务器问题</h4><blockquote><ul><li>首先确定这是单条查询问题还是服务器问题，如果服务器上所有的程序都突然变慢，又突然变好，每一条查询页都变慢了，那么慢查询可能就不一定是原因，而是由于其他问题导致的结果。反过来说，如果服务器整体运行没有问题，只有某条查询偶尔变慢，则需要将注意力放到这条特定的查询上面。大多数情况都可以通过三种技术来解决。</li></ul></blockquote><h5 id="使用-SHOW-GLOBAL-STATUS"><a href="#使用-SHOW-GLOBAL-STATUS" class="headerlink" title="使用 SHOW GLOBAL STATUS"></a>使用 SHOW GLOBAL STATUS</h5><blockquote><ul><li>以较高的频率比如一秒执行一次SHOW GLOBAL STATUS命令捕获数据，问题出现时，则可以通过某些计数器(比如Threads_running、Threads_connected、Questions和Queries)的”尖刺”或则”凹陷“来发现，这个方法比较简单，所有人都可以使用，对服务器影响小。</li><li>这个命令每秒输出一行数据，可以运行几个小时或者几天，然后将结果绘制成图形，可以有效方便的发现啥是否有趋势的突变。也可以尽可能长时间的运行此命令，直到发现问题再回头来看输出结果。大多数情况下，通过输出结果都可以更明确的定位问题。</li></ul></blockquote><h5 id="使用-SHOW-PROCESSLIST"><a href="#使用-SHOW-PROCESSLIST" class="headerlink" title="使用 SHOW PROCESSLIST"></a>使用 SHOW PROCESSLIST</h5><blockquote><ul><li>通过不停地捕获SHOW PROCESSLIST的输出，来观察是否有大量线程处理不正常的状态或者右其他不正常的特征。</li><li>使用SHOW PROCESSLIST命令时，在尾部加上\G可以垂直的方式输出结果。</li></ul></blockquote><h5 id="使用查询日志"><a href="#使用查询日志" class="headerlink" title="使用查询日志"></a>使用查询日志</h5><blockquote><ul><li>如果需要通过查询日志发现问题，需要开启慢查询日志并且在全局级别设置time为0，并且要确认所有的连接都采用了新的设置，这可能需要重置所有连接以使新的全局设置生效。</li><li>要注意找到吞吐量突然下降时间段的日志。查询是在完成阶段才写入到慢查询日志的，所所以会堆积造成大量查询处于完成阶段。直到阻塞其他查询的资源占用者释放资源后，其他的查询才能执行完成。这种特征的好处是，当遇到吞吐量突然下降时，可以归咎于吞吐量下降后完成的第一个查询</li></ul></blockquote><h5 id="理解发现的问题"><a href="#理解发现的问题" class="headerlink" title="理解发现的问题"></a>理解发现的问题</h5><blockquote><ul><li>可视化的数据最具有说服力，在实际情况中，利用上面的工具诊断时，可能会产生大量的输出结果。可以选用gnuplot或者R，或者其他绘图工具将结果绘制成图形。</li><li>建议诊断问题时先使用前两种方法：SHOW STATUS和SHOW PROCESSLIST。这两种方法开销很低，可以通过简单的shell脚本或者反复执行的查询来交互式地收集数据，分析慢查询日志则相对要困难一点，经常会发现蛛丝马迹，但仔细研究时可能又消失，1这样我们很容易会认为其实没有问题。</li></ul></blockquote><h4 id="捕获诊断数据"><a href="#捕获诊断数据" class="headerlink" title="捕获诊断数据"></a>捕获诊断数据</h4><blockquote><ul><li>当出现间歇性问题时，需要尽可能地多收集所有的数据，而不只是问题出现时的数据，虽然这样会收集大量的诊断数据，但总比真正能够诊断问题的数据没有被收集到的情况要好。</li><li>开始之前，要搞清楚两件事情：<blockquote><ul><li>一个可靠且实时的”触发器”，也就是能够区分出什么时候问题出现的方法。</li><li>一个手机诊断数据的工具。</li></ul></blockquote></li></ul></blockquote><h5 id="诊断触发器"><a href="#诊断触发器" class="headerlink" title="诊断触发器"></a>诊断触发器</h5><blockquote><ul><li>非常重要，这是在问题出现时能够捕获数据的基础，有两个常见的问题可能会导致无法达到预期的结果：误报或者漏检。<blockquote><ul><li>误报是指收集了很多诊断数据，但期间其实没有发生问题，这可能浪费时间，而令人沮丧。</li><li>漏检则是指在问题出现时没有捕获到数据，错失了机会，一样浪费时间。</li></ul></blockquote></li><li>好的触发器标准是什么？Threads_running的趋势在出现问题时会比较敏感，而没有问题时则比较平稳。SHOW PROCESSLIST中线程的异常状态尖峰也是个不错的指标。</li><li>选择一个合适的阈值很重要，既要足够高，以确保在正常时不会触发；又不能太高，要确保问题发生时不会错过。</li></ul></blockquote><h5 id="需要收集什么样的数据"><a href="#需要收集什么样的数据" class="headerlink" title="需要收集什么样的数据"></a>需要收集什么样的数据</h5><blockquote><ul><li>尽可能收集所有能收集的数据，但只在需要的时间段内手机。包括系统的状态、CPU利用率、磁盘使用率和可用空间、ps的输出采样、内存利用率、已经可以从MySQL获得的信息，例如SHOW STATUS、SHOW PROCESSLIST和SHOW INNODB STATUS。</li><li>执行时间包括用于工作的时间和等待的时间。当一个未知问题发生时，一般来说有两种可能：服务器需要做大量的工作，从而导致大量消耗CPU；或者在等待某些资源被释放。所以需要用不同的方法收集诊断数据，来确认是何种原因。</li></ul></blockquote><h5 id="解释结果数据"><a href="#解释结果数据" class="headerlink" title="解释结果数据"></a>解释结果数据</h5><blockquote><ul><li>第一，检查问题是否真的发生，因为有很多样本数据需要检查，如果是误报就会白白浪费大量的时间。第二，是否有非常明显的跳跃性变化。</li><li>查看异常的查询或事务的行为，以及异常的服务器内部行为通常都是最有收获的。查询或事务的行为可以显示是否是由于使用服务器的方式导致的问题：性能低下的SQL查询、使用不当的索引、设计糟糕的数据库逻辑架构等。通过抓取TCP流量或者SHOW PROCESSLIST输出，可以获得查询和事务出现的地方，从而知道用户对数据库进行了什么操作。</li><li>如果遇到无法解释的错误，则最好将收集到的所有数据打包，提交给技术支持人员进行分析。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、性能优化简介&quot;&gt;&lt;a href=&quot;#一、性能优化简介&quot; class=&quot;headerlink&quot; title=&quot;一、性能优化简介&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://xingchuan.vip/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>高性能MySQL(二)</title>
    <link href="http://xingchuan.vip/%E9%AB%98%E6%80%A7%E8%83%BDMySQL(%E4%BA%8C).html"/>
    <id>http://xingchuan.vip/高性能MySQL(二).html</id>
    <published>2019-07-31T10:10:00.000Z</published>
    <updated>2019-07-31T02:48:39.089Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、什么是基准测试？"><a href="#一、什么是基准测试？" class="headerlink" title="一、什么是基准测试？"></a>一、什么是基准测试？</h3><blockquote><ul><li>是mysql新手和专家都需要掌握的技能。简单来说，基准测试是针对系统设计的一种压力测试。通常是为了掌握系统的行为。但也有其他原因，如重现某个系统状态，或者是做新硬件的可靠性测试。</li></ul></blockquote><hr><h3 id="二、为什么需要基准测试？"><a href="#二、为什么需要基准测试？" class="headerlink" title="二、为什么需要基准测试？"></a>二、为什么需要基准测试？</h3><blockquote><ul><li>是唯一方便有效的、可以学习系统在给定的工作负载下会发生什么的方法。</li><li>可以观察系统在不同压力下的行为，评估系统的荣来，掌握哪些是重要变化，或者观察系统如何处理不同的数据。</li><li>可以在系统实际负载之外创造一些虚构场景进行测试，可以完成以下工作，或者更多：<blockquote><ul><li>验证基于系统的假设，确认这些假设是否符合实际情况。</li><li>重现系统中的某些异常行为，以解决这些异常。</li><li>测试系统当前的运行状态。</li><li>模拟比当前系统更高的负载，以找出系统随着压力增加而可能遇到的扩展性瓶颈。</li><li>规划未来业务增长。</li><li>测试应用适应可变环境的能力。</li><li>测试不同的硬件、软件和操作系统配置。</li><li>证明新采购的设备是否配置正确。</li></ul></blockquote></li><li>主要问题在于其不是真实压力的测试，真实压力复杂多变，基准测试较为简单，所以使用真实压力测试，可能难以从结果中分析出确切的结论。</li><li>我们只能进行大概的测试，来确定系统大致的余量有多少。要尽量简单直接，结果之间容易比较，成本底且易于执行。</li></ul></blockquote><hr><h3 id="三、基准测试的策略"><a href="#三、基准测试的策略" class="headerlink" title="三、基准测试的策略"></a>三、基准测试的策略</h3><blockquote><ul><li>主要有两种主要的策略，：一个针对整个系统的整体测试，另外是单独测试mysql。这两个策略也被称为集成式以及单组件式基准测试。</li></ul></blockquote><h4 id="集成测试："><a href="#集成测试：" class="headerlink" title="集成测试："></a>集成测试：</h4><blockquote><ul><li>测试整个应用系统，包括web服务器、应用代码、网络和数据库是非常有用的，因为用户关注的并不仅仅是mysql本身的性能，而是应用整体的性能。</li><li>mysql并非应用的瓶颈。通过整体测试可以揭示这一点。</li><li>整体应用的集成式测试更能揭示应用的真实表现。而单独组件的测试很难做到这一点。</li></ul></blockquote><h4 id="单组件测试"><a href="#单组件测试" class="headerlink" title="单组件测试"></a>单组件测试</h4><blockquote><ul><li>需要比较不同的schema或查询的性能。</li><li>针对应用中某个棘突问题的测试。<br>为了避免漫长的基准测试，可以通过一个短期的基准测试，做快速的”周期循环”，来检测出某些调整后的效果、</li></ul></blockquote><hr><h3 id="四、测试指标"><a href="#四、测试指标" class="headerlink" title="四、测试指标"></a>四、测试指标</h3><h4 id="吞吐量："><a href="#吞吐量：" class="headerlink" title="吞吐量："></a>吞吐量：</h4><blockquote><ul><li>单位时间内事务的处理树。经典的数据库应用测试指标。主要针对在线事务处理(OLTP的吞吐量,非常适用于多用户的交互式应用。</li><li>单位是每秒事务(TPS)，有些也采用每分钟事务(TPM)。</li></ul></blockquote><h4 id="响应时间或者延迟"><a href="#响应时间或者延迟" class="headerlink" title="响应时间或者延迟"></a>响应时间或者延迟</h4><blockquote><ul><li>用于测试任务所需的整体时间。测试单位可能是微秒、毫秒、秒或者分钟，可以计算出平均响应时间、最小响应时间、最大响应时间和所占百分比，通过使用百分比响应时间来代替最大响应时间。</li><li>使用图表有助于理解测试结果。可以将测试结果绘制成折线图或者散点图。</li></ul></blockquote><h4 id="并发性"><a href="#并发性" class="headerlink" title="并发性:"></a>并发性:</h4><blockquote><ul><li>一个非常重要又经常被误解和误用的指标。Web服务器的并发性不等同于数据库的并发性，而仅仅指表示会话存储机制可以处理多少数据的能力。Web服务器的并发性更准确的度量指标，应该是在任意时间有多少同时发生的并发请求。</li><li>需要关注的是正在工作中的并发操作，或者是同事工作中的线程数或者连接数。当并发性增加时，需要测量吞吐量是否下降，响应时间是否增长，如果是这样，应用可能就无法处理峰值压力。</li></ul></blockquote><h4 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h4><blockquote><ul><li>给系统增加一倍的工作，在理想情况下就能获得两倍的结果，或者说给系统增加一倍的资源(比如两倍的CPU树)，就可以获得两倍的吞吐量。大多数系统无法做到如此理想的线性拓展，随着压力变化。吞吐量和性能都可能越来越差。</li></ul></blockquote><hr><h3 id="五、基准测试方法"><a href="#五、基准测试方法" class="headerlink" title="五、基准测试方法"></a>五、基准测试方法</h3><blockquote><ul><li>这部分不做过多解释，如果是DBA或者测试可以阅读书籍详细观看。主要有五个流程：</li></ul></blockquote><h4 id="设计和规划基准测试"><a href="#设计和规划基准测试" class="headerlink" title="设计和规划基准测试"></a>设计和规划基准测试</h4><blockquote><ul><li>首先获得需要生产数据集的快照。</li><li>针对数据运行查询，建立一个单元测试集作为初步的测试，并运行多边，更好的方法是选择一个有代表性的时间段，比如高峰期一小时，或者一整天，记录生产系统所有查询。如果时间段比较小。可以选择多个时间段，这样有助于覆盖整个系统的活动状态，例如每周报表查询、或者非峰值时间运行的批处理作业。</li><li>可以在不同级别记录查询。例如，如果是集成式基准测试，可以记录Web服务器上的HTTP请求，也可以打开mysql的查询日志。</li></ul></blockquote><h4 id="基准测试应该运行多长时间"><a href="#基准测试应该运行多长时间" class="headerlink" title="基准测试应该运行多长时间"></a>基准测试应该运行多长时间</h4><blockquote><ul><li>应该运行足够长的时间，需要等待系统处于稳定状态，而达到稳定状态需要非常多的时间。</li></ul></blockquote><h4 id="获取系统性能和状态"><a href="#获取系统性能和状态" class="headerlink" title="获取系统性能和状态"></a>获取系统性能和状态</h4><h4 id="获得准确的测试结果集"><a href="#获得准确的测试结果集" class="headerlink" title="获得准确的测试结果集"></a>获得准确的测试结果集</h4><h4 id="运行基准测试并分析结果"><a href="#运行基准测试并分析结果" class="headerlink" title="运行基准测试并分析结果"></a>运行基准测试并分析结果</h4><hr><h3 id="六、基准测试工具"><a href="#六、基准测试工具" class="headerlink" title="六、基准测试工具"></a>六、基准测试工具</h3><h4 id="ab"><a href="#ab" class="headerlink" title="ab"></a>ab</h4><blockquote><ul><li>是一个Apache HTTP服务器基准测试工具。它可以测试HTTP服务器每秒最多可以处理多少请求。如何测试的是Web应用服务，这个结果可以转成整个应用每秒可以满足多少请求，非常简单但用途有限，只能针对单URL进行测试。</li></ul></blockquote><h4 id="http-load"><a href="#http-load" class="headerlink" title="http_load"></a>http_load</h4><blockquote><ul><li>也被设计为Web服务器进行测试，但比ab更加灵活，可以通过一个输入文件提供多高URL，http_load在这些URL中随机选择进行测试。也可以定制http_load,使其按照时间的比率进行从厕所，而不仅仅是测试最大请求处理能力。</li></ul></blockquote><h4 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h4><blockquote><ul><li>是一个Java应用程序，可以加载其他应用并测试其性能。它虽然是设计用来测试Web应用的，但也可以用户测试其他诸如FTP服务器器，或者通过JDBC进行数据库查询测试。</li><li>比ab和http_load的复杂的多，可以通过控制预热时间等参数，更加灵活地模拟真实用户的访问。拥有绘图接口，还可以对测试进行金鸡路，然后离线重演测试结果。</li></ul></blockquote><h4 id="mysqlslap"><a href="#mysqlslap" class="headerlink" title="mysqlslap"></a>mysqlslap</h4><blockquote><ul><li>可以模拟服务器的负载，并输出计时信息，测试时可以执行并发连接数，并指定SQL语句。如果没有指定SQL语句。会自动生成查询schema的SELECT语句。</li></ul></blockquote><h4 id="MySQL-Benchmark-Suite-sql-bench"><a href="#MySQL-Benchmark-Suite-sql-bench" class="headerlink" title="MySQL Benchmark Suite(sql-bench)"></a>MySQL Benchmark Suite(sql-bench)</h4><blockquote><ul><li>单线程，用于测试服务器执行查询的速度，可以用于不同数据库服务器上进行比较测试。单用户模式，测试数据集很小且用户无法使用指定的数据。</li></ul></blockquote><h4 id="Super-Smack"><a href="#Super-Smack" class="headerlink" title="Super Smack"></a>Super Smack</h4><blockquote><ul><li>用于mysql和PostgerSQL的基准测试工具。可以提供压力测试和负载生成，可以模拟多用户访问，可以加载测试数据到数据库，并支持使用随机填充测试表。</li></ul></blockquote><h4 id="sysbench"><a href="#sysbench" class="headerlink" title="sysbench"></a>sysbench</h4><blockquote><ul><li>多线程系统压测工具，可以根据影响数据库服务器性能的各种因素来评估系统的性能。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、什么是基准测试？&quot;&gt;&lt;a href=&quot;#一、什么是基准测试？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是基准
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://xingchuan.vip/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>高性能MySQL(一)</title>
    <link href="http://xingchuan.vip/%E9%AB%98%E6%80%A7%E8%83%BDMySQL(%E4%B8%80).html"/>
    <id>http://xingchuan.vip/高性能MySQL(一).html</id>
    <published>2019-07-30T15:17:00.000Z</published>
    <updated>2019-07-30T08:05:24.131Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、逻辑架构"><a href="#一、逻辑架构" class="headerlink" title="一、逻辑架构"></a>一、逻辑架构</h3><h4 id="1-连接管理与安全性"><a href="#1-连接管理与安全性" class="headerlink" title="1. 连接管理与安全性"></a>1. 连接管理与安全性</h4><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1564459328961&di=ebd13e527e39953dd5f33f73bfd7df6b&imgtype=0&src=http%3A%2F%2Fwww.manongjc.com%2Fimages%2F51jb%2F1530849075153a0x8m49a075.png" alt="架构图"></p><h5 id="第一层"><a href="#第一层" class="headerlink" title="第一层:"></a>第一层:</h5><blockquote><ul><li>大多基于网络客户端/服务器的工具或者服务都有类似的架构，比如连接处理，授权认证，安全等等。</li></ul></blockquote><h5 id="第二层："><a href="#第二层：" class="headerlink" title="第二层："></a>第二层：</h5><blockquote><ul><li>mysql核心功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数。所有的跨存储引擎功能都在这一层实现，比如触发器、存储过程、视图等。</li></ul></blockquote><h5 id="第三层："><a href="#第三层：" class="headerlink" title="第三层："></a>第三层：</h5><blockquote><ul><li>包含存储引擎，负责mysql中的数据的存储和提取。不会解析sql，不同存储引擎也不会相互通信，只是简单的响应上层服务器的请求。</li></ul></blockquote><h4 id="2-优化与执行"><a href="#2-优化与执行" class="headerlink" title="2.优化与执行"></a>2.优化与执行</h4><blockquote><ul><li>每个客户端连接都会在服务器进程中都有一个线程，这个连接的查询只会在这个单独的线程中执行，服务器会缓存线程，不需要新建和销毁。</li></ul></blockquote><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步:"></a>第一步:</h5><blockquote><ul><li>当客户端连接到服务器时，服务器对其进行认证，基于用户名，密码，原始主机信息，连接成功后，会继续验证该客户端是否有执行某个特定查询的权限。</li></ul></blockquote><h5 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h5><blockquote><ul><li>认证通过后，mysql会解析查询，并创建内部数据结构，对其进行优化，包括重写查询，决定表的读取顺序，以及选择合适的索引。用户可以通过关键字(hint)提示优化器，也可以通过explain请求服务器解释优化过程。</li></ul></blockquote><h5 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h5><blockquote><ul><li>对于select查询，在解析查询之前，服务器会先检查查询缓存，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。</li></ul></blockquote><hr><h3 id="二、并发控制"><a href="#二、并发控制" class="headerlink" title="二、并发控制"></a>二、并发控制</h3><h4 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1.读写锁"></a>1.读写锁</h4><blockquote><ul><li>在处理并发读或者写的时候，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。通常被称为共享锁和排他锁，也叫读锁和写锁。</li></ul></blockquote><h5 id="读锁-共享锁-："><a href="#读锁-共享锁-：" class="headerlink" title="读锁(共享锁)："></a>读锁(共享锁)：</h5><blockquote><ul><li>读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源。而互不干扰。</li></ul></blockquote><h5 id="写锁-排它锁-："><a href="#写锁-排它锁-：" class="headerlink" title="写锁(排它锁)："></a>写锁(排它锁)：</h5><blockquote><ul><li>一个写锁会阻塞其他的写锁和读锁，这个处于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的统一资源。</li><li>在实际数据库系统中，锁时时刻刻都在发生，当某个用户正在修改一部分数据时，mysql会通过锁定防止其他用户读取统一数据。</li></ul></blockquote><h4 id="2-锁粒度"><a href="#2-锁粒度" class="headerlink" title="2.锁粒度"></a>2.锁粒度</h4><blockquote><ul><li>提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。而加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁是否已经被解除、释放锁都会增加系统开销。</li><li>所谓所策略，就是在锁的开销和数据的安全性之间寻找平衡，一般都是在表上施加行级锁。</li></ul></blockquote><h5 id="表锁："><a href="#表锁：" class="headerlink" title="表锁："></a>表锁：</h5><blockquote><ul><li>最基本的锁策略，并且是开销最小的策略，它会锁住整张表。一个用户在对表进行写操作(插入、删除、更新等)前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取用户才能获取读锁，读锁之间是不相互阻塞的。</li><li>特定场景中，表锁也可能有良好的性能。例如，READ LOCAL表锁支持某些类型的并发操作。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列前面，反之不不能。</li></ul></blockquote><h5 id="行级锁："><a href="#行级锁：" class="headerlink" title="行级锁："></a>行级锁：</h5><blockquote><ul><li>可以最大程度地支持并发处理(同时也带来了最大的锁开销)。众所周知，在InnoDB和XtraDB，以及其他的一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而mysql服务器层没有实现。</li></ul></blockquote><hr><h3 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h3><blockquote><ul><li>事务就是一组原子性的sql操作，或者说一个独立的工作单元。如果数据库引擎能够成功的对数据库应用该组操作的全部语句，那么就执行该组操作，如果其他有任何一条语句因为崩溃或者其他原因无法执行，那么所有语句都不会执行。</li><li>一句话总结：事务内的语句，要么全部执行成功，要么全部执行失败.</li></ul></blockquote><h4 id="1-ACID"><a href="#1-ACID" class="headerlink" title="1.ACID:"></a>1.ACID:</h4><h5 id="原子性-atomicity"><a href="#原子性-atomicity" class="headerlink" title="原子性(atomicity):"></a>原子性(atomicity):</h5><blockquote><ul><li>一个事务必须被视为一个不可分割的最小工作单元，不可能只执行其中的一部分，这就是事务的原子性。</li></ul></blockquote><h5 id="一致性-consistency-："><a href="#一致性-consistency-：" class="headerlink" title="一致性(consistency)："></a>一致性(consistency)：</h5><blockquote><ul><li>数据库总是从一个一致性的状态转换到另外一个一致性的状态，事务中的操作要么全部执行成功，要么全部失败回滚。</li></ul></blockquote><h5 id="隔离性-isolation"><a href="#隔离性-isolation" class="headerlink" title="隔离性(isolation)"></a>隔离性(isolation)</h5><blockquote><ul><li>一个事务所做的修改在最终提交之前，对其他事务是不可见的。</li></ul></blockquote><h5 id="持久性-durability"><a href="#持久性-durability" class="headerlink" title="持久性(durability)"></a>持久性(durability)</h5><blockquote><ul><li>一旦事务提交，对其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</li></ul></blockquote><h4 id="2-隔离级别："><a href="#2-隔离级别：" class="headerlink" title="2.隔离级别："></a>2.隔离级别：</h4><h5 id="READ-UNCOMMITTED-未提交读-："><a href="#READ-UNCOMMITTED-未提交读-：" class="headerlink" title="READ UNCOMMITTED(未提交读)："></a>READ UNCOMMITTED(未提交读)：</h5><blockquote><ul><li>在未提交读级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也称为脏读。这个级别会导致很多问题，从性能上来说，不会比其他级别好太多，缺缺乏其他级别的很多好处，一般很少使用。</li></ul></blockquote><h5 id="READ-COMMITTED-提交读-不可重复读"><a href="#READ-COMMITTED-提交读-不可重复读" class="headerlink" title="READ COMMITTED(提交读/不可重复读)"></a>READ COMMITTED(提交读/不可重复读)</h5><blockquote><ul><li>解决了脏读的问题。大多数数据默认的隔离级别，mysql不是。简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始知道提交之前，所做的任何修改对其他事务都不可见的。两次执行同样的查询，可能会得到不一样的结果，产生了不可重复读的问题。</li></ul></blockquote><h5 id="REPEATABLE-READ-可重复读-："><a href="#REPEATABLE-READ-可重复读-：" class="headerlink" title="REPEATABLE READ(可重复读)："></a>REPEATABLE READ(可重复读)：</h5><blockquote><ul><li>解决了脏读和不可重复读的问题。mysql的默认隔离级别，该级别保证了再同一事务中多次读取同样记录的结果是一致的。但是无法解决幻读的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另一个事务又会在该范围内插入新的记录，当之前的事务再次读取该范围内的技术时，会产生幻行。InnoDB和XtraDB存储引擎通过多版本并发控制，解决幻读问题。</li></ul></blockquote><h5 id="SERIALIZABLE-可串行化-："><a href="#SERIALIZABLE-可串行化-：" class="headerlink" title="SERIALIZABLE(可串行化)："></a>SERIALIZABLE(可串行化)：</h5><blockquote><ul><li>最高的隔离级别，通过强制事务串行执行，避免了前面说的幻读的问题，会在读取的每一行都加上所，所以可能导致大量的超时和锁争用的问题。实际中很少用到，只有在非常需要确保数据的一致性而且没有并发的情况下，才考虑采用该级别。</li></ul></blockquote><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1564467235392&di=3e5ee36282c1ebfe80e5fb74fe6cd529&imgtype=jpg&src=http%3A%2F%2Fimg3.imgtn.bdimg.com%2Fit%2Fu%3D3830690663%2C1874983557%26fm%3D214%26gp%3D0.jpg" alt></p><h4 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h4><blockquote><ul><li>两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多高事务试图以不同的顺序锁定资源时，就可能产生死锁。多个1事务同事锁定同一个资源时，也会产生死锁。</li></ul></blockquote><h5 id="如何解决死锁？"><a href="#如何解决死锁？" class="headerlink" title="如何解决死锁？"></a>如何解决死锁？</h5><blockquote><ul><li>数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如InnoDB存储引擎，越能检测出死锁的循环依赖，并立即返回一个错误。这种解决方法很有效。</li><li>另一种解决方式，就是当查询的时候达到锁等待超时的设定后放弃锁请求，这种方法不太好。</li><li>InnoDB目前处理死锁的方法是，将持有最少行级排它锁的事务进行回滚。</li><li>死锁发生后，只有部分或者完全回滚其中的一个事务，才能打破死锁。大多数情况下只需要重新执行因死锁回滚的1事务即可。</li></ul></blockquote><h4 id="4-事务日志"><a href="#4-事务日志" class="headerlink" title="4.事务日志"></a>4.事务日志</h4><blockquote><ul><li>提高事务效率，使用时，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不需要每次都将修改的数据本社持久到磁盘。事务日志采用追加的方式，因此写日志的操作是在磁盘上一小块区域内的顺序I/O，事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘，通常称为预写式日志，修改数据需要写两次磁盘。</li><li>如果日志持久化但是数据没有写回磁盘时，系统奔溃，存储引擎在重启后能够自动恢复这部分被修改的数据。</li></ul></blockquote><h4 id="5-mysql中的事务"><a href="#5-mysql中的事务" class="headerlink" title="5.mysql中的事务"></a>5.mysql中的事务</h4><blockquote><ul><li>提供两种事务型的存储引擎：InnoDB和NDB Cluster。</li><li>默认采用自动提交模式，如果不是显式地开始一个事务，则每个查询都被当做一个事务执行提交操作。</li><li>InnoDB采用的是两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会被释放，并且所有的锁是在同一时刻被释放。</li></ul></blockquote><hr><h3 id="四、多版本并发控制-MVCC"><a href="#四、多版本并发控制-MVCC" class="headerlink" title="四、多版本并发控制(MVCC)"></a>四、多版本并发控制(MVCC)</h3><blockquote><ul><li>以InnoDB为主，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。当然存储的不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询道德每行记录的版本号进行比较。<br>下面看一下，在可重复读的级别下，MVCC具体操作。</li></ul></blockquote><h4 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1.SELECT"></a>1.SELECT</h4><blockquote><ul><li>InnoDB会根据以下两个条件检查每行记录：<blockquote><ul><li>a.InnoDB只查找版本早于当前事务版本的数据行(也就是行的系统版本号小于或者等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过得。</li><li>b.行的删除版本要么未定义，要么大于当前事务版本。这样可以确保事务读到的行，在失误开始之前未被删除。</li></ul></blockquote></li><li>只有符合符合上述两个条件的记录，才能返回作为查询结果。</li></ul></blockquote><h4 id="2-INSERT"><a href="#2-INSERT" class="headerlink" title="2.INSERT"></a>2.INSERT</h4><blockquote><ul><li>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</li></ul></blockquote><h4 id="3-DELETE"><a href="#3-DELETE" class="headerlink" title="3.DELETE"></a>3.DELETE</h4><blockquote><ul><li>InnoDB为删除的的每一行保存当前系统版本号作为行删除标识。</li></ul></blockquote><h4 id="4-UPDATE"><a href="#4-UPDATE" class="headerlink" title="4.UPDATE"></a>4.UPDATE</h4><blockquote><ul><li>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。、</li></ul></blockquote><h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4><blockquote><ul><li>保存这两个额外的系统版本号，使大多数读操作都可以不用加锁，操作简单，性能很好，能够保证只会读到符合标准的行。不足在于每个记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</li><li>mysql只在可重复读和提交读两个隔离机制下工作。</li></ul></blockquote><hr><h3 id="五、存储引擎"><a href="#五、存储引擎" class="headerlink" title="五、存储引擎"></a>五、存储引擎</h3><h4 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1.InnoDB"></a>1.InnoDB</h4><blockquote><ul><li>mysql默认的事务型引擎，数据存储在表空间，它是InnoDB管理的黑盒子，由一系列的数据文件组成，可以将每个表的数据和索引存放在单独文件中。</li><li>采用MVCC来支持高并发，并且实现1李四光标准的隔离级别，默认是可重复读，并且可以通过间隙锁策略防止幻读的出现。间隙锁使得InooDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻影行的插入。</li><li>表基于聚簇索引建立，对主键查询有很高的性能，不过它的耳机索引中必须包含主键列。所以主键列很大的话，其他索引都会很大。如果表索引较多，主键应当尽可能的小。</li><li>内如做了很多优化，包括从磁盘读取数据时采用的可预测性玉都，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区。</li></ul></blockquote><h4 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2.MyISAM"></a>2.MyISAM</h4><blockquote><ul><li>mysql5.1版本以前的默认索引，提供大量特性，包括全文索引、压缩、空间函数，但是不支持事务和行级锁，崩溃后无法安全修复对于只读的数据，或者表比较小、可以忍受修复操作，可以使用MyISAM。</li></ul></blockquote><h5 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h5><blockquote><ul><li>加锁与并发<blockquote><ul><li>针对整张表加锁，而不是针对行，读取时会读到所有表加共享锁，写入时则对表加排他。但是在标有读取查询的同时，也可以往表里插入新的数据。</li></ul></blockquote></li><li>修复<blockquote><ul><li>可以收工或者自动执行检查和修复操作，执行表的修复可能导致一些数据丢失，而且修复操作非常慢，可以通过CHECK TABLE mytalbe检查表的错误，如果有错误，可以通过执行REPAIR TABLE mytalbe 进行修复。</li></ul></blockquote></li><li>索引特性<blockquote><ul><li>既是是BLOB和TEXT等长字段，也可以基于前500个字符创建索引，MyISAM也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。</li></ul></blockquote></li><li>延迟更新索引<blockquote><ul><li>创建表时如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引2块写入磁盘，极大的提升写入性能，但是数据库或系统崩溃会造成索引损坏。</li></ul></blockquote></li></ul></blockquote><h4 id="3-mysql内建的其他存储引擎"><a href="#3-mysql内建的其他存储引擎" class="headerlink" title="3.mysql内建的其他存储引擎"></a>3.mysql内建的其他存储引擎</h4><h5 id="Archive引擎"><a href="#Archive引擎" class="headerlink" title="Archive引擎"></a>Archive引擎</h5><blockquote><ul><li>只支持INSERT和SELECT操作。</li></ul></blockquote><h5 id="Blackhole引擎"><a href="#Blackhole引擎" class="headerlink" title="Blackhole引擎"></a>Blackhole引擎</h5><blockquote><ul><li>，没有实现任何的存储机制，它会丢弃索引插入的数据，不做任何保存。</li></ul></blockquote><h5 id="CSV引擎"><a href="#CSV引擎" class="headerlink" title="CSV引擎"></a>CSV引擎</h5><blockquote><ul><li>可以将普通的CSV文件作为mysql的表来处理，但这种表不支持索引。</li></ul></blockquote><h5 id="Federated引擎"><a href="#Federated引擎" class="headerlink" title="Federated引擎"></a>Federated引擎</h5><blockquote><ul><li>方位其他mysql服务器的一个代理，它会创建一个到远程mysql服务器的客户端连接，并将查询传输到远程服务器执行，然后提取或者发送需要的数据。</li></ul></blockquote><h5 id="Memory引擎"><a href="#Memory引擎" class="headerlink" title="Memory引擎"></a>Memory引擎</h5><blockquote><ul><li>如果需要快速地访问数据，并且这些数据不会被修改，重启后丢失也没有关系，则使用Memory表是非常有用的。至少比MyISAM表快一个数量级，因为所有数据数据都保存在内存中，不需要进行磁盘I/O。</li></ul></blockquote><h5 id="Merge引擎"><a href="#Merge引擎" class="headerlink" title="Merge引擎"></a>Merge引擎</h5><blockquote><ul><li>是MyLSAM引擎的变种，由多个MyISAM表合并而来的虚拟表，引入分区后，该引擎已经被放弃。</li></ul></blockquote><h5 id="NDB集群引擎"><a href="#NDB集群引擎" class="headerlink" title="NDB集群引擎"></a>NDB集群引擎</h5><blockquote><ul><li>mysql服务器，NDB集群存储引擎，以及分布式的、share-nothing的、容灾的、高可用的NDB数据库的组合，被称为msql集群。</li></ul></blockquote><h4 id="4-选择合适的存储引擎"><a href="#4-选择合适的存储引擎" class="headerlink" title="4.选择合适的存储引擎"></a>4.选择合适的存储引擎</h4><blockquote><ul><li>大多数情况下，InooDB都是正确的选择，所以在mysql5.5版本后将InnoDB作为默认的存储引擎了，。简单归纳一句话：”除非需要用到某些InnoDB不具备的特性，并没有其他办法代替，否则都应该优先选择InnoDB”。例如用到全文索引，建议优先考虑InnoDB加上Sphinx的组合，而不是支持全文索引的MyISAM。</li></ul></blockquote><h4 id="5-转换表的引擎"><a href="#5-转换表的引擎" class="headerlink" title="5.转换表的引擎"></a>5.转换表的引擎</h4><h5 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h5><blockquote><ul><li>将表从一个引擎修改为另一个引擎最简单的方法就是使用ALTER TABLE语句</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE mytable ENGINE = InnoDB;</span><br></pre></td></tr></table></figure><blockquote><ul><li>需要执行很长时间，原表会加上读锁，会失去和原引擎先关的所有特性。</li></ul></blockquote><h5 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h5><blockquote><ul><li>使用mysqldump工具将数据到处到文件，然后修改文件中CREATE TABLE语句的存储引擎选择，注意同时修改表名。同时要注意mysqldump默认会自动在CREATE TABLE语句前面加上DROP TABLEy语句，不注意这一点可能会导致数据丢失。</li></ul></blockquote><h5 id="创建与查询"><a href="#创建与查询" class="headerlink" title="创建与查询"></a>创建与查询</h5><blockquote><ul><li>综合了第一种和第二张方法，不需要导出整个表数据，而是先创建一个新的存储引擎的表，然后利用INSERT—-SELECT语法来导数据：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;CREATE TABLE innodb_table  LIKE myisam_table;</span><br><span class="line">mysql&gt;ALTER TABLE innodb_table=InnoDB;</span><br><span class="line">mysql&gt;INSERT INTO innodb_table SELECT * FROM myisam_table;</span><br></pre></td></tr></table></figure><blockquote><ul><li>数据量很大，可以考虑做分批处理，针对每一段时间只需事务提交操作，以避免大事务产生过多的uudo。假设有主键字段id，重复运行以下语句(最小值x和最大值y)将数据导入新表：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">mysql&gt; INSERT INTO innodb_table SELECT * FROM myisam_table-&gt; WHERE id BETWEEN x AND y;</span><br><span class="line">mysql&gt; COMMIT;</span><br></pre></td></tr></table></figure><blockquote><ul><li>这样操作完成以后，新表是原表的一个全量复制，原表还在，如果需要可以删除原表。如果有必要，可以在执行的过程中对原表加锁，以确保新表和原表的数据一致。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、逻辑架构&quot;&gt;&lt;a href=&quot;#一、逻辑架构&quot; class=&quot;headerlink&quot; title=&quot;一、逻辑架构&quot;&gt;&lt;/a&gt;一、逻
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://xingchuan.vip/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>UML类图</title>
    <link href="http://xingchuan.vip/UML%E7%B1%BB%E5%9B%BE.html"/>
    <id>http://xingchuan.vip/UML类图.html</id>
    <published>2019-07-29T15:30:00.000Z</published>
    <updated>2019-07-29T08:09:09.930Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、什么是UML图？"><a href="#一、什么是UML图？" class="headerlink" title="一、什么是UML图？"></a>一、什么是UML图？</h3><blockquote><ul><li>UML（Unified Modeling Language）是一种统一建模语言，为面向对象开发系统的产品进行说明、可视化、和编制文档的一种标准语言。UML图分为用例视图、设计视图、进程视图、实现视图和拓扑视图，又可以静动分为静态视图和动态视图。静态图分为：用例图，类图，对象图，包图，构件图，部署图。动态图分为：状态图，活动图，协作图，序列图。</li></ul></blockquote><hr><h3 id="二、UML类图"><a href="#二、UML类图" class="headerlink" title="二、UML类图"></a>二、UML类图</h3><blockquote><ul><li>用户根据用例图抽象成类，描述类的内部结构和类与类之间的关系，是一种静态结构图。 在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。</li></ul></blockquote><blockquote><ul><li>各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</li></ul></blockquote><h4 id="泛化："><a href="#泛化：" class="headerlink" title="泛化："></a>泛化：</h4><blockquote><ul><li>是一种继承关系，指定了子类如何继承父类的所有特征和行为。</li><li>实现+空心三角箭头表示。</li></ul></blockquote><h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><blockquote><ul><li>是一种类与接口的关系，表示类是接口所有特征和行为的实现。</li><li>虚线+空心三角箭头表示。</li></ul></blockquote><h4 id="关联："><a href="#关联：" class="headerlink" title="关联："></a>关联：</h4><blockquote><ul><li>是一种拥有关系，它使一个类知道另一个类的属性和方法。可以是单向也可以是双向。</li><li>双向关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</li></ul></blockquote><h4 id="聚合："><a href="#聚合：" class="headerlink" title="聚合："></a>聚合：</h4><blockquote><ul><li>是整体与部分的关系，且部分可以离开整体而单独存在。</li><li>实线+空心菱形表示</li></ul></blockquote><h4 id="组合："><a href="#组合：" class="headerlink" title="组合："></a>组合：</h4><blockquote><ul><li>是整体与部分的存在，但是部分不能离开整体而单独存在。</li><li>实现+实心菱形表示</li></ul></blockquote><h4 id="依赖："><a href="#依赖：" class="headerlink" title="依赖："></a>依赖：</h4><blockquote><ul><li>是一种使用的关系，一个类的实现需要另一个类的协助，尽量避免双向协助。</li><li>带箭头的虚线，指向被使用者</li></ul></blockquote><hr><h3 id="三、示例图"><a href="#三、示例图" class="headerlink" title="三、示例图"></a>三、示例图</h3><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2055311077,4220686053&fm=26&gp=0.jpg" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、什么是UML图？&quot;&gt;&lt;a href=&quot;#一、什么是UML图？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是UM
      
    
    </summary>
    
      <category term="随记" scheme="http://xingchuan.vip/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="设计模式" scheme="http://xingchuan.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>一句话设计模式</title>
    <link href="http://xingchuan.vip/%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xingchuan.vip/一句话设计模式.html</id>
    <published>2019-07-29T13:50:00.000Z</published>
    <updated>2019-07-29T06:28:51.765Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="创造类"><a href="#创造类" class="headerlink" title="创造类"></a>创造类</h3><h4 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h4><blockquote><ul><li>确保一个类只有一个实例，而且自行实例化并像整个系统提供这个实例。私有化构造方法，提供公共方法获得实例。</li></ul></blockquote><h4 id="工厂方法模式："><a href="#工厂方法模式：" class="headerlink" title="工厂方法模式："></a>工厂方法模式：</h4><blockquote><ul><li>定义一个用于创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的实例化延迟到了子类。</li></ul></blockquote><h4 id="抽象工厂模式："><a href="#抽象工厂模式：" class="headerlink" title="抽象工厂模式："></a>抽象工厂模式：</h4><blockquote><ul><li>为创建一组相关的或者相互依赖的的对象提供一个接口，而无需指定他们的具体类。</li></ul></blockquote><h4 id="建造者模式："><a href="#建造者模式：" class="headerlink" title="建造者模式："></a>建造者模式：</h4><blockquote><ul><li>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</li></ul></blockquote><h4 id="原型模式："><a href="#原型模式：" class="headerlink" title="原型模式："></a>原型模式：</h4><blockquote><ul><li>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。实现Cloneable接口，重写clone方法。</li></ul></blockquote><h4 id="迭代器模式：提供一个方法访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节。Java中已经默认实现，使用foreach即可。"><a href="#迭代器模式：提供一个方法访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节。Java中已经默认实现，使用foreach即可。" class="headerlink" title="迭代器模式：提供一个方法访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节。Java中已经默认实现，使用foreach即可。"></a>迭代器模式：提供一个方法访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节。Java中已经默认实现，使用foreach即可。</h4><hr><h3 id="行为类"><a href="#行为类" class="headerlink" title="行为类"></a>行为类</h3><h4 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h4><blockquote><ul><li>把一个请求或者操作封装在命令对象中，命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和回复功能。</li></ul></blockquote><h4 id="解释器模式："><a href="#解释器模式：" class="headerlink" title="解释器模式："></a>解释器模式：</h4><blockquote><ul><li>给定一种语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</li></ul></blockquote><h4 id="责任链模式："><a href="#责任链模式：" class="headerlink" title="责任链模式："></a>责任链模式：</h4><blockquote><ul><li>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者1之间的解耦关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</li></ul></blockquote><h4 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h4><blockquote><ul><li>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知被自动更新。</li></ul></blockquote><h4 id="中介者模式："><a href="#中介者模式：" class="headerlink" title="中介者模式："></a>中介者模式：</h4><blockquote><ul><li>用一个中介对象封装一系列对象的交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立的改变它们之间的交互。</li></ul></blockquote><h4 id="备忘录模式："><a href="#备忘录模式：" class="headerlink" title="备忘录模式："></a>备忘录模式：</h4><blockquote><ul><li>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到原先保存的状态。</li></ul></blockquote><h4 id="状态模式："><a href="#状态模式：" class="headerlink" title="状态模式："></a>状态模式：</h4><blockquote><ul><li>当一个对象内在状态改变时允许其改变行为，这个对象看起来像是改变了其类。</li></ul></blockquote><h4 id="策略模式："><a href="#策略模式：" class="headerlink" title="策略模式："></a>策略模式：</h4><blockquote><ul><li>定义一组算法，将每个算法都封装起来，并且可以使他们之间可以相互转换。</li></ul></blockquote><h4 id="模板方法模式："><a href="#模板方法模式：" class="headerlink" title="模板方法模式："></a>模板方法模式：</h4><blockquote><ul><li>定义一个操作中的算法骨架，而将一些步骤延伸到子类，使得子类可以不改变一个算法结构即可重定义该算法的某些特定步骤。</li></ul></blockquote><h4 id="访问者模式："><a href="#访问者模式：" class="headerlink" title="访问者模式："></a>访问者模式：</h4><blockquote><ul><li>封装一些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定于作用于这些元素的新操作。</li></ul></blockquote><hr><h3 id="结构类"><a href="#结构类" class="headerlink" title="结构类"></a>结构类</h3><h4 id="适配器模式："><a href="#适配器模式：" class="headerlink" title="适配器模式："></a>适配器模式：</h4><blockquote><ul><li>将一个类的接口变换成客户端所期待的另一个接口，从而使本因接口不必配而无法工作的两个类能够在一起工作。</li></ul></blockquote><h4 id="组合模式："><a href="#组合模式：" class="headerlink" title="组合模式："></a>组合模式：</h4><blockquote><ul><li>将对象组合成树形结构以表示”部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</li></ul></blockquote><h4 id="代理模式；"><a href="#代理模式；" class="headerlink" title="代理模式；"></a>代理模式；</h4><blockquote><ul><li>为其他对象提供一种代理以控制这个对象的访问。</li></ul></blockquote><h4 id="桥梁模式："><a href="#桥梁模式：" class="headerlink" title="桥梁模式："></a>桥梁模式：</h4><blockquote><ul><li>将抽象和实现解耦，使得两者可以独立的变化。</li></ul></blockquote><h4 id="装饰模式："><a href="#装饰模式：" class="headerlink" title="装饰模式："></a>装饰模式：</h4><blockquote><ul><li>动态的给一个对象添加一些额外的职责，就增加功能来说，它相比生成子类更为灵活</li></ul></blockquote><h4 id="门面模式："><a href="#门面模式：" class="headerlink" title="门面模式："></a>门面模式：</h4><blockquote><ul><li>要求一个子系统的外部与内部得同学都必须通过一个统一的对象进行，门面模式提供一个搞层次的接口，使得子系统更易于使用。</li></ul></blockquote><h4 id="享元模式："><a href="#享元模式：" class="headerlink" title="享元模式："></a>享元模式：</h4><blockquote><ul><li>使用共享对象可以有效的支持大量的细粒度的对象。</li></ul></blockquote><hr><h4 id="代码相关链接："><a href="#代码相关链接：" class="headerlink" title="代码相关链接："></a>代码相关链接：</h4><h5 id="《大话设计模式》-《设计模式之禅》"><a href="#《大话设计模式》-《设计模式之禅》" class="headerlink" title="《大话设计模式》 《设计模式之禅》"></a><a href="https://github.com/quietAny/BigTalkDesign" target="_blank" rel="noopener">《大话设计模式》</a> <a href="https://github.com/quietAny/ZenOfDesign" target="_blank" rel="noopener">《设计模式之禅》</a></h5><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;创造类&quot;&gt;&lt;a href=&quot;#创造类&quot; class=&quot;headerlink&quot; title=&quot;创造类&quot;&gt;&lt;/a&gt;创造类&lt;/h3&gt;&lt;h4 
      
    
    </summary>
    
      <category term="随记" scheme="http://xingchuan.vip/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="设计模式" scheme="http://xingchuan.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Resful相关</title>
    <link href="http://xingchuan.vip/Resful%E7%9B%B8%E5%85%B3.html"/>
    <id>http://xingchuan.vip/Resful相关.html</id>
    <published>2019-07-26T12:26:00.000Z</published>
    <updated>2019-07-26T05:04:46.247Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、什么是Resful？"><a href="#一、什么是Resful？" class="headerlink" title="一、什么是Resful？"></a>一、什么是Resful？</h3><blockquote><ul><li>RESTful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</li></ul></blockquote><hr><h3 id="二、常用方法："><a href="#二、常用方法：" class="headerlink" title="二、常用方法："></a>二、常用方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /blog/getArticles --&gt; GET /blog/Articles 获取所有文章</span><br><span class="line">GET /blog/addArticles --&gt; POST /blog/Articles 添加一篇文章</span><br><span class="line">GET /blog/editArticles --&gt; PUT /blog/Articles 修改一篇文章 </span><br><span class="line">GET /rest/api/deleteArticles?id=1 --&gt; DELETE /blog/Articles/1 删除一篇文章</span><br></pre></td></tr></table></figure><hr><h3 id="三、一句话总结！"><a href="#三、一句话总结！" class="headerlink" title="三、一句话总结！"></a>三、一句话总结！</h3><blockquote><ul><li>URL定位资源,HTTP动词描述操作。</li></ul></blockquote><hr><h3 id="四、如何在resful传入多个参数？"><a href="#四、如何在resful传入多个参数？" class="headerlink" title="四、如何在resful传入多个参数？"></a>四、如何在resful传入多个参数？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PutMapping(value = &quot;wx/createCustomer/&#123;number&#125;/&#123;nickName&#125;.do&quot;)</span><br></pre></td></tr></table></figure><hr><h3 id="五、-PathVariable-和-RequestParam区别："><a href="#五、-PathVariable-和-RequestParam区别：" class="headerlink" title="五、@PathVariable 和 @RequestParam区别："></a>五、@PathVariable 和 @RequestParam区别：</h3><blockquote><ul><li>@PathVariable用来绑定url模板变量值，获取url请求中的动态参数</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/zyh/&#123;type&#125;&quot;)</span><br><span class="line">  public String zyh(@PathVariable(value = &quot;type&quot;) int type) throws UnsupportedEncodingException &#123;</span><br><span class="line">    String url = &quot;http://wx.diyfintech.com/zyhMain/&quot; + type;</span><br><span class="line">    if (type != 1 &amp;&amp; type != 2) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;参数错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    String encodeUrl = URLEncoder.encode(url, &quot;utf-8&quot;);</span><br><span class="line">    String redirectUrl = MessageFormat.format(OAUTH_URL, WxConfig.zyhAppId, encodeUrl, &quot;snsapi_userinfo&quot;, UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;));</span><br><span class="line">    return &quot;redirect:&quot; + redirectUrl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>@RequestParam控制层用来获取参数</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/wx&quot;)</span><br><span class="line">public class WxController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private WxService wxService;</span><br><span class="line">    private static final Log log= LogFactory.getLog(WxController.class);</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/service&quot;,method = RequestMethod.GET)</span><br><span class="line">    public void acceptWxValid(@RequestParam String signature, @RequestParam String timestamp, @RequestParam String nonce,</span><br><span class="line">                              @RequestParam String echostr, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">            out.print(echostr);</span><br><span class="line">        &#125;else</span><br><span class="line">            out.print(&quot;fail&quot;);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、什么是Resful？&quot;&gt;&lt;a href=&quot;#一、什么是Resful？&quot; class=&quot;headerlink&quot; title=&quot;一、什
      
    
    </summary>
    
      <category term="随记" scheme="http://xingchuan.vip/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="面试" scheme="http://xingchuan.vip/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与集合(下)</title>
    <link href="http://xingchuan.vip/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88(%E4%B8%8B).html"/>
    <id>http://xingchuan.vip/数据结构与集合(下).html</id>
    <published>2019-07-24T13:01:00.000Z</published>
    <updated>2019-07-24T05:41:01.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、Map集合"><a href="#一、Map集合" class="headerlink" title="一、Map集合"></a>一、Map集合</h3><h5 id="Map类特点"><a href="#Map类特点" class="headerlink" title="Map类特点:"></a>Map类特点:</h5><blockquote><ul><li>Map类取代了旧的抽象对象Dictionary，拥有更好的性能。</li><li>没有重复的key，可以有重复的value。</li><li>Value可以是List、Set、Map类对象。<blockquote><ul><li>AbstractCollection只实现了remove、clear操作，没有修改和删除</li></ul></blockquote></li><li>KV是否允许有空值，以实现类约束为准。<blockquote><ul><li>HashMap允许KV都为空，ConcurrentHashMap不允许KV为空</li></ul></blockquote></li></ul></blockquote><hr><h3 id="二、-树"><a href="#二、-树" class="headerlink" title="二、 树"></a>二、 树</h3><blockquote><ul><li>常用的数据机构，它是一个由有限节点组成的一个具有层次关系的集合，数据就存在树的节点中。最顶层只有一个节点成为根节点。</li></ul></blockquote><h5 id="结构特点："><a href="#结构特点：" class="headerlink" title="结构特点："></a>结构特点：</h5><blockquote><ul><li>一个节点，既是只有根节点，也是一棵树。</li><li>其中任何一个节点与下面所有节点构成的树称为字数。</li><li>根节点没有父节点，而叶子节点没有子节点。</li><li>除根节点外，任何节点有且只有一个父节点。</li><li>任何节点可以有0~n个子节点。</li></ul></blockquote><h6 id="最多有两个节点的树称为二叉树，其中最重要的概念是平衡二叉树、二叉查找树、红黑树。"><a href="#最多有两个节点的树称为二叉树，其中最重要的概念是平衡二叉树、二叉查找树、红黑树。" class="headerlink" title="最多有两个节点的树称为二叉树，其中最重要的概念是平衡二叉树、二叉查找树、红黑树。"></a>最多有两个节点的树称为二叉树，其中最重要的概念是平衡二叉树、二叉查找树、红黑树。</h6><h4 id="1-平衡二叉树"><a href="#1-平衡二叉树" class="headerlink" title="1. 平衡二叉树"></a>1. 平衡二叉树</h4><p><img src="https://img-blog.csdn.net/20180829143433419?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1OTQwOTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p><h5 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h5><blockquote><ul><li>树的左右高度差不能超过1。</li><li>任何往下递归的左子树与右子树，必须符合第一条性质。</li><li>没有任何节点的空树或者只有根节点的树也是平衡二叉树。</li></ul></blockquote><h4 id="2-二叉查找树"><a href="#2-二叉查找树" class="headerlink" title="2. 二叉查找树"></a>2. 二叉查找树</h4><p><img src="https://img-blog.csdn.net/2018082914312743?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1OTQwOTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p><blockquote><ul><li>擅长数据查找，对树增加了额外的要求：对于任意节点来说，它的左子树所有节点的值都小于它，而它的右字数所有节点都必须大于它。</li><li>常见的遍历方式有三种：前序遍历、中序遍历、后续遍历。它们三者规律如下：<blockquote><ul><li>在任何递归子树中，左节点一定在右节点之前先遍历。<br>前序遍历的顺序是根节点、左节点、右节点；中序遍历的顺序是左节点、根节点、右节点；后序遍历的顺序是左节点、右节点、根节点。</li></ul></blockquote></li></ul></blockquote><h4 id="3-AVL树"><a href="#3-AVL树" class="headerlink" title="3. AVL树"></a>3. AVL树</h4><blockquote><ul><li>一种平衡二叉查找树，增加和删除节点通过树形旋转重新达到平衡。</li><li>左旋是以某个节点为中心，将它沉入当前左节点的位置，而让当前的右节点成为新树的根节点，也称为逆时针旋转。<br><img src="https://img-blog.csdn.net/20180829143451434?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1OTQwOTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></li><li>右旋是以某个节点为中心，将它沉入当前右子节点的位置，而让当前的左节点成为新树的根节点，也称为顺时针旋转。<br><img src="https://img-blog.csdn.net/20180829143509110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1OTQwOTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></li></ul></blockquote><h4 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4. 红黑树"></a>4. 红黑树</h4><h5 id="主要特征是在每个节点上增加一个属性来表示节点的颜色以是红色，也可以是黑色。"><a href="#主要特征是在每个节点上增加一个属性来表示节点的颜色以是红色，也可以是黑色。" class="headerlink" title="主要特征是在每个节点上增加一个属性来表示节点的颜色以是红色，也可以是黑色。"></a>主要特征是在每个节点上增加一个属性来表示节点的颜色以是红色，也可以是黑色。</h5><blockquote><ul><li>和AVL树类似，都是在进行插入和删除元素时，通过特定的旋转来保持自首平衡的，从而获得了较高的查找性能。和AVL树相比，红黑树并不追求所有递归子树的高度差不超过1.而是保证从根节点到叶子节点的最长路径不超过最短路径的2倍，通过重新着色和左右旋转，更加高效的完成了插入和删除操作后的自平衡调整。</li><li>5个约束条件：<blockquote><ul><li>节点只能是红色或黑色。</li><li>根节点必须是黑色。</li><li>所有NIL节点都是黑色的。NIL，即叶子节点下挂的两个虚节点。</li><li>一条路径上不能出现相邻的两个红色节点。</li><li>在任何递归子树内，根节点到叶子节点的所有路径上包含相同数目的黑色节点。</li></ul></blockquote></li></ul></blockquote><h6 id="总结一下：”有红必有黑，红红不相连”。如果一个树的左子节点或者右子节点不存在，则均认定为黑色。红黑树的任何旋转在3次只能均可完成。"><a href="#总结一下：”有红必有黑，红红不相连”。如果一个树的左子节点或者右子节点不存在，则均认定为黑色。红黑树的任何旋转在3次只能均可完成。" class="headerlink" title="总结一下：”有红必有黑，红红不相连”。如果一个树的左子节点或者右子节点不存在，则均认定为黑色。红黑树的任何旋转在3次只能均可完成。"></a>总结一下：”有红必有黑，红红不相连”。如果一个树的左子节点或者右子节点不存在，则均认定为黑色。红黑树的任何旋转在3次只能均可完成。</h6><h4 id="5-红黑树和AVL比较"><a href="#5-红黑树和AVL比较" class="headerlink" title="5. 红黑树和AVL比较:"></a>5. 红黑树和AVL比较:</h4><blockquote><ul><li>面对频繁插入和删除，红黑树更为合适；面对低频修改、大量查询，AVL树更为合适。</li></ul></blockquote><hr><h3 id="三、TreeMap"><a href="#三、TreeMap" class="headerlink" title="三、TreeMap"></a>三、TreeMap</h3><blockquote><ul><li>按照Key的排序结果来组织内部结构的Map类集合，它改变了Map类散乱无序的形象。虽然没有ConcurrentHashMap和HashMap普及，但是在Key有排序要求的情况下事半功倍。</li><li>在继承树中，有两个与众不同的接口：SortedMap和NavigableMap。SortedMap表示它的key是有序不可重复的，支持获得头尾的key-value元素。插入的Key必须实现Comparable接口，所以Key不允许为空，Value可以为空。NavigableMap继承SortedMap接口，根据指定的搜索条件返回最匹配的Key-Value元素。不同于HashMap，TreeMap并非一定要重写hashcode和equals方法来达到Key去重的目的。</li></ul></blockquote><h4 id="插入新节点，三个前提条件："><a href="#插入新节点，三个前提条件：" class="headerlink" title="插入新节点，三个前提条件："></a>插入新节点，三个前提条件：</h4><blockquote><ul><li>需要调整的新节点总是红色的。</li><li>如果插入新节点的父节点是黑色的，无需调整。</li><li>如果插入新节点的父节点是红色的，因为红黑树规定不能出现相邻的两个红色节点，所以进入循环判断，或重新着色，或左右旋转，最终达到红黑树的五个约束条件，退出条件如下：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(x != null &amp;&amp; x!= root &amp;&amp; x.parent.color == RED)&#123;...&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果是根节点，则直接退出，设置为黑色即可；如果不是根节点，并且父节点是红色，则一直调整，直到退出循环。</li><li>TreeMap的插入操作就是按照Key的对比往下遍历，大于比较值节点的往右走，小于比较值节点的往左走,先按照二叉查找树的特性进行操作，无需关心节点颜色与树的平衡，后续会重新着色旋转，保持红黑树的特性。</li></ul></blockquote><hr><h3 id="四、HashMap"><a href="#四、HashMap" class="headerlink" title="四、HashMap"></a>四、HashMap</h3><h4 id="三个存储概念："><a href="#三个存储概念：" class="headerlink" title="三个存储概念："></a>三个存储概念：</h4><table><thead><tr><th>名称</th><th align="right">说明</th></tr></thead><tbody><tr><td>table</td><td align="right">存储所有节点数据的数组</td></tr><tr><td>slot</td><td align="right">哈希槽。即table[i]这个位置</td></tr><tr><td>bucket</td><td align="right">哈希桶。table[i]上所有元素形成的表或数的集合</td></tr></tbody></table><blockquote><ul><li>除了局部方法或绝对线程安全情况下，优先推荐使用ConcurrentHashMap。两者性能相差无几，但后者解决了 高并发下线程安全的问题。HashMap的死链问题以及扩容数据丢失问题是慎用HashMap的两个主要原因。</li><li>默认容量16，默认负载因子0.75，当到达阈值(容量 * 负载因子)时，进行扩容。每次扩容容量为原来的两倍。</li></ul></blockquote><h4 id="发生hash冲突的情况："><a href="#发生hash冲突的情况：" class="headerlink" title="发生hash冲突的情况："></a>发生hash冲突的情况：</h4><blockquote><ul><li>两节点Key值相同(hash值一定相同)，导致冲突。</li><li>两节点Key值不同，但是由于hash函数的局限性导致了hash值相同，导致冲突。</li><li>两节点Key值不同，hash值也不同，但是hash值对 数组长度取模后相同，导致冲突。</li></ul></blockquote><h4 id="高并发中，新增对象丢失原因："><a href="#高并发中，新增对象丢失原因：" class="headerlink" title="高并发中，新增对象丢失原因："></a>高并发中，新增对象丢失原因：</h4><blockquote><ul><li>并发赋值时被覆盖。</li><li>已遍历区间新增元素会丢失。</li><li>“新表被覆盖”。</li><li>迁移丢失。在迁移过程中，有并发时，next被提前设置为null。</li></ul></blockquote><h4 id="JDK1-7和1-8中HashMap的区别："><a href="#JDK1-7和1-8中HashMap的区别：" class="headerlink" title="JDK1.7和1.8中HashMap的区别："></a>JDK1.7和1.8中HashMap的区别：</h4><blockquote><ul><li>JDK1.7中使用的是头插法，1.8中使用的是尾插法。因为JDK1.7中是用单链表进行的纵向延伸，采用头插法能够提高插入的效率，但是也会出现逆序且环形链表死循环的问题。在1.8之后加入了红黑树，采用尾插法，能够避免出现逆序且链表死循环的问题。</li><li>扩容后数据存储位置计算方式也不一样:<blockquote><ul><li>1.7直接使用hash值和需要扩容的二进制数进行&amp;(这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞)(hash值 &amp; length-1)。</li><li>1.8直接用了1.7的运算规律，扩容前位置 + 扩容大小值=JDK1.8的计算方式，只需要判断Hash值的新增参与运算的位是0还是1就直接迅速算出扩容后的存储方式。</li></ul></blockquote></li><li>JDK1.7是数组 + 单链表的数据结构，1.8之后，使用的是数组 + 链表 + 红黑树的数据结构(当链表的深度到达8时，就会自动扩容把链表转换成红黑树的数据结构来把时间复杂度从O(N)变成O(LogN)提高了效率；当阈值小于6时，红黑树转换成链表)。</li></ul></blockquote><h4 id="为什么HashMap是线程不安全的？"><a href="#为什么HashMap是线程不安全的？" class="headerlink" title="为什么HashMap是线程不安全的？"></a>为什么HashMap是线程不安全的？</h4><h6 id="HashMap在并发时出现的问题主要是两方面："><a href="#HashMap在并发时出现的问题主要是两方面：" class="headerlink" title="HashMap在并发时出现的问题主要是两方面："></a>HashMap在并发时出现的问题主要是两方面：</h6><blockquote><ul><li>put的时候导致的多线程数据不一致<blockquote><ul><li>两个线程A和B，A先插入key-value到HashMap中，计算出hash桶的索引坐标，获得该桶的链表头节结点，A执行完后B开始执行插入，假设A计算出来的hash桶索引和B计算出的hash桶索引一样，在B插入后，A再次被调度时，执行了旧数据，覆盖了B的插入记录，这样线程B插入的数据就消失了，从而造成数据不一致。</li></ul></blockquote></li><li>resize而引起死循环<blockquote><ul><li>当两个线程同时检测到元素个数超过了数组大小 x 负载因子，同时会在put()方法中调用resize(),两个线程同时修改一个链表结构会产生一个循环列表(JDK1.7中，会出现resize前后元素顺序倒置的情况)。接下来再想通过get()获取一个元素，就会出现死循环。</li></ul></blockquote></li></ul></blockquote><hr><h3 id="五、ConcurrentHashMap"><a href="#五、ConcurrentHashMap" class="headerlink" title="五、ConcurrentHashMap"></a>五、ConcurrentHashMap</h3><h4 id="高并发下其他哈希式集合："><a href="#高并发下其他哈希式集合：" class="headerlink" title="高并发下其他哈希式集合："></a>高并发下其他哈希式集合：</h4><blockquote><ul><li>HashTable是JDK1.0引入的集合，以全互斥的方式处理并发情况，性能极差。</li><li>HashMap是JDK1.2引入的，非线程安全，最大的问题是在并发写的情况下，容易出现死链，导致服务不可用。</li><li>ConcurrentHashMap是JDK1.5引入的线程安全的哈希式集合。</li></ul></blockquote><h4 id="ConcurrentHashMap设计理念；"><a href="#ConcurrentHashMap设计理念；" class="headerlink" title="ConcurrentHashMap设计理念；"></a>ConcurrentHashMap设计理念；</h4><blockquote><ul><li>JDK1.8之前：采用分段锁的设计理念，相当于HashTable和HashMap的折中版本，把数据分成一段一段进行存储，给每一段分配一把锁，当线程占用锁访问其中一个数据时候，其他端的数据也能被其他线程方法，实现真正的并发访问。<blockquote><ul><li>优点：写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，并发能力大大提高。</li><li>缺点：Hash过程要比普通的HashMap要长。</li></ul></blockquote></li><li>JDK1.8之后：参考了HashMap，采用了数组 + 链表 + 红黑树的实现方式来设计，内部大量的采用了CAS操作，彻底放弃了Segment转而采用的是Node。</li></ul></blockquote><hr><h4 id="更多知识点会在后面专题介绍，尽情期待。"><a href="#更多知识点会在后面专题介绍，尽情期待。" class="headerlink" title="更多知识点会在后面专题介绍，尽情期待。"></a>更多知识点会在后面专题介绍，尽情期待。</h4><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、Map集合&quot;&gt;&lt;a href=&quot;#一、Map集合&quot; class=&quot;headerlink&quot; title=&quot;一、Map集合&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="集合" scheme="http://xingchuan.vip/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与集合(上)</title>
    <link href="http://xingchuan.vip/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88(%E4%B8%8A).html"/>
    <id>http://xingchuan.vip/数据结构与集合(上).html</id>
    <published>2019-07-23T13:01:00.000Z</published>
    <updated>2019-07-24T05:40:20.250Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><ul><li>指逻辑意义上数据组织方式及其相应的处理方式</li><li>数据结构=逻辑结构+存储结构+（在存储结构上的）运算/操作</li><li>数据结构是指相互之间存在一种或者多种特定关系的数据元素的集合。<br>是组织并存储数据以便能够有效使用的一种专门格式，它用来反映一个数据的内部构成，即同一个数据由那些成分数据构成，以什么方式构成，是什么结构。</li></ul></blockquote><h4 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h4><p>数据的逻辑结构指数据元素之间的逻辑关系（和实现无关）</p><blockquote><ul><li>分类1：线性结构和非线性结构<blockquote><ul><li>线性结构<br>有且只有一个开始结点和一个终端结点，并且所有的结点都最多只有一个直接前驱和一个直接后驱。<blockquote><ul><li>线性表就是一个典型的线性结构，它有四个基本特征：</li><li>集合中必存在唯一的一个“第一元素”；</li><li>集合中必存在唯一的一个“最后的元素”；</li><li>除最后元素外，其他数据元素均有唯一的“后继”；</li><li>除第一元素外，其他数据元素均有唯一的“前驱”。</li></ul></blockquote></li><li>非线性结构：<br>一个结点元素可能对应多个直接前驱和多个直接后驱。<br>常见的有二叉树，图等。</li></ul></blockquote></li><li>分类2：集合结构、线性结构、树状结构、网状结构<blockquote><ul><li>集合结构<br>该结构的数据元素之间的关系是“同属于一个集合“，别无其他关系<br>三个特征：<blockquote><ul><li>确定性（集合中的元素必须是确定的）</li><li>唯一性（集合中的元素互不相同）、</li><li>无序性（集合中的元素没有前后之分）</li></ul></blockquote></li><li>线性结构<blockquote><ul><li>数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构</li></ul></blockquote></li><li>树状结构<blockquote><ul><li>除了一个元素外，每一个数据元素有且只有一个直接前驱元素，但是可以有多个直接的后续元素，特点是数据元素之间是一对多。</li></ul></blockquote></li><li>网状结构<blockquote><ul><li>每个数据元素之间都可以有多个直接前驱元素，也可以有多个直接后继元素，特点是数据元素之间是多对多的关系。</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><h4 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h4><blockquote><blockquote><blockquote><ul><li>数据的存储结构主要包括数据元素本身的存储结构以及数据元素之间关系表示，是数据的逻辑结构在计算机中的表示。<br>分类：顺序储存、链式储存、索引储存以及散列储存</li><li>顺序存储结构</li><li>把逻辑上相邻的节点存储在物理位置上相邻的存储单元，结点之间的逻辑关系由存储单元的邻接关系来体现</li><li>优点：是节省存储空间，因为分配给数据的存储单元全用存放结点的数据，结点之间没有占用额外的存储空间。</li><li>采用这种方法时，可实现对结点的随机存取，即每一个结点对应一个序号，由该序号可以直接计算出来结点的存储地址。</li><li>缺点：插入和删除需要移动元素，效率较低。</li><li>链式储存结构</li><li>数据元素的存储空间对应的不连续的存储空间，每个存储空间节点对应一个需要存储的元素。<br>每个结点是由数据域和指针域组成。元素之间的逻辑关系通过存储节点之间的链接关系反映出来。</li><li>特点：<blockquote><ul><li>比顺序存储结构的存储密度要小；</li><li>逻辑上相邻的节点物理上不必相邻；</li><li>插入、删除灵活，不需要改变位置，只需要改变指针中的地址；</li><li>查找结点是链式存储要比顺序存储慢。</li></ul></blockquote></li><li>索引储存结构</li><li>除了建立存储结点信息外，还建立附加的索引来标识结点的位置</li><li>散列存储结构</li><li>根据结点的关键字直接计算出该结点的存储地址</li></ul></blockquote></blockquote></blockquote><h2 id="一种神奇的存储结构，添加，查询速度快。"><a href="#一种神奇的存储结构，添加，查询速度快。" class="headerlink" title="一种神奇的存储结构，添加，查询速度快。"></a>一种神奇的存储结构，添加，查询速度快。</h2><h3 id="二、集合"><a href="#二、集合" class="headerlink" title="二、集合"></a>二、集合</h3><h5 id="常见有Set-Queue，List，Map接口，全部继承Collection接口。"><a href="#常见有Set-Queue，List，Map接口，全部继承Collection接口。" class="headerlink" title="常见有Set,Queue，List，Map接口，全部继承Collection接口。"></a>常见有Set,Queue，List，Map接口，全部继承Collection接口。</h5><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><blockquote><ul><li>线性数据结构的主要表现，通常存在明确的上一个和下一个元素，也UC你在明确的第一个元素和最后一个元素。常见的又ArrayList和LinkedList两个集合类。<blockquote><ul><li>ArrayList：容量可以改变的非线程安全集合。内部使用数组存储，集合扩容时会创建更大的数组空间，把原有的数组复制到新数组中。<blockquote><ul><li>优点：能够快速的随机访问</li><li>缺点: 插入和删除时候速度很慢，需要移动元素。</li></ul></blockquote></li><li>LinkedList:本质是双向链表，和ArrayList相比，插入和删除速度更快，但是随机访问速度慢。这个接口同时有队列和栈的性质，包含3个重要成员：size、first、size。size是双向链表中节点的个数。first和last分别指向第一个和最后 一个节点。<blockquote><ul><li>优点：可以将零散的内存单元通过附加引用的方式关联起来，形成按链路顺序查找的线性结构，内存利用率较高。</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><h4 id="Queue集合"><a href="#Queue集合" class="headerlink" title="Queue集合"></a>Queue集合</h4><blockquote><ul><li>一种先入先出的数据结构。队列是一种特殊的线性表，它只允许在表的一端进行获取操作，另一端进行插入操作。当队列为空时，称为空队列。由于其本身FIFO的特性和阻塞操作的特点，常常被作为Buffer(数据缓冲区)使用。</li></ul></blockquote><h4 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h4><blockquote><ul><li>以Key-Value键值作为存储元素实现的哈希结构，Key唯一，value可以重复。最早用于存储键值对的Hashtable因为性能瓶颈已经被淘汰，HashMap线程不安全，ConcurrentHashMap是线程安全的，在多线程中，优先使用ConcurrentHashMap。TreeMap是Key有序的Map类集合。</li></ul></blockquote><h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h4><blockquote><ul><li>不允许出现重复元素的集合类型。最常用的有HashSet、TreeSet和LinkedHashSet。HashSet是使用HashMap来实现的，只是value固定为一个静态对象，使用Key保证集合元素的唯一性，但是它不能保证集合元素的顺序。TreeSet是使用TreeMap来实现的，底层作为树结构，在添加新元素到集合中时，按照某种比较规则将其插入合适的位置，保证插入后的集合仍然有序。LinkedHashSet继承自HashSet，具有HashSet的优点，内部使用链表维护元素插入的顺序。</li></ul></blockquote><hr><h3 id="三、集合初始化"><a href="#三、集合初始化" class="headerlink" title="三、集合初始化"></a>三、集合初始化</h3><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><blockquote><ul><li>如果原始容量13，当添加一个元素时，根据程序中的计算方法，得出113的二进制数右移以为后得到的二进制数110，即十进制数6，最终扩容的大小计算结果为：oledCapacitiy + (oldCapacitiy&gt;&gt;1)=13 + 6 = 19。</li><li>当使用无参数的构造方法时，默认大小为10，也就说第一次add的时候，分配10的容量，每次都调用Array.copyOf方法。当需要把1000个元素放入集合时候，如果我们没有定义容量，将会产生被动扩容和数组复制的额外开销，甚至有可能导致OOM的风险。</li></ul></blockquote><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><blockquote><ul><li>默认容量16，负载因子0.75，基于两数乘积来决定什么时候扩容，第一次扩容按着这个2的幂初始化数组大小，以后每次扩容都是2倍，若没有指定初始值，则为9.96。</li></ul></blockquote><hr><h3 id="四、数组与集合"><a href="#四、数组与集合" class="headerlink" title="四、数组与集合"></a>四、数组与集合</h3><h4 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h4><blockquote><ul><li>注意是否使用了视图方式直接返回数组中的数据。我们以Arrays.asList()为例，它把数组转换成集合时，不能使用其修改集合的相关方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String[] strings = new String[3];</span><br><span class="line">    strings[0] = &quot;one&quot;;</span><br><span class="line">    strings[1] = &quot;two&quot;;</span><br><span class="line">    strings[2] = &quot;three&quot;;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; stringList = Arrays.asList(strings);</span><br><span class="line">    //修改转换后的集合，成功的把第一个元素&quot;one&quot;变&quot;oneList&quot;</span><br><span class="line">    stringList.set(0,&quot;oneList&quot;);</span><br><span class="line">    System.out.println(strings[0]);</span><br><span class="line"></span><br><span class="line">    //以下三个方法编译正确，为什么会抛出运行时异常</span><br><span class="line">    stringList.add(&quot;four&quot;);</span><br><span class="line">    stringList.remove(2);</span><br><span class="line">    stringList.clear();</span><br><span class="line">    //因为asList返回的对象是一个Arrays内部类，并不是真正的ArrayList。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="正确使用："><a href="#正确使用：" class="headerlink" title="正确使用："></a>正确使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//正确使用</span><br><span class="line"> List&lt;String&gt; stringList1 = new ArrayList&lt;&gt;(Arrays.asList(strings));</span><br><span class="line"> stringList1.add(&quot;four&quot;);</span><br><span class="line"> stringList1.remove(2);</span><br><span class="line"> stringList1.clear();</span><br></pre></td></tr></table></figure><h4 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;(3);</span><br><span class="line">    list.add(&quot;one&quot;);</span><br><span class="line">    list.add(&quot;two&quot;);</span><br><span class="line">    list.add(&quot;three&quot;);</span><br><span class="line"></span><br><span class="line">    //泛型丢失，无法使用String[]接收返回的结果</span><br><span class="line">    Object[] array1 = list.toArray();</span><br><span class="line"></span><br><span class="line">    //数组长度小于元素长度</span><br><span class="line">    String[] array2 = new String[2];</span><br><span class="line">    list.toArray(array2);</span><br><span class="line">    System.out.println(Arrays.asList(array2));</span><br><span class="line"></span><br><span class="line">    //数组长度等于正确长度</span><br><span class="line">    String[] array3 = new String[3];</span><br><span class="line">    list.toArray(array3);</span><br><span class="line">    System.out.println(Arrays.asList(array3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>当数组容量等于集合大小时 运行总是最快的，空间消耗也是最少的。由此证明，如果数组初始大小设 不当，不仅会降低性能，还会浪费空间。使用集合的toArray(T[] array) 方法，转换为数组时 注意需要传入类型完全一样的数组并且它的容量大小为list.size();</li></ul></blockquote><hr><h3 id="五、集合与泛型"><a href="#五、集合与泛型" class="headerlink" title="五、集合与泛型"></a>五、集合与泛型</h3><h4 id="List、List、List-lt-gt-的区别？"><a href="#List、List、List-lt-gt-的区别？" class="headerlink" title="List、List、List&lt;?&gt;的区别？"></a>List、List<object>、List&lt;?&gt;的区别？</object></h4><blockquote><ul><li>List完全没有类型限制和赋值限定，如果天马行空的乱用，迟早会遭遇类型转换错误；List<object>在接收其他泛型赋值时会编译报错;List&lt;?&gt;是一个泛型，在没有赋值之前可以接收任何类型的集合赋值，赋值之后就不能随便添加了。</object></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //第一段：泛型出现之前的集合定义方式</span><br><span class="line">        List a1 = new ArrayList();</span><br><span class="line">        a1.add(new Object());</span><br><span class="line">        a1.add(new Integer(111));</span><br><span class="line">        a1.add(new String(&quot;hello a1a1&quot;));</span><br><span class="line"></span><br><span class="line">        //第二段：把a1引用赋值给a2，注意a2和a1的区别是增加了泛型限制&lt;Object&gt;</span><br><span class="line">        List&lt;Object&gt; a2 = a1;</span><br><span class="line">        a2.add(new Object());</span><br><span class="line">        a2.add(new Integer(222));</span><br><span class="line">        a2.add(new String(&quot;hello a2a2&quot;));</span><br><span class="line"></span><br><span class="line">        //第三段：把a1引用赋值给a3，注意a3和a1的区别就是增加了泛型&lt;Integer&gt;</span><br><span class="line">        List&lt;Integer&gt; a3 = a1; </span><br><span class="line">        a3.add(new Integer(333));</span><br><span class="line">        //下面两行出错，不允许加入非Integer的元素加入集合</span><br><span class="line">        a3.add(new Object());</span><br><span class="line">        a3.add(new String(&quot;hello a3a3&quot;));</span><br><span class="line"></span><br><span class="line">        //第四段：把a1引用赋值给a4，a1与a4的区别是增加了通配符</span><br><span class="line">        List&lt;?&gt; a4 = a1;</span><br><span class="line">        //运行删除和清楚元素</span><br><span class="line">        a1.remove(0);</span><br><span class="line">        a4.clear();</span><br><span class="line">        //编译出错，不允许增加任何元素</span><br><span class="line">        a4.add(new Object());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="lt-extends-T-gt-与-lt-super-T-gt-的区别？"><a href="#lt-extends-T-gt-与-lt-super-T-gt-的区别？" class="headerlink" title="&lt;? extends T&gt;与&lt;? super T&gt;的区别？"></a>&lt;? extends T&gt;与&lt;? super T&gt;的区别？</h4><blockquote><ul><li>&lt;? extends T&gt;是Get First，适用于消费集合元素的场景，称为上界通配符，可以赋值给任何T或者T的子类的集合，上界为T，取出来的类型带有泛型限制，向上转型为T。</li><li>&lt;? super T&gt;可以赋值给任何T及T父类的集合，下界为T，称为下界通配符。例如选举代表时，你只能往里投票，取票时，根本不知道谁的票，相当于泛型丢失。</li><li>extends的场景是put功能受限，而super的场景是get功能受限。</li></ul></blockquote><hr><h3 id="六、元素比较"><a href="#六、元素比较" class="headerlink" title="六、元素比较"></a>六、元素比较</h3><h4 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h4><h5 id="原理图："><a href="#原理图：" class="headerlink" title="原理图："></a>原理图：</h5><p><img src="https://images2017.cnblogs.com/blog/1216886/201710/1216886-20171016205125521-1228601863.jpg" alt="avatar"></p><h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//两路归并算法，两个排好序的子序列合并为一个子序列</span><br><span class="line">    public void merge(int []a,int left,int mid,int right)&#123;</span><br><span class="line">        int []tmp=new int[a.length];//辅助数组</span><br><span class="line">        int p1=left,p2=mid+1,k=left;//p1、p2是检测指针，k是存放指针</span><br><span class="line"></span><br><span class="line">        while(p1&lt;=mid &amp;&amp; p2&lt;=right)&#123;</span><br><span class="line">            if(a[p1]&lt;=a[p2])</span><br><span class="line">                tmp[k++]=a[p1++];</span><br><span class="line">            else</span><br><span class="line">                tmp[k++]=a[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(p1&lt;=mid) tmp[k++]=a[p1++];//如果第一个序列未检测完，直接将后面所有元素加到合并的序列中</span><br><span class="line">        while(p2&lt;=right) tmp[k++]=a[p2++];//同上</span><br><span class="line"></span><br><span class="line">        //复制回原素组</span><br><span class="line">        for (int i = left; i &lt;=right; i++)</span><br><span class="line">            a[i]=tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void mergeSort(int [] a,int start,int end)&#123;</span><br><span class="line">        if(start&lt;end)&#123;//当子序列中只有一个元素时结束递归</span><br><span class="line">            int mid=(start+end)/2;//划分子序列</span><br><span class="line">            mergeSort(a, start, mid);//对左侧子序列进行递归排序</span><br><span class="line">            mergeSort(a, mid+1, end);//对右侧子序列进行递归排序</span><br><span class="line">            merge(a, start, mid, end);//合并</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        int[] a = &#123; 49, 38, 65, 97, 76, 13, 27, 50 &#125;;</span><br><span class="line">        mergeSort(a, 0, a.length-1);</span><br><span class="line">        System.out.println(&quot;排好序的数组：&quot;);</span><br><span class="line">        for (int e : a)</span><br><span class="line">            System.out.print(e+&quot; &quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h4><h5 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] arr = &#123;1,4,6,8,2,5,3,7,9&#125;;</span><br><span class="line">    System.out.println(&quot;数组排序前顺序&quot;);</span><br><span class="line">    for (int a : arr) &#123;</span><br><span class="line">        System.out.print(a + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    insertSort(arr);</span><br><span class="line">    System.out.println(&quot;\n数组排序后的顺序&quot;);</span><br><span class="line">    for (int a : arr) &#123;</span><br><span class="line">        System.out.print(a + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 直接插入排序</span><br><span class="line"> * @param arr</span><br><span class="line"> */</span><br><span class="line">private static void insertSort(int[] arr)&#123;</span><br><span class="line">    for (int i = 1; i &lt; arr.length; i++) &#123; //必须i = 1，因为开始从第二个数与第一个数进行比较</span><br><span class="line">        int temp = arr[i]; //待比较值</span><br><span class="line">        int j = i - 1;</span><br><span class="line">        //内存循环为待比较值确定其最终位置</span><br><span class="line">        for (;j &gt;= 0 &amp;&amp; arr[j] &gt; temp;j--)&#123;//如果待比较值比前一位值小，应该往前插一位</span><br><span class="line">            //将大于temp的值整体后移一位</span><br><span class="line">            arr[j+1] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+1] = temp;//待比较值值比前一位值大，确定最终位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TimSort："><a href="#TimSort：" class="headerlink" title="TimSort："></a>TimSort：</h4><h5 id="结合归并排序和插入排序的优点，相对于传统归并排序，减少了并归次数，相对于插入排序，引入了二分排序概念，提升排序效率。它主要有两个优化："><a href="#结合归并排序和插入排序的优点，相对于传统归并排序，减少了并归次数，相对于插入排序，引入了二分排序概念，提升排序效率。它主要有两个优化：" class="headerlink" title="结合归并排序和插入排序的优点，相对于传统归并排序，减少了并归次数，相对于插入排序，引入了二分排序概念，提升排序效率。它主要有两个优化："></a>结合归并排序和插入排序的优点，相对于传统归并排序，减少了并归次数，相对于插入排序，引入了二分排序概念，提升排序效率。它主要有两个优化：</h5><blockquote><ul><li>归并排序的分段不再从单个元素开始，而是每次先查找当前最大的排序好的组数片段run，然后对run进行拓展并进利用二分排序，之后将该run与其他已经排好的run进行归并，产生排好序的大run。</li><li>引入二分排序，即binarySort。二分排序是对插入排序的优化，在排序中不再是从后往前逐个排序，而是引入了二分查找的思想，将一次查找新元素合适位置的时间复杂度从<br>O(n)降低到O(logn)。</li></ul></blockquote><h4 id="hashCode和equals"><a href="#hashCode和equals" class="headerlink" title="hashCode和equals"></a>hashCode和equals</h4><h5 id="用来标识对象。两个方法协同工作可以用来判断对象是否相等。对象通过Object-hashCode-生成哈希值，由于不可避免地存在哈希值冲突的情况，因此当hashCode相同时，还需要再调用equals进行一次值的比较。如果hashCode不同，直接返回Obejcts不同，跳过equals，加快冲突处理效率，Object定义要求如下："><a href="#用来标识对象。两个方法协同工作可以用来判断对象是否相等。对象通过Object-hashCode-生成哈希值，由于不可避免地存在哈希值冲突的情况，因此当hashCode相同时，还需要再调用equals进行一次值的比较。如果hashCode不同，直接返回Obejcts不同，跳过equals，加快冲突处理效率，Object定义要求如下：" class="headerlink" title="用来标识对象。两个方法协同工作可以用来判断对象是否相等。对象通过Object.hashCode()生成哈希值，由于不可避免地存在哈希值冲突的情况，因此当hashCode相同时，还需要再调用equals进行一次值的比较。如果hashCode不同，直接返回Obejcts不同，跳过equals，加快冲突处理效率，Object定义要求如下："></a>用来标识对象。两个方法协同工作可以用来判断对象是否相等。对象通过Object.hashCode()生成哈希值，由于不可避免地存在哈希值冲突的情况，因此当hashCode相同时，还需要再调用equals进行一次值的比较。如果hashCode不同，直接返回Obejcts不同，跳过equals，加快冲突处理效率，Object定义要求如下：</h5><blockquote><ul><li>如果两个对象的equals值相等，则两个对象的hashCode的返回结果也一定相等。</li><li>任何时候重写equals，都必须要重写hashCode。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Client(int id, String name) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        Client client = (Client) o;</span><br><span class="line">        return id == client.id &amp;&amp;</span><br><span class="line">                Objects.equals(name, client.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return Objects.hash(id, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;Client&gt; hashSet = new HashSet&lt;&gt;();</span><br><span class="line">        Client a = new Client(1,&quot;one&quot;);</span><br><span class="line">        Client b = new Client(1,&quot;one&quot;);</span><br><span class="line">        Client c = new Client(1,&quot;one&quot;);</span><br><span class="line">        hashSet.add(a);</span><br><span class="line">        hashSet.add(b);</span><br><span class="line">        hashSet.add(c);</span><br><span class="line">        System.out.println(hashSet.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、fail-fast机制"><a href="#七、fail-fast机制" class="headerlink" title="七、fail-fast机制"></a>七、fail-fast机制</h3><blockquote><ul><li>集合常见的错误检查机制，通常出现在遍历集合元素的过程中。在遍历途中出现意料之外的修改时，通过unchecked异常暴力反馈出来，这种机制常常出现在多线程环境下，当前线程会维护一个计数比较器，即expectedModCount，记录已经修改的次数。在进入遍历前，会把实时修改次数modCount赋值给expectedModCount，如果两个数据不相等，则抛出异常。java.util下所有的集合包都是fail-fast。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        List masterList = new ArrayList();</span><br><span class="line">        masterList.add(&quot;one&quot;);</span><br><span class="line">        masterList.add(&quot;two&quot;);</span><br><span class="line">        masterList.add(&quot;three&quot;);</span><br><span class="line">        masterList.add(&quot;four&quot;);</span><br><span class="line">        masterList.add(&quot;five&quot;);</span><br><span class="line"></span><br><span class="line">        List branchList = masterList.subList(0,3);</span><br><span class="line"></span><br><span class="line">        //下面三行代码如果不注释掉，会导致branchList操作出现异常</span><br><span class="line">        masterList.remove(0);</span><br><span class="line">        masterList.add(&quot;ten&quot;);</span><br><span class="line">        masterList.clear();</span><br><span class="line"></span><br><span class="line">        //下面四行全部能执行</span><br><span class="line">        branchList.clear();</span><br><span class="line">        branchList.add(&quot;sex&quot;);</span><br><span class="line">        branchList.add(&quot;seven&quot;);</span><br><span class="line">        branchList.remove(0);</span><br><span class="line"></span><br><span class="line">        //正常遍历，只有一个元素：seven</span><br><span class="line">        for (Object o: branchList) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //子列表修改导致主列表页被改动，输出：seven，four，five</span><br><span class="line">        System.out.println(masterList);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>concurrent包中所有的集合类都是fail-safe，是在安全的副本上进行遍历，集合修改与副本遍历没有任何关系，但是缺点很明显，就是读取不到最新的数据。</li></ul></blockquote><h5 id="Copy-On-Write"><a href="#Copy-On-Write" class="headerlink" title="Copy-On-Write"></a>Copy-On-Write</h5><blockquote><ul><li>它是并发的一种新思路，实行读写分离，如果是写操作，则复制一个新集合，在新集合内添加或删除元素。待一切修改完成后，再将原集合的引用指向新的集合，这样做的好处是可以高并发地对COW进行读和遍历操作，而不需要加锁，因为当前集合不会添加任何元素。</li><li>使用COW时应该注意两点：<blockquote><ul><li>尽量设置合理的容量初始值，它扩容的代价比较大</li><li>使用批量添加或者删除方法，如addAll或removeAll操作，在高并发请求下，可以攒一下要添加或者删除的元素，避免增加一个元素复制整个集合。如果集合数据是100MB，再写入50MB，那么某个时间段内占用的内存就达到了（100MB x 2) + 50MB = 250MB,内存大量占用会导致GC的频繁发生，从而降低服务器性能。</li></ul></blockquote></li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、数据结构&quot;&gt;&lt;a href=&quot;#一、数据结构&quot; class=&quot;headerlink&quot; title=&quot;一、数据结构&quot;&gt;&lt;/a&gt;一、数
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="集合" scheme="http://xingchuan.vip/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>异常和日志</title>
    <link href="http://xingchuan.vip/%E5%BC%82%E5%B8%B8%E5%92%8C%E6%97%A5%E5%BF%97.html"/>
    <id>http://xingchuan.vip/异常和日志.html</id>
    <published>2019-07-22T12:55:00.000Z</published>
    <updated>2019-07-22T05:36:51.648Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、异常分类"><a href="#一、异常分类" class="headerlink" title="一、异常分类"></a>一、异常分类</h3><h6 id="JDK中定义了一套完整的异常机制，所有异常都是Throwable的子类，主要有分类如下："><a href="#JDK中定义了一套完整的异常机制，所有异常都是Throwable的子类，主要有分类如下：" class="headerlink" title="JDK中定义了一套完整的异常机制，所有异常都是Throwable的子类，主要有分类如下："></a>JDK中定义了一套完整的异常机制，所有异常都是Throwable的子类，主要有分类如下：</h6><h5 id="Error-致命异常"><a href="#Error-致命异常" class="headerlink" title="Error(致命异常)"></a>Error(致命异常)</h5><blockquote><ul><li>一种非常特殊的异常，它的出现标识着系统发生了不可控制的错误，例如StackOverflowErro、OutOfMemoryErro。针对这种错误，程序无法处理，只能人工介入。</li></ul></blockquote><h5 id="Exception-非致命异常"><a href="#Exception-非致命异常" class="headerlink" title="Exception(非致命异常)"></a>Exception(非致命异常)</h5><blockquote><ul><li>checked异常(受检异常)<blockquote><ul><li>需要在代码中显示处理的异常，否则会编译出错。如果能自行处理可以在当前方法中捕获异常，如果无法处理，则继续向调用方法抛出异常，常见的异常主要有SQLException、ClassNotFoundException等。</li></ul></blockquote></li><li>unchecked异常(运行时异常)，他们都继承自RuntimeException，不需要程序进行显式的捕捉和处理。进一步可细分3类：<blockquote><ul><li>可预测异常,常见的包括IndexOutOfBoundsException，NullPointerException等，基于代码性能和稳定性要求，应该做出提前边界检查，空指针判断等处理。</li><li>需捕获异常,例如在使用Dubbo框架进行RPC调用时产生的远程服务器超时异常DubboTimeoutException，此类异常客户端必须显示处理，可以是重试或者降级处理。</li><li>可透出异常，主要是框架或系统产生会自行处理的异常，程序无需关系，比如调转404页面。</li></ul></blockquote></li></ul></blockquote><hr><h3 id="二、异常处理"><a href="#二、异常处理" class="headerlink" title="二、异常处理"></a>二、异常处理</h3><h5 id="try代码块，例："><a href="#try代码块，例：" class="headerlink" title="try代码块，例："></a>try代码块，例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pub ic static int finallyNotWork () &#123; </span><br><span class="line">int temp = 10000 ; </span><br><span class="line">try &#123; </span><br><span class="line">throw new Excepti on (); </span><br><span class="line">&#125; catch (Exception e ) &#123; </span><br><span class="line">return ++temp ;</span><br><span class="line">&#125; finally&#123;</span><br><span class="line">  temp = 99999；  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="如果没有进入进入finally代码块执行，那么有三种可能："><a href="#如果没有进入进入finally代码块执行，那么有三种可能：" class="headerlink" title="如果没有进入进入finally代码块执行，那么有三种可能："></a>如果没有进入进入finally代码块执行，那么有三种可能：</h6><blockquote><ul><li>没有进入try代码块。</li><li>进入try代码块，但是出现了死循环或者死锁。</li><li>进入try代码块，但是执行了System.exit()操作。</li></ul></blockquote><h6 id="注意：finally是在return表达式运行后执行的，此时将要return的结果暂时被保存起来，待finally代码块执行结束后再将之前保存的结果返回，切勿在finally中执行赋值操作。"><a href="#注意：finally是在return表达式运行后执行的，此时将要return的结果暂时被保存起来，待finally代码块执行结束后再将之前保存的结果返回，切勿在finally中执行赋值操作。" class="headerlink" title="注意：finally是在return表达式运行后执行的，此时将要return的结果暂时被保存起来，待finally代码块执行结束后再将之前保存的结果返回，切勿在finally中执行赋值操作。"></a>注意：finally是在return表达式运行后执行的，此时将要return的结果暂时被保存起来，待finally代码块执行结束后再将之前保存的结果返回，切勿在finally中执行赋值操作。</h6><h5 id="自定义异常，继承Exception或者是RuntimeException，在业务中使用throw-new-XxxException（“xxx错误”）来使用。"><a href="#自定义异常，继承Exception或者是RuntimeException，在业务中使用throw-new-XxxException（“xxx错误”）来使用。" class="headerlink" title="自定义异常，继承Exception或者是RuntimeException，在业务中使用throw new XxxException（“xxx错误”）来使用。"></a>自定义异常，继承Exception或者是RuntimeException，在业务中使用throw new XxxException（“xxx错误”）来使用。</h5><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class XxxException extends RuntimeException&#123;</span><br><span class="line">public XxxException()&#123;&#125;</span><br><span class="line">public XxxException(String msg) &#123;</span><br><span class="line">    super(msg);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、日志"><a href="#三、日志" class="headerlink" title="三、日志"></a>三、日志</h3><h5 id="日志级别："><a href="#日志级别：" class="headerlink" title="日志级别："></a>日志级别：</h5><blockquote><ul><li>DEBUG级别：记录对调试程序有帮助的信息。</li><li>INFO级别：用来记录程序运行现场，虽然此处并未发生错误，但是对排查其他错误具有指导意义。</li><li>WARN级别：也可以用来记录程序运行现场，但是更偏向于表明此处有出现潜在错误的可能。</li><li>ERROR级别：表明当前程序运行发生了错误，需要被关注。但是当前发生的错误，没有影响系统的继续运行。</li><li>FATAL级别：表明当前程序运行出现了严重的错误事件，并且将会导致应用程序中断。</li></ul></blockquote><h5 id="常见用法："><a href="#常见用法：" class="headerlink" title="常见用法："></a>常见用法：</h5><p><del>~</del><br>／／使明条件判断形式<br>if (logger.isDebugEnabled()) {<br>logger.debug (“Erocessing trade with id:”+ id + “and symlbol :” + symbol) ;<br>／／使用占位符形式<br>logger.debug (“Processing trade with id: {} and symbol：{}”,id,symbol);</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、异常分类&quot;&gt;&lt;a href=&quot;#一、异常分类&quot; class=&quot;headerlink&quot; title=&quot;一、异常分类&quot;&gt;&lt;/a&gt;一、异
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="exception" scheme="http://xingchuan.vip/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>走进JVM</title>
    <link href="http://xingchuan.vip/%E8%B5%B0%E8%BF%9BJVM.html"/>
    <id>http://xingchuan.vip/走进JVM.html</id>
    <published>2019-07-22T09:53:00.000Z</published>
    <updated>2019-07-22T02:32:05.074Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、字节码"><a href="#一、字节码" class="headerlink" title="一、字节码"></a>一、字节码</h3><h4 id="源码转化成字节码过程："><a href="#源码转化成字节码过程：" class="headerlink" title="源码转化成字节码过程："></a>源码转化成字节码过程：</h4><blockquote><ul><li>Java源文件-&gt;词法解析-&gt;语法解析-&gt;语义分析-&gt;生成字节码</li></ul></blockquote><hr><h3 id="二、类加载过程"><a href="#二、类加载过程" class="headerlink" title="二、类加载过程"></a>二、类加载过程</h3><h6 id="Java的类加载器是一个运行时核心基础设施模块，主要是在启动之初进行类的Load、Link和Init，即加载、链接、初始化。"><a href="#Java的类加载器是一个运行时核心基础设施模块，主要是在启动之初进行类的Load、Link和Init，即加载、链接、初始化。" class="headerlink" title="Java的类加载器是一个运行时核心基础设施模块，主要是在启动之初进行类的Load、Link和Init，即加载、链接、初始化。"></a>Java的类加载器是一个运行时核心基础设施模块，主要是在启动之初进行类的Load、Link和Init，即加载、链接、初始化。</h6><blockquote><ul><li>第一步，Load阶段读取类文件产生二进制流，并转化为特定的数据结构，初步校验cafe babe魔法数、常量池、文件长度、是否有父类，然后创建对应类的java.lang.Class实例。</li><li>第二步，Link阶段包括验证、准备解析三个步骤。验证是更详细的校验，比如final是否合规、类型是否准确静态变量是否合理、准备阶段是为静态变量分配内存，并设定默认值，解析类和方法确保类与类之间的项目引用准确性，完成内存结构布局。</li><li>Init阶段执行类构造器<clinit>方法，如果赋值与那算是通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值。</clinit></li></ul></blockquote><hr><h3 id="三、自定义加载器与双亲委派模型"><a href="#三、自定义加载器与双亲委派模型" class="headerlink" title="三、自定义加载器与双亲委派模型"></a>三、自定义加载器与双亲委派模型</h3><h4 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h4><blockquote><ul><li>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有的那个父加载类在自己的搜索范围内找不到指定的类时，自加载器才会尝试自己去加载。</li></ul></blockquote><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h5><h6 id="默认实现如下："><a href="#默认实现如下：" class="headerlink" title="默认实现如下："></a>默认实现如下：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        return loadClass(name, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="再看看loadClass-String-name-boolean-resolve-函数："><a href="#再看看loadClass-String-name-boolean-resolve-函数：" class="headerlink" title="再看看loadClass(String name, boolean resolve)函数："></a>再看看loadClass(String name, boolean resolve)函数：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从上面面代码可以明显看出，loadClass-String-boolean-函数即是实现了双亲委派模型，大致过程如下："><a href="#从上面面代码可以明显看出，loadClass-String-boolean-函数即是实现了双亲委派模型，大致过程如下：" class="headerlink" title="从上面面代码可以明显看出，loadClass(String,boolean)函数即是实现了双亲委派模型，大致过程如下："></a>从上面面代码可以明显看出，loadClass(String,boolean)函数即是实现了双亲委派模型，大致过程如下：</h5><blockquote><ul><li>首先、检查一下指定名称的类是否已经加载过了，如果加载过了，就不需要加载，直接返回。</li><li>如果此类没有加载过，那么，再判断下是否有父加载器；如果有，则由父加载器加载，或者调用bootstrap类加载器加载。</li><li>如果父加载器及bootstrap类加载器都没有找到指定的类，则调用当前类findClass方法来完成类加载。</li></ul></blockquote><h5 id="换句话说，如果要自定义类加载器，就必要要重写findClas方法。"><a href="#换句话说，如果要自定义类加载器，就必要要重写findClas方法。" class="headerlink" title="换句话说，如果要自定义类加载器，就必要要重写findClas方法。"></a>换句话说，如果要自定义类加载器，就必要要重写findClas方法。</h5><h6 id="默认实现如下：-1"><a href="#默认实现如下：-1" class="headerlink" title="默认实现如下："></a>默认实现如下：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException&#123;</span><br><span class="line">    throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>若果是读取一个指定的名称的类为字节数组，则使用defineClass转换成Class对象，默认实现如下：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</span><br><span class="line">        throws ClassFormatError  &#123;</span><br><span class="line">        return defineClass(name, b, off, len, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数调用过程："><a href="#函数调用过程：" class="headerlink" title="函数调用过程："></a>函数调用过程：</h4><blockquote><ul><li>开始-&gt;loadClass-&gt;父类加载器是否返回Class对象？是的话直接返回，否-&gt;findClass-&gt;根据名称读取文件存入字节数组-&gt;defineClas-&gt;返回Clas对象。</li></ul></blockquote><hr><h3 id="四、内存布局"><a href="#四、内存布局" class="headerlink" title="四、内存布局"></a>四、内存布局</h3><h5 id="主要有类加载子系统、java栈、方法区、Java堆、直接内存、本地方法栈、垃圾回收机制、PC寄存器、执行引擎。"><a href="#主要有类加载子系统、java栈、方法区、Java堆、直接内存、本地方法栈、垃圾回收机制、PC寄存器、执行引擎。" class="headerlink" title="主要有类加载子系统、java栈、方法区、Java堆、直接内存、本地方法栈、垃圾回收机制、PC寄存器、执行引擎。"></a>主要有类加载子系统、java栈、方法区、Java堆、直接内存、本地方法栈、垃圾回收机制、PC寄存器、执行引擎。</h5><blockquote><ul><li>类加载系统和方法区：类加载系统负责从文件系统或者网络中加载class信息，加载的类信息存放在一块称为方法区的内存空间。除了类的信息外，方法区还有可能存放运行时常量池信息，包括字符串常量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）。</li><li>Java堆：Java堆在虚拟机启动的时候建立，它是Java程序中最重要的内存工作区域。几乎所有的java对象实例都存放在java堆中。堆空间的所有线程是共享的，这是一块与java应用密切相关的内存空间。</li><li>直接内存：java的NIO库允许java程序使用直接内存。直接内存是java堆外的，直接向系统申请的工作空间。通常访问直接内存的速度会优于java堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在java堆外，因此它的大小不会受限于xmx指定的最大堆大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li><li>垃圾回收系统：垃圾回收系统是Java虚拟机的重要组成部分，垃圾回收器可以对方法区、java堆和直接内存进行回收。其中，java堆是垃圾收集器的工作重点。和C/C++不同，java中所有的对象空间释放都是隐式的，也就是说，java中没有类似free()或者delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默的查找，标识并释放垃圾对象，完成包括java堆，直接内存和方法区中全自动化管理。</li><li>Java栈：每一个java虚拟机线程都有一个私有的java栈，一个线程的java栈在线程创建的时候被创建，java栈中保存着帧的信息，java栈中保存着局部变量、方法参数、同时和java方法的调用、返回密切相关。</li><li>本地方法栈：本地方法栈和java栈非常类似，最大的不同在于java栈用于方法的调用，而本地方法栈则用于本地方法的调用，作为对java虚拟机的重要拓展，java虚拟机允许java直接调用本地方法（通常使用C编写）。</li><li>PC寄存器：PC寄存器也是每一个线程私有的空间，java虚拟机会为每一个java线程创建PC寄存器。在任意时刻，一个Java线程总是在执行一个方法，这个正在执行的方法称为当前方法。如果当前方法不是本地方法，PC寄存器就会指向正在被执行的指令。如果当前方法是本地方法，那么PC寄存器的值就是undefined。</li><li>执行引擎：执行引擎是Java虚拟机的最核心组件之一，它负责执行虚拟机的字节码文件，现代虚拟机为了提高执行效率，会使用即时编译技术将方法编译成机器码后执行。</li></ul></blockquote><hr><h3 id="五、垃圾回收"><a href="#五、垃圾回收" class="headerlink" title="五、垃圾回收"></a>五、垃圾回收</h3><h4 id="分代策略"><a href="#分代策略" class="headerlink" title="分代策略"></a>分代策略</h4><blockquote><ul><li>JVM内存分代策略<blockquote><ul><li>Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对HotSpot虚拟机而言），这就是JVM内存分代策略。</li></ul></blockquote></li><li>为什么要分代？<blockquote><ul><li>堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收机制最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中，给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾回收，而每次回收都要遍历所有对象，遍历这些对象所花费的时间代价是巨大的，会严重我们的GC效率，这简直太可怕了。</li><li>有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经历过多次回收任然存活下来的对象存放在老年代中，静态属性，类信息存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收的效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾回收算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。</li></ul></blockquote></li><li>内存分代划分<blockquote><ul><li>Java虚拟机将堆内存划分为新生代、老年代和永久代，永久代是HotSpot虚拟机特有的概念，它采用永久代的方式来实现方法区，其他的虚拟机实现没有这一个概念，而且HotSpot也有取消永久代的趋势，在JDK1.7中HotSpot已经开始去“永久化”，把原本放在永久代的字符串常量池移出。永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。</li></ul></blockquote></li><li>新生代<blockquote><ul><li>新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，回收效率很高。</li><li>HoSpot将新生代划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例是8：1：1。划分的目的是因为HotSpot采用主从复制算法来回收新生代，设计这个比例是为了充分利用内存空间，减少浪费。新生成的对象在Eden区分配（大对象除外，大对象直接进入老年代），当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的（作为保留区）。GC进行时，Eden区所有存活的对象都会被复制到To Survivor区，而在From Survivor区中，任然存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认是15，新生代中的对象每熬过一次垃圾回收，年龄值就加一，GC分代年龄储存在对象的header中）的对象就会被移到老年区，没有达到阀值的对象都在To Survivor区。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区，接着From Survivor区和To Survivor区会交换他们的角色，不管怎样都会保证To Survivor区在一轮GC后是空的。GC时当To Survivor区没有足够的空间存放上一次新生代收集下来的存活对象，需要依赖老年代进行分配担，将这些对象放在老年代区。</li></ul></blockquote></li><li>老年代<blockquote><ul><li>在新生代中经历了多次GC后任然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，在老年代中进行GC的频率相对而言较低，而且回收的速度较慢。</li></ul></blockquote></li><li>永久代<blockquote><ul><li>永久代存储类信息、常量、静态变量、即时编译器编译之后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾回收收集，一般而言不会进行垃圾回收。</li></ul></blockquote></li></ul></blockquote><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><blockquote><ul><li>比较古老的算法，原理是此对象有一个引用，既增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象，此算法最致命的是无法处理循环引用的问题。</li></ul></blockquote><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><blockquote><p>*此算法把内存空间分配成两个相等的区域，每次只使用其中的一个区域。垃圾回收时，遍历当前的使用区域，把正在使用的对象复制在另一个区域中，算法每次只处理正在使用中的对象，因此复制都成本较小，同时复制过去还能进行相应的内存整理，不会出现“碎片”问题，当然，此算法的缺点也是很明显的，就是需要两倍的内存空间。</p></blockquote><h5 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h5><blockquote><ul><li>此算法执行分两阶段，第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</li></ul></blockquote><h5 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h5><blockquote><ul><li>此算法整合了“标记-清除”和“复制”两个算法的优点，也是分两个阶段，第一个阶段从根节点开始标记所有被引用的对象，第二个阶段遍历整个堆，清除未标记的对象并且把存活的对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了”复制“算法的空间问题。</li></ul></blockquote><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="Scavenge-GC（次收集）和Full-GC的区别（全收集）"><a href="#Scavenge-GC（次收集）和Full-GC的区别（全收集）" class="headerlink" title="Scavenge GC（次收集）和Full GC的区别（全收集）"></a>Scavenge GC（次收集）和Full GC的区别（全收集）</h5><blockquote><ul><li>新生代GC（Scavenge GC）：<blockquote><ul><li>指发生在新生代的GC，因此新生代的Java对象大多都是朝生夕死，所以Scaveng GC非常频繁，一般回收速度也比较快。当Eden空间不足以为对象分配内存时，会触发Scavenge GC。</li></ul></blockquote></li><li>老年代GC（Full GC/Major GC）：<blockquote><ul><li>Full GC指发生在老年代的GC，出现了Full GC一般都伴随着至少一次的Minor GC（老年代的对象大部分是Minor GC过程中从新生代进入老年代），比如：分配担保失败，Full GC的速度一般会比Minor GC慢10倍以上。当老年代内存不足或者显式调用System.gc()方法时，会触发Full GC。</li></ul></blockquote></li><li>次收集<blockquote><ul><li>当年轻的空间紧张时会被触发</li><li>相对于全收集来说，收集间隔较短</li></ul></blockquote></li><li>全收集<blockquote><ul><li>当老年代或者持久代堆空间满了，会触发全收集操作</li><li>可以使用System.gc()方法来显式的启动全收集<br>全收集一般根据堆大小的不同，需要的时间不尽相同，但是一般会比较长，不过，如果全收集时间超过了3到5秒钟，那就太长了。</li></ul></blockquote></li></ul></blockquote><h5 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h5><blockquote><ul><li>串行收集器（Serial）<blockquote><ul><li>Serial收集器HotSpot运行在client模式下默认的新生代收集器，它的特点是只有一个cpu/一条收集线程去完成GC工作，且在进行垃圾收集时必须暂停其它所有的工作线程。<br>新生代采用复制算法，老年代采用标记-整理算法。</li></ul></blockquote></li><li>并行收集器（ParNew）<blockquote><ul><li>ParNew是Serial的多线程版本，除了使用多线程进行GC之外，包括Serial可用的所有控制参数、收集算法、STW、对象分配规则、回收策略等都与Serial完全一样，由于存在线程切换的开销，ParNew在单cpu的环境中比不上Serial，但是随着线程的增加，效率会大大增加。<br>新生代采用复制算法，老年代采用标记-整理算法。</li></ul></blockquote></li><li>Parallel Scavenge收集器<blockquote><ul><li>与ParNew类似，也是使用复制算法，也是并行多线程收集器，但与其他收集器关注尽可能缩短垃圾收集时间不同，Parallel Scavenge收集器更关注系统吞吐量。<br>系统吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。<br>停顿时间越短越适用于用户交互的程序，而高吞吐量则适用于后台运算而不需要太多交互的任务，可以最高效的利用cpu时间，尽快地完成程序的运算任务。</li></ul></blockquote></li></ul></blockquote><h5 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h5><blockquote><ul><li>erial Old收集器<br>Serial Old是Serial收集器的老年代版本，同样是单线程收集器，使用标记-整理算法。</li><li>Parallel Old收集器<br>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法，吞吐量优先，主要是和Parallel Scavenge在注重吞吐量及cpu资源敏感系统内使用。</li><li>CMS收集器<blockquote><ul><li>CMS是一个具有跨时代的收集器，一款真正意义上的并发收集器，虽然已经有了理论意义上表现更好的G1收集器，但现在主流互联网企业线上仍然是CMS。</li><li>CMS是一种以获取最短回收停顿时间为目标的收集器，又称为多并发低暂停的收集器，基于标记-清除算法实现，整个GC过程分为以下4个步骤：<blockquote><ul><li>初始标记；</li><li>并发标记；</li><li>重新标记；</li><li>并发清除。</li></ul></blockquote></li><li>由于CMD采用标记-清除算法实现，可能会产生大量的内存碎片，内存碎片过多会导致无法分配大对象而提前触发Full GC，因此CMS提供了-xx：+UseCMSCompactAtFullCollection开关参数。用于在Full GC之后再执行一次碎片整理过程，但是内存整理是无法并发的，内存碎片问题虽然没有了， 但是停顿时间也因此变长了，因此CMS还提供了一个参数-xx：CMSFullGCsBeforeCompaction用于设置在执行N次不进行内存整理的Full GC后，跟着来一次带整理的。</li></ul></blockquote></li></ul></blockquote><h5 id="分区收集-G1收集器（Garbage-First）"><a href="#分区收集-G1收集器（Garbage-First）" class="headerlink" title="分区收集-G1收集器（Garbage-First）"></a>分区收集-G1收集器（Garbage-First）</h5><blockquote><ul><li>G1是一款面向服务端应用的收集器，主要目标用于配备多频cpu的服务器治理大内存</li></ul><p>–XX:+UseG1GC，启动G1收集<br>与其他基于分代的收集器不同，G1将整个Java堆划分分为多个大小相等的独立区域，虽然还保留着新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、字节码&quot;&gt;&lt;a href=&quot;#一、字节码&quot; class=&quot;headerlink&quot; title=&quot;一、字节码&quot;&gt;&lt;/a&gt;一、字节码&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="JVM" scheme="http://xingchuan.vip/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型知识点</title>
    <link href="http://xingchuan.vip/%E6%B3%9B%E5%9E%8B.html"/>
    <id>http://xingchuan.vip/泛型.html</id>
    <published>2019-07-19T17:21:00.000Z</published>
    <updated>2019-07-22T01:00:15.775Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、什么是泛型？"><a href="#一、什么是泛型？" class="headerlink" title="一、什么是泛型？"></a>一、什么是泛型？</h3><blockquote><ul><li>本质就是类型参数化，可以定义在类、接口、方法中，编辑器通过识别尖括号和尖括号内的字母来解析泛型。在定义泛型时，约定俗称的符号包括：E代表Element，用户集合中的元素；T代表the type of object，表示某个类；K代表Key，V代表Value，用户键值对元素。</li></ul></blockquote><hr><h3 id="二、使用泛型的好处"><a href="#二、使用泛型的好处" class="headerlink" title="二、使用泛型的好处"></a>二、使用泛型的好处</h3><blockquote><ul><li>类型安全。放置的是什么，取回来的自然是什么，不用担心会抛出ClassCastException异常。</li><li>提升可读性，从编码阶段就显式地知道泛型集合、泛型方法等处理的对象类型是什么。</li><li>代码重用。泛型合并了同类型的处理代码，使代码重用度变高。</li></ul></blockquote><hr><h3 id="三、常见用法"><a href="#三、常见用法" class="headerlink" title="三、常见用法"></a>三、常见用法</h3><h5 id="泛型类："><a href="#泛型类：" class="headerlink" title="泛型类："></a>泛型类：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class DateHolder&lt;T&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line">    </span><br><span class="line">    public void setData(T t)&#123;</span><br><span class="line">        this.item = t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public T getDat()&#123;</span><br><span class="line">        return this.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class DateHolder&lt;T&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line">    </span><br><span class="line">    public void setData(T t)&#123;</span><br><span class="line">        this.item = t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public T getDat()&#123;</span><br><span class="line">        return this.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   /**</span><br><span class="line">    * 泛型方法</span><br><span class="line">    * @param e</span><br><span class="line">    */</span><br><span class="line">    public &lt;E&gt; void PrinterInfo(E e)&#123;</span><br><span class="line">        system.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//定义一个泛型接口</span><br><span class="line">public interface Generator&lt;T&gt;&#123;</span><br><span class="line">    public T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、泛型擦除及其相关内容"><a href="#四、泛型擦除及其相关内容" class="headerlink" title="四、泛型擦除及其相关内容"></a>四、泛型擦除及其相关内容</h3><h5 id="我们下面看一个例子："><a href="#我们下面看一个例子：" class="headerlink" title="我们下面看一个例子："></a>我们下面看一个例子：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1 = new ArrayList&lt;String&gt;().getClass();</span><br><span class="line">Class&lt;?&gt; class2 = new ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">System.out.println(class1);</span><br><span class="line">System.out.println(class2);</span><br><span class="line">System.out.println(class1.equals(class2);</span><br><span class="line"></span><br><span class="line">结果： </span><br><span class="line">    java.util.ArrayList</span><br><span class="line">    java.util.ArrayList</span><br><span class="line">    true</span><br></pre></td></tr></table></figure><blockquote><ul><li>我们看输出发现，class1和class2居然是同一个类型ArrayList，在运行时我们传入的类型变量String和Integer都被丢掉了。Java语言泛型在设计的时候为了兼容原来的旧代码，Java的泛型机制使用了”擦除机制”。</li></ul></blockquote><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><ul><li>编译器虽然会在编译过程中移除参数的类型信息，但是会保证类或方法内部参数类型的一致性。</li><li>泛型参数将会被擦除到它的第一个边界，如果没有指明边界，那么类型将会被擦除到Object。</li></ul></blockquote><h5 id="类型擦除原理："><a href="#类型擦除原理：" class="headerlink" title="类型擦除原理："></a>类型擦除原理：</h5><blockquote><ul><li>在编译过程中，类型变量的信息是能拿到的。所以，set方法在编辑器可以做类型检查，非法类型不能通过编译。但是对于get方法，由于擦除机制，运行时的实际引用为Object类型，为了还原返回结果的类型，编辑器在get方法后面添加了类型转换。</li></ul></blockquote><h5 id="类型擦除的缺陷和补救措施"><a href="#类型擦除的缺陷和补救措施" class="headerlink" title="类型擦除的缺陷和补救措施"></a>类型擦除的缺陷和补救措施</h5><p>泛型类型不能显示地运用在运行时类型的操作中，例如：转型、instanceof 和 new。因为在运行中，所有参数的类型都丢失了。类似如下代码则无法通过编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Erased&lt;T&gt;&#123;</span><br><span class="line">    private final int SIZE = 100;</span><br><span class="line">    public static void f(Object arg)&#123;</span><br><span class="line">        //编译不通过</span><br><span class="line">        if(arg instanceof T)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        //编译不通过</span><br><span class="line">        T var = new T();</span><br><span class="line">        //编译不通过</span><br><span class="line">        T[] array = new T[SIZE];</span><br><span class="line">        //编译不通过</span><br><span class="line">        T[] array = (T) new Object[SIZE]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决措施："><a href="#解决措施：" class="headerlink" title="解决措施："></a>解决措施：</h5><blockquote><ul><li>类型判断问题</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 泛型类型判断封装类</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class GenericType&lt;T&gt;&#123;</span><br><span class="line">    Class&lt;?&gt; classType;</span><br><span class="line">    </span><br><span class="line">    public GenericType(Class&lt;?&gt; type)&#123;</span><br><span class="line">        this.classType = type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean isInstance(Object object)&#123;</span><br><span class="line">        return classType.inInstance(Object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>创建类型实例</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *使用工厂方法来创建实例</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">interface Factory&lt;T&gt;&#123;</span><br><span class="line">    T create();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class creater&lt;T&gt;&#123;</span><br><span class="line">    T instance;</span><br><span class="line">    public &lt;F extends Factory&lt;T&gt;&gt;T newInstance(F f)&#123;</span><br><span class="line">    instance = f.create();</span><br><span class="line">    return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class IntegerFactory implements Factory&lt;Integer&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer create()&#123;</span><br><span class="line">        Integer integer = new Integer(9);</span><br><span class="line">        return integer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>创建泛型数组<blockquote><p>一般不建议创建泛型数组，尽量使用ArrayList来代替泛型数组。</p></blockquote></li></ul></blockquote><hr><h3 id="五、Java泛型的通配符"><a href="#五、Java泛型的通配符" class="headerlink" title="五、Java泛型的通配符"></a>五、Java泛型的通配符</h3><h5 id="上界通配符-lt-extends-T-gt"><a href="#上界通配符-lt-extends-T-gt" class="headerlink" title="上界通配符&lt;? extends T&gt;:"></a>上界通配符&lt;? extends T&gt;:</h5><blockquote><ul><li>只适合频繁读取的场景，例：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Food&#123;&#125;</span><br><span class="line">class Fruit extends Food&#123;&#125;</span><br><span class="line">class Apple extends Fruit&#123;&#125;</span><br><span class="line">class Banana extends Fruit&#123;&#125;</span><br></pre></td></tr></table></figure><p>在上面这个层次，可以用Plate&lt;? extends Fruit&gt;,无法存放，因为编译器只知道容器里存放的是Fruit和它的派生类，不知道具体类，但是可以进行读取操作。</p><h5 id="下界通配符-lt-super-T-gt"><a href="#下界通配符-lt-super-T-gt" class="headerlink" title="下界通配符&lt;? super T&gt;:"></a>下界通配符&lt;? super T&gt;:</h5><blockquote><ul><li>不影响往里面存储，但是读取出来的数据只能是Object类型，里面存储的都是T及其基类，无法转换成任何一种类型，只能转换成Object基类才能放下。</li></ul></blockquote><h5 id="lt-gt-无限通配符"><a href="#lt-gt-无限通配符" class="headerlink" title="&lt;?&gt;无限通配符"></a>&lt;?&gt;无限通配符</h5><blockquote><ul><li>无界通配符修饰的容器持有的是某种具体的类型。举个例子，在List&lt;？&gt;类型的引用中，不能向其中添加Object，而在List类型的引用中，可以添加Object对象。</li></ul></blockquote><h5 id="PECS原则："><a href="#PECS原则：" class="headerlink" title="PECS原则："></a>PECS原则：</h5><blockquote><ul><li>上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。</li><li>下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、什么是泛型？&quot;&gt;&lt;a href=&quot;#一、什么是泛型？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是泛型？&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="泛型" scheme="http://xingchuan.vip/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>HTTP/HTTPS</title>
    <link href="http://xingchuan.vip/http%E5%92%8Chttps.html"/>
    <id>http://xingchuan.vip/http和https.html</id>
    <published>2019-07-19T15:00:00.000Z</published>
    <updated>2019-07-19T07:44:33.747Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、什么是HTTP和HTTPS？"><a href="#一、什么是HTTP和HTTPS？" class="headerlink" title="一、什么是HTTP和HTTPS？"></a>一、什么是HTTP和HTTPS？</h3><h5 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h5><blockquote><ul><li>超文本传输协议，所有的www文件都必须遵守这个标准，互联网上应用最广泛的一种网络协议。</li></ul></blockquote><h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS:"></a>HTTPS:</h5><blockquote><ul><li>是以安全为目标的HTTP通道，简单来说就是HTTP的安全办，即HTTP下加入SLL层，HTTPS的安全基础是SLL，因此加密的详细内容就需要要SSL。</li><li>主要作用：建立一个信息安全通道，保证数据安全；确定网站真实性。</li></ul></blockquote><hr><h3 id="二、两者区别"><a href="#二、两者区别" class="headerlink" title="二、两者区别"></a>二、两者区别</h3><blockquote><ul><li>http免费试用，https协议需要ca申请证书，一般免费证书很少，需要交费。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的完全不一样的端口，前者是80，后者是443。</li><li>http的连接很简单，是无状态的。</li><li>https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</li></ul></blockquote><hr><h3 id="三、HTTPS工作流程"><a href="#三、HTTPS工作流程" class="headerlink" title="三、HTTPS工作流程"></a>三、HTTPS工作流程</h3><blockquote><ul><li>客户端使用https的URL访问Web服务器，要求与Web服务器建立SSL连接；</li><li>Web服务器接收客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端；</li><li>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级；</li><li>客户端浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站；</li><li>Web服务器利用自己的私钥解密会话密钥；</li><li>Web服务器利用会话密钥加密与客户端之间的通信。</li></ul></blockquote><hr><h3 id="四、一句话总结HTTPS"><a href="#四、一句话总结HTTPS" class="headerlink" title="四、一句话总结HTTPS"></a>四、一句话总结HTTPS</h3><blockquote><ul><li>HTTPS要使客户端与服务器端的通信过程得到安全的保证。必须使用对称加密，但是协商对称密钥的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身就不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这种机制协商出一个对称加密算法，之后双方再使用该算法进行加解密，从而解决了客户端与服务端之间的通信安全问题。</li></ul></blockquote><hr><h3 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a>五、常见问题</h3><h5 id="TLS和SLL的区别？"><a href="#TLS和SLL的区别？" class="headerlink" title="TLS和SLL的区别？"></a>TLS和SLL的区别？</h5><blockquote><ul><li>TLS可以理解成SSL协议3.0版本的升级，所以TLS的1.0版本也被标识为SSL3.1版本。</li></ul></blockquote><h5 id="什么是对称加密和非对称加密？"><a href="#什么是对称加密和非对称加密？" class="headerlink" title="什么是对称加密和非对称加密？"></a>什么是对称加密和非对称加密？</h5><blockquote><ul><li>对称加密：最快速、最简单的加密方式，加密与解密同样的密钥，这种方法在密码学中叫做对称加密算法。最大缺点是密钥的管理和分配，在发送密钥的过程中，密钥有很大的风险会被黑客拦截。通常做法是将对称加密的密钥进行非对称加密，然后传输给需要他的人。</li><li>非对称加密：为数据加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥和私钥。私钥只能由一方保管，不能外泄，而公钥则可以发送给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发送给你，你使用公钥对数据加密，只有私钥的持有人银行才能对你的消息进行解密，安全性大大提高。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、什么是HTTP和HTTPS？&quot;&gt;&lt;a href=&quot;#一、什么是HTTP和HTTPS？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="https" scheme="http://xingchuan.vip/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>网络安全</title>
    <link href="http://xingchuan.vip/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.html"/>
    <id>http://xingchuan.vip/网络安全.html</id>
    <published>2019-07-19T13:15:00.000Z</published>
    <updated>2019-07-19T05:53:54.847Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、黑客与安全"><a href="#一、黑客与安全" class="headerlink" title="一、黑客与安全"></a>一、黑客与安全</h3><h5 id="黑客："><a href="#黑客：" class="headerlink" title="黑客："></a>黑客：</h5><blockquote><ul><li>攻击手段分为非破坏性攻击和破坏性攻击。<blockquote><ul><li>非破坏型攻击：一般是为了扰乱系统的运行，使之暂时失去对外提供服务的能力，比如DDos攻击。</li><li>破坏性攻击：主要会造成两种后果:系统数据收送或者信息被窃取，比如CSRF攻击。</li></ul></blockquote></li><li>攻击手段有病毒式、洪水式、系统漏洞式。</li></ul></blockquote><h5 id="安全："><a href="#安全：" class="headerlink" title="安全："></a>安全：</h5><blockquote><ul><li>互联网企业都要建立一套完整的信息安全体系，遵循CIA原则，即保密性、完整性、可用性。<blockquote><ul><li>保密性：对需要保护的数据（例如用户的私人信息等）进行保密操作，无论是存储还是传输，都要保证用户数据及相关资源的安全。</li><li>完整性：访问的数据需要是完整的，而不是缺失或者篡改的，必然用户访问的数据就是不正确的。</li><li>可用性：服务必须是可用的。</li></ul></blockquote></li></ul></blockquote><hr><h3 id="二、SQL注入"><a href="#二、SQL注入" class="headerlink" title="二、SQL注入"></a>二、SQL注入</h3><blockquote><ul><li>SQL注入是注入式攻击中常见的类型，是未将代码与数据进行严格的隔离，导致在读取用户数据时候，错误的把数据作为代码的一部分执行，从而导致安全问题。</li></ul></blockquote><h5 id="常见案例："><a href="#常见案例：" class="headerlink" title="常见案例："></a>常见案例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var testCondition;</span><br><span class="line">testCondition = Request.from(&quot;testCondition&quot;)</span><br><span class="line">var sql = &quot;select * from TableA where id =&apos;&quot;+ testCondition +&quot;&apos;&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>上面例子，若果用户只输入ID是一个数字是没有问题的，但是如果用”;”隔开，在testCondition中插入其他SQL，则会带来意想不到的结果。</p></blockquote><h5 id="如何预防？"><a href="#如何预防？" class="headerlink" title="如何预防？"></a>如何预防？</h5><blockquote><ul><li>过滤用户输入参数中的特殊字符，从而降低被SQL注入的风险；</li><li>禁止通过字符串凭借的SQL语句，严格使用参数绑定传入的SQL参数；</li><li>合理使用数据库访问框架提供的防注入机制。例如Mybatis提供的#{} 绑定数据，从而防止SQL注入。同时谨慎使用${},${}相当于使用字符串拼接SQL，拒绝拼接的SQL语句，使用参数化的语句。</li></ul></blockquote><hr><h3 id="三、XSS与CSRF"><a href="#三、XSS与CSRF" class="headerlink" title="三、XSS与CSRF"></a>三、XSS与CSRF</h3><h5 id="XSS"><a href="#XSS" class="headerlink" title="XSS:"></a>XSS:</h5><blockquote><ul><li>跨站脚本攻击，指黑客通过技术手段，向正常用户请求的HTML页面中插入恶意的脚本，从而可以执行任意脚本,比如如下代码可能造成XSS漏洞</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h3&gt;反射型xss示例&lt;h3&gt;</span><br><span class="line">&lt;br&gt;用户：&lt;%= request.getParameter(&quot;userName&quot;) %&gt;</span><br><span class="line">&lt;br&gt;系统错误信息：&lt;%= request.getParameter(&quot;errorMessage&quot;) %&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码从HTTP请求中获取了userName和errorMessage两个参数，并直接输出到HTML中展示，当黑客构造如下的URL时出现了反射型XSS</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xss.demo/self-xss.jsp?userName= 张三&lt;script&gt;alert(&quot;张三&quot;)&lt;/script&gt;&amp;errorMessage=XSS示例&lt;script src=http://hacker.demo/xss-script.js /&gt;</span><br></pre></td></tr></table></figure><h6 id="防范措施："><a href="#防范措施：" class="headerlink" title="防范措施："></a>防范措施：</h6><blockquote><ul><li>使用Jsonp框架对用户输入字符串做XSS过滤；</li><li>使用框架的工具类对用户输入的字符串做HTML转义，例如Spring提供的HtmlUtils；</li><li>前端展示数据时使用innerText而不是innerHTML。</li></ul></blockquote><h5 id="CSRF："><a href="#CSRF：" class="headerlink" title="CSRF："></a>CSRF：</h5><blockquote><ul><li>跨站请求伪造，在用户不知情的情况下，冒用用户发起请求，在当前已经登录的Web应用上执行恶意操作，如恶意发帖，修改密码等。比如某用户A登录了网上银行，这时黑客给他发了一条连接如下：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https//net_bank.demo/transfer.do?targetAccount=12345&amp;amount=100</span><br></pre></td></tr></table></figure><blockquote><p>如果用户在打开网银的浏览器中点开了黑客发送的URL,那么就有可能给黑客转账100元。</p></blockquote><h6 id="防范措施：-1"><a href="#防范措施：-1" class="headerlink" title="防范措施："></a>防范措施：</h6><blockquote><ul><li>CSRF Token验证，利用浏览器的同源限制，在HTTP接口执行前验证页面或者Cookie中设置的Token，只有验证通过才能继续执行请求；</li><li>人机交互，比如在调用网上银行转账时校验短信验证码。</li></ul></blockquote><hr><h3 id="四、两者差别"><a href="#四、两者差别" class="headerlink" title="四、两者差别"></a>四、两者差别</h3><blockquote><ul><li>XSS是在正常用户请求的HTML页面中执行了黑客提供的恶意代码；CSRF是黑客直接盗用浏览器中的登录信息，冒充用户去执行黑客指定的操作。XSS问题出在用户数据没有过滤、转义；CSRF问题出现在HTTP接口没有防范不受信任的调用。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、黑客与安全&quot;&gt;&lt;a href=&quot;#一、黑客与安全&quot; class=&quot;headerlink&quot; title=&quot;一、黑客与安全&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="socket" scheme="http://xingchuan.vip/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>什么是TCP/IP</title>
    <link href="http://xingchuan.vip/TCP-IP.html"/>
    <id>http://xingchuan.vip/TCP-IP.html</id>
    <published>2019-07-19T09:44:00.000Z</published>
    <updated>2019-07-19T02:25:09.012Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --><h3 id="一、网络协议"><a href="#一、网络协议" class="headerlink" title="一、网络协议"></a>一、网络协议</h3><h5 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP :"></a>TCP/IP :</h5><blockquote><ul><li>中文翻译为传输控制协议，通常有4层协议：应用层、传输层、网络层、链路层。</li></ul></blockquote><h5 id="链路层："><a href="#链路层：" class="headerlink" title="链路层："></a>链路层：</h5><blockquote><ul><li>主要有IEEE 802.x/PPP 等，以字节为单位把0与1进行分组，定义数据帧，写入源和目标机器的物理地址、数据、校验位来传输数据。</li></ul></blockquote><h5 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h5><blockquote><ul><li>主要有IP/APR等，根据IP定义网络地址，区分网段。子网内根据地址解析协议（ARP）进行MAC寻址，子网外进行路由转发数据包，这个数据包即为IP数据包。</li></ul></blockquote><h5 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h5><blockquote><ul><li>主要有TPC/UDP等，数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份，把数据包交给应用程序，实现端口与端口间的通信。</li></ul></blockquote><h5 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h5><blockquote><ul><li>主要有HTTP/FTP/SMTP等，传输层的数据到达应用程序后，以某种统一规定的协议格式解读数据。</li></ul></blockquote><hr><h3 id="二、IP协议"><a href="#二、IP协议" class="headerlink" title="二、IP协议"></a>二、IP协议</h3><blockquote><ul><li>IP协议是面向无连接、无状态、没有额外的机制保证发送的包是否有序到达。</li><li>是TCP/IP的基石，几乎所有其他协议都是建立在IP所提供的服务基础上进行传输，其中包括在实际应用中用于传输稳定有序数据的TCP。</li></ul></blockquote><hr><h3 id="三、TPC建立链接"><a href="#三、TPC建立链接" class="headerlink" title="三、TPC建立链接"></a>三、TPC建立链接</h3><blockquote><ul><li>传输控制协议。是一种面向连接、确保数据在端与端之间可靠传输的协议。</li><li>三次握手:<blockquote><ul><li>A机器发出一个数据包并将SYN置1，表示希望建立连接；</li><li>B机器收到A机器发过来的数据包，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置为1。假设这个包中的序列号是y，而确认序列号必须是x+1，表示收到了A发过来的SYN，在TCP中，SYN被当做数据部分的一个字节；</li><li>A收到B的响应包后进行确认，确认包中将ACK置为1，并将确认序列号置为y+1，表示收到来自B的SYN。</li></ul></blockquote></li><li>目的： 信息对等，防止超时。</li></ul></blockquote><hr><h3 id="四、TCP断开连接"><a href="#四、TCP断开连接" class="headerlink" title="四、TCP断开连接"></a>四、TCP断开连接</h3><blockquote><ul><li>四次挥手：<blockquote><ul><li>A机器想要关闭连接，则待本方数据发送完毕之后，传递FIN信号给B机器；</li><li>B机器应答ACK，告诉A机器可以断开，但是要等B机器处理完数据，再主动给A机器发送FIN信号，此时A机器处于半关闭状态，无法发送新的数据；</li><li>B机器做好链接关闭的准备后，发送FIN信号给A机器，此时B机器也进入半关闭状态；</li><li>A机器发送针对B机器FIN的ACK后，进入TIME-WAIT状态，经过2MSL后，没有收到B发送的报文，则确定B机器已经收到A机器最后发送的ACK命令，此时TCP正式释放。</li></ul></blockquote></li></ul></blockquote><hr><h3 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a>五、常见问题</h3><h5 id="1-TCP和UDP区别？"><a href="#1-TCP和UDP区别？" class="headerlink" title="1. TCP和UDP区别？"></a>1. TCP和UDP区别？</h5><blockquote><ul><li>TCP:<blockquote><ul><li>面向连接</li><li>点到点通信</li><li>高可靠性</li><li>占用系统资源多、效率低</li><li>利用IO流实现数据的传输</li><li>响应式请求</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>UDP:<blockquote><ul><li>非面向连接，传输不可靠，可能丢失</li><li>发送不管对方是否准备好，接受到也不确认</li><li>可以广播发送</li><li>非常简单的协议，开销小</li><li>效率高，不用IO流实现数据的传输</li></ul></blockquote></li></ul></blockquote><h5 id="2-为什么连接的时候是三次握手，断开的时候是四次挥手？"><a href="#2-为什么连接的时候是三次握手，断开的时候是四次挥手？" class="headerlink" title="2. 为什么连接的时候是三次握手，断开的时候是四次挥手？"></a>2. 为什么连接的时候是三次握手，断开的时候是四次挥手？</h5><blockquote><ul><li>当服务端收到客户端的连接请求报文时，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的，但是关闭连接时候，当服务端收到FIN报文时，不会立刻关闭SOCKET，只能先回复一个ACK报文，告诉客户端你的FIN报文收到了，只有等我服务端所有的报文发送完，我才能发送FIN报文，因此不能一次发送，需要四步。</li></ul></blockquote><h5 id="3-为什么不用两次握手链接？"><a href="#3-为什么不用两次握手链接？" class="headerlink" title="3.为什么不用两次握手链接？"></a>3.为什么不用两次握手链接？</h5><blockquote><ul><li>容易发生死锁，客户端在服务端的应答分组在传输中被丢失的情况下，将不知道服务端是否准备好，不知道服务端建立什么样的序列号，在这种情况下，客户端认为链接还未建立，将忽略服务端发来的任何数据分组，只能等待链接确认才应答f分组，而服务端发出的分组超时后，重复发送同样的分组，这样就行成了死锁。</li></ul></blockquote><h5 id="4-为什么TIME-WAIT状态需要经过2MSL才能返回到Close状态？"><a href="#4-为什么TIME-WAIT状态需要经过2MSL才能返回到Close状态？" class="headerlink" title="4.为什么TIME-WAIT状态需要经过2MSL才能返回到Close状态？"></a>4.为什么TIME-WAIT状态需要经过2MSL才能返回到Close状态？</h5><blockquote><ul><li>按照道理来说，四个报文发送完毕，我们可以直接进入CLOSE状态，但是我们假象网络是不可靠的，有可能最后一个ACK丢失，所以TIME-WAIT状态是用来重发可能丢失的ACK报文。在客户端发送出最后的ACK回复，但该ACK可能丢失，服务端如果没有收到ACK，则不断的发送FIN片段，所以客户端不能立即关闭，它必须确认客户端收到了该ACK，此时设置了一个定时器，如果直到2MSL，客户端都没有收到FIN，则推断ACK已经成功被接收，关闭连接。</li></ul></blockquote><h5 id="5-如果已经建立了连接，但是客户端突然出现故障怎么办？"><a href="#5-如果已经建立了连接，但是客户端突然出现故障怎么办？" class="headerlink" title="5.如果已经建立了连接，但是客户端突然出现故障怎么办？"></a>5.如果已经建立了连接，但是客户端突然出现故障怎么办？</h5><blockquote><ul><li>TPC设有一个保活计时器，服务端每次接收到请求都会重新复位这个计时器，时间通常是2小时，若2小时没有收到客户端的任何数据，则服务端会发送一个探测报文段，以后每隔75秒发送一次，若一连发送10个探测报文都没有反应，则认为客户端发生故障，关闭连接。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Aug 02 2019 15:52:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、网络协议&quot;&gt;&lt;a href=&quot;#一、网络协议&quot; class=&quot;headerlink&quot; title=&quot;一、网络协议&quot;&gt;&lt;/a&gt;一、网
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="socket" scheme="http://xingchuan.vip/tags/socket/"/>
    
  </entry>
  
</feed>
