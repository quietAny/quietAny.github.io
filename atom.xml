<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>行川居</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xingchuan.vip/"/>
  <updated>2019-07-24T05:41:01.983Z</updated>
  <id>http://xingchuan.vip/</id>
  
  <author>
    <name>川总</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与集合(下)</title>
    <link href="http://xingchuan.vip/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88(%E4%B8%8B).html"/>
    <id>http://xingchuan.vip/数据结构与集合(下).html</id>
    <published>2019-07-24T13:01:00.000Z</published>
    <updated>2019-07-24T05:41:01.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --><h3 id="一、Map集合"><a href="#一、Map集合" class="headerlink" title="一、Map集合"></a>一、Map集合</h3><h5 id="Map类特点"><a href="#Map类特点" class="headerlink" title="Map类特点:"></a>Map类特点:</h5><blockquote><ul><li>Map类取代了旧的抽象对象Dictionary，拥有更好的性能。</li><li>没有重复的key，可以有重复的value。</li><li>Value可以是List、Set、Map类对象。<blockquote><ul><li>AbstractCollection只实现了remove、clear操作，没有修改和删除</li></ul></blockquote></li><li>KV是否允许有空值，以实现类约束为准。<blockquote><ul><li>HashMap允许KV都为空，ConcurrentHashMap不允许KV为空</li></ul></blockquote></li></ul></blockquote><hr><h3 id="二、-树"><a href="#二、-树" class="headerlink" title="二、 树"></a>二、 树</h3><blockquote><ul><li>常用的数据机构，它是一个由有限节点组成的一个具有层次关系的集合，数据就存在树的节点中。最顶层只有一个节点成为根节点。</li></ul></blockquote><h5 id="结构特点："><a href="#结构特点：" class="headerlink" title="结构特点："></a>结构特点：</h5><blockquote><ul><li>一个节点，既是只有根节点，也是一棵树。</li><li>其中任何一个节点与下面所有节点构成的树称为字数。</li><li>根节点没有父节点，而叶子节点没有子节点。</li><li>除根节点外，任何节点有且只有一个父节点。</li><li>任何节点可以有0~n个子节点。</li></ul></blockquote><h6 id="最多有两个节点的树称为二叉树，其中最重要的概念是平衡二叉树、二叉查找树、红黑树。"><a href="#最多有两个节点的树称为二叉树，其中最重要的概念是平衡二叉树、二叉查找树、红黑树。" class="headerlink" title="最多有两个节点的树称为二叉树，其中最重要的概念是平衡二叉树、二叉查找树、红黑树。"></a>最多有两个节点的树称为二叉树，其中最重要的概念是平衡二叉树、二叉查找树、红黑树。</h6><h4 id="1-平衡二叉树"><a href="#1-平衡二叉树" class="headerlink" title="1. 平衡二叉树"></a>1. 平衡二叉树</h4><p><img src="https://img-blog.csdn.net/20180829143433419?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1OTQwOTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p><h5 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h5><blockquote><ul><li>树的左右高度差不能超过1。</li><li>任何往下递归的左子树与右子树，必须符合第一条性质。</li><li>没有任何节点的空树或者只有根节点的树也是平衡二叉树。</li></ul></blockquote><h4 id="2-二叉查找树"><a href="#2-二叉查找树" class="headerlink" title="2. 二叉查找树"></a>2. 二叉查找树</h4><p><img src="https://img-blog.csdn.net/2018082914312743?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1OTQwOTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p><blockquote><ul><li>擅长数据查找，对树增加了额外的要求：对于任意节点来说，它的左子树所有节点的值都小于它，而它的右字数所有节点都必须大于它。</li><li>常见的遍历方式有三种：前序遍历、中序遍历、后续遍历。它们三者规律如下：<blockquote><ul><li>在任何递归子树中，左节点一定在右节点之前先遍历。<br>前序遍历的顺序是根节点、左节点、右节点；中序遍历的顺序是左节点、根节点、右节点；后序遍历的顺序是左节点、右节点、根节点。</li></ul></blockquote></li></ul></blockquote><h4 id="3-AVL树"><a href="#3-AVL树" class="headerlink" title="3. AVL树"></a>3. AVL树</h4><blockquote><ul><li>一种平衡二叉查找树，增加和删除节点通过树形旋转重新达到平衡。</li><li>左旋是以某个节点为中心，将它沉入当前左节点的位置，而让当前的右节点成为新树的根节点，也称为逆时针旋转。<br><img src="https://img-blog.csdn.net/20180829143451434?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1OTQwOTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></li><li>右旋是以某个节点为中心，将它沉入当前右子节点的位置，而让当前的左节点成为新树的根节点，也称为顺时针旋转。<br><img src="https://img-blog.csdn.net/20180829143509110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1OTQwOTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></li></ul></blockquote><h4 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4. 红黑树"></a>4. 红黑树</h4><h5 id="主要特征是在每个节点上增加一个属性来表示节点的颜色以是红色，也可以是黑色。"><a href="#主要特征是在每个节点上增加一个属性来表示节点的颜色以是红色，也可以是黑色。" class="headerlink" title="主要特征是在每个节点上增加一个属性来表示节点的颜色以是红色，也可以是黑色。"></a>主要特征是在每个节点上增加一个属性来表示节点的颜色以是红色，也可以是黑色。</h5><blockquote><ul><li>和AVL树类似，都是在进行插入和删除元素时，通过特定的旋转来保持自首平衡的，从而获得了较高的查找性能。和AVL树相比，红黑树并不追求所有递归子树的高度差不超过1.而是保证从根节点到叶子节点的最长路径不超过最短路径的2倍，通过重新着色和左右旋转，更加高效的完成了插入和删除操作后的自平衡调整。</li><li>5个约束条件：<blockquote><ul><li>节点只能是红色或黑色。</li><li>根节点必须是黑色。</li><li>所有NIL节点都是黑色的。NIL，即叶子节点下挂的两个虚节点。</li><li>一条路径上不能出现相邻的两个红色节点。</li><li>在任何递归子树内，根节点到叶子节点的所有路径上包含相同数目的黑色节点。</li></ul></blockquote></li></ul></blockquote><h6 id="总结一下：”有红必有黑，红红不相连”。如果一个树的左子节点或者右子节点不存在，则均认定为黑色。红黑树的任何旋转在3次只能均可完成。"><a href="#总结一下：”有红必有黑，红红不相连”。如果一个树的左子节点或者右子节点不存在，则均认定为黑色。红黑树的任何旋转在3次只能均可完成。" class="headerlink" title="总结一下：”有红必有黑，红红不相连”。如果一个树的左子节点或者右子节点不存在，则均认定为黑色。红黑树的任何旋转在3次只能均可完成。"></a>总结一下：”有红必有黑，红红不相连”。如果一个树的左子节点或者右子节点不存在，则均认定为黑色。红黑树的任何旋转在3次只能均可完成。</h6><h4 id="5-红黑树和AVL比较"><a href="#5-红黑树和AVL比较" class="headerlink" title="5. 红黑树和AVL比较:"></a>5. 红黑树和AVL比较:</h4><blockquote><ul><li>面对频繁插入和删除，红黑树更为合适；面对低频修改、大量查询，AVL树更为合适。</li></ul></blockquote><hr><h3 id="三、TreeMap"><a href="#三、TreeMap" class="headerlink" title="三、TreeMap"></a>三、TreeMap</h3><blockquote><ul><li>按照Key的排序结果来组织内部结构的Map类集合，它改变了Map类散乱无序的形象。虽然没有ConcurrentHashMap和HashMap普及，但是在Key有排序要求的情况下事半功倍。</li><li>在继承树中，有两个与众不同的接口：SortedMap和NavigableMap。SortedMap表示它的key是有序不可重复的，支持获得头尾的key-value元素。插入的Key必须实现Comparable接口，所以Key不允许为空，Value可以为空。NavigableMap继承SortedMap接口，根据指定的搜索条件返回最匹配的Key-Value元素。不同于HashMap，TreeMap并非一定要重写hashcode和equals方法来达到Key去重的目的。</li></ul></blockquote><h4 id="插入新节点，三个前提条件："><a href="#插入新节点，三个前提条件：" class="headerlink" title="插入新节点，三个前提条件："></a>插入新节点，三个前提条件：</h4><blockquote><ul><li>需要调整的新节点总是红色的。</li><li>如果插入新节点的父节点是黑色的，无需调整。</li><li>如果插入新节点的父节点是红色的，因为红黑树规定不能出现相邻的两个红色节点，所以进入循环判断，或重新着色，或左右旋转，最终达到红黑树的五个约束条件，退出条件如下：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(x != null &amp;&amp; x!= root &amp;&amp; x.parent.color == RED)&#123;...&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果是根节点，则直接退出，设置为黑色即可；如果不是根节点，并且父节点是红色，则一直调整，直到退出循环。</li><li>TreeMap的插入操作就是按照Key的对比往下遍历，大于比较值节点的往右走，小于比较值节点的往左走,先按照二叉查找树的特性进行操作，无需关心节点颜色与树的平衡，后续会重新着色旋转，保持红黑树的特性。</li></ul></blockquote><hr><h3 id="四、HashMap"><a href="#四、HashMap" class="headerlink" title="四、HashMap"></a>四、HashMap</h3><h4 id="三个存储概念："><a href="#三个存储概念：" class="headerlink" title="三个存储概念："></a>三个存储概念：</h4><table><thead><tr><th>名称</th><th align="right">说明</th></tr></thead><tbody><tr><td>table</td><td align="right">存储所有节点数据的数组</td></tr><tr><td>slot</td><td align="right">哈希槽。即table[i]这个位置</td></tr><tr><td>bucket</td><td align="right">哈希桶。table[i]上所有元素形成的表或数的集合</td></tr></tbody></table><blockquote><ul><li>除了局部方法或绝对线程安全情况下，优先推荐使用ConcurrentHashMap。两者性能相差无几，但后者解决了 高并发下线程安全的问题。HashMap的死链问题以及扩容数据丢失问题是慎用HashMap的两个主要原因。</li><li>默认容量16，默认负载因子0.75，当到达阈值(容量 * 负载因子)时，进行扩容。每次扩容容量为原来的两倍。</li></ul></blockquote><h4 id="发生hash冲突的情况："><a href="#发生hash冲突的情况：" class="headerlink" title="发生hash冲突的情况："></a>发生hash冲突的情况：</h4><blockquote><ul><li>两节点Key值相同(hash值一定相同)，导致冲突。</li><li>两节点Key值不同，但是由于hash函数的局限性导致了hash值相同，导致冲突。</li><li>两节点Key值不同，hash值也不同，但是hash值对 数组长度取模后相同，导致冲突。</li></ul></blockquote><h4 id="高并发中，新增对象丢失原因："><a href="#高并发中，新增对象丢失原因：" class="headerlink" title="高并发中，新增对象丢失原因："></a>高并发中，新增对象丢失原因：</h4><blockquote><ul><li>并发赋值时被覆盖。</li><li>已遍历区间新增元素会丢失。</li><li>“新表被覆盖”。</li><li>迁移丢失。在迁移过程中，有并发时，next被提前设置为null。</li></ul></blockquote><h4 id="JDK1-7和1-8中HashMap的区别："><a href="#JDK1-7和1-8中HashMap的区别：" class="headerlink" title="JDK1.7和1.8中HashMap的区别："></a>JDK1.7和1.8中HashMap的区别：</h4><blockquote><ul><li>JDK1.7中使用的是头插法，1.8中使用的是尾插法。因为JDK1.7中是用单链表进行的纵向延伸，采用头插法能够提高插入的效率，但是也会出现逆序且环形链表死循环的问题。在1.8之后加入了红黑树，采用尾插法，能够避免出现逆序且链表死循环的问题。</li><li>扩容后数据存储位置计算方式也不一样:<blockquote><ul><li>1.7直接使用hash值和需要扩容的二进制数进行&amp;(这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞)(hash值 &amp; length-1)。</li><li>1.8直接用了1.7的运算规律，扩容前位置 + 扩容大小值=JDK1.8的计算方式，只需要判断Hash值的新增参与运算的位是0还是1就直接迅速算出扩容后的存储方式。</li></ul></blockquote></li><li>JDK1.7是数组 + 单链表的数据结构，1.8之后，使用的是数组 + 链表 + 红黑树的数据结构(当链表的深度到达8时，就会自动扩容把链表转换成红黑树的数据结构来把时间复杂度从O(N)变成O(LogN)提高了效率；当阈值小于6时，红黑树转换成链表)。</li></ul></blockquote><h4 id="为什么HashMap是线程不安全的？"><a href="#为什么HashMap是线程不安全的？" class="headerlink" title="为什么HashMap是线程不安全的？"></a>为什么HashMap是线程不安全的？</h4><h6 id="HashMap在并发时出现的问题主要是两方面："><a href="#HashMap在并发时出现的问题主要是两方面：" class="headerlink" title="HashMap在并发时出现的问题主要是两方面："></a>HashMap在并发时出现的问题主要是两方面：</h6><blockquote><ul><li>put的时候导致的多线程数据不一致<blockquote><ul><li>两个线程A和B，A先插入key-value到HashMap中，计算出hash桶的索引坐标，获得该桶的链表头节结点，A执行完后B开始执行插入，假设A计算出来的hash桶索引和B计算出的hash桶索引一样，在B插入后，A再次被调度时，执行了旧数据，覆盖了B的插入记录，这样线程B插入的数据就消失了，从而造成数据不一致。</li></ul></blockquote></li><li>resize而引起死循环<blockquote><ul><li>当两个线程同时检测到元素个数超过了数组大小 x 负载因子，同时会在put()方法中调用resize(),两个线程同时修改一个链表结构会产生一个循环列表(JDK1.7中，会出现resize前后元素顺序倒置的情况)。接下来再想通过get()获取一个元素，就会出现死循环。</li></ul></blockquote></li></ul></blockquote><hr><h3 id="五、ConcurrentHashMap"><a href="#五、ConcurrentHashMap" class="headerlink" title="五、ConcurrentHashMap"></a>五、ConcurrentHashMap</h3><h4 id="高并发下其他哈希式集合："><a href="#高并发下其他哈希式集合：" class="headerlink" title="高并发下其他哈希式集合："></a>高并发下其他哈希式集合：</h4><blockquote><ul><li>HashTable是JDK1.0引入的集合，以全互斥的方式处理并发情况，性能极差。</li><li>HashMap是JDK1.2引入的，非线程安全，最大的问题是在并发写的情况下，容易出现死链，导致服务不可用。</li><li>ConcurrentHashMap是JDK1.5引入的线程安全的哈希式集合。</li></ul></blockquote><h4 id="ConcurrentHashMap设计理念；"><a href="#ConcurrentHashMap设计理念；" class="headerlink" title="ConcurrentHashMap设计理念；"></a>ConcurrentHashMap设计理念；</h4><blockquote><ul><li>JDK1.8之前：采用分段锁的设计理念，相当于HashTable和HashMap的折中版本，把数据分成一段一段进行存储，给每一段分配一把锁，当线程占用锁访问其中一个数据时候，其他端的数据也能被其他线程方法，实现真正的并发访问。<blockquote><ul><li>优点：写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，并发能力大大提高。</li><li>缺点：Hash过程要比普通的HashMap要长。</li></ul></blockquote></li><li>JDK1.8之后：参考了HashMap，采用了数组 + 链表 + 红黑树的实现方式来设计，内部大量的采用了CAS操作，彻底放弃了Segment转而采用的是Node。</li></ul></blockquote><hr><h4 id="更多知识点会在后面专题介绍，尽情期待。"><a href="#更多知识点会在后面专题介绍，尽情期待。" class="headerlink" title="更多知识点会在后面专题介绍，尽情期待。"></a>更多知识点会在后面专题介绍，尽情期待。</h4><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、Map集合&quot;&gt;&lt;a href=&quot;#一、Map集合&quot; class=&quot;headerlink&quot; title=&quot;一、Map集合&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="集合" scheme="http://xingchuan.vip/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与集合(上)</title>
    <link href="http://xingchuan.vip/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88(%E4%B8%8A).html"/>
    <id>http://xingchuan.vip/数据结构与集合(上).html</id>
    <published>2019-07-23T13:01:00.000Z</published>
    <updated>2019-07-24T05:40:20.250Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --><h3 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><ul><li>指逻辑意义上数据组织方式及其相应的处理方式</li><li>数据结构=逻辑结构+存储结构+（在存储结构上的）运算/操作</li><li>数据结构是指相互之间存在一种或者多种特定关系的数据元素的集合。<br>是组织并存储数据以便能够有效使用的一种专门格式，它用来反映一个数据的内部构成，即同一个数据由那些成分数据构成，以什么方式构成，是什么结构。</li></ul></blockquote><h4 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h4><p>数据的逻辑结构指数据元素之间的逻辑关系（和实现无关）</p><blockquote><ul><li>分类1：线性结构和非线性结构<blockquote><ul><li>线性结构<br>有且只有一个开始结点和一个终端结点，并且所有的结点都最多只有一个直接前驱和一个直接后驱。<blockquote><ul><li>线性表就是一个典型的线性结构，它有四个基本特征：</li><li>集合中必存在唯一的一个“第一元素”；</li><li>集合中必存在唯一的一个“最后的元素”；</li><li>除最后元素外，其他数据元素均有唯一的“后继”；</li><li>除第一元素外，其他数据元素均有唯一的“前驱”。</li></ul></blockquote></li><li>非线性结构：<br>一个结点元素可能对应多个直接前驱和多个直接后驱。<br>常见的有二叉树，图等。</li></ul></blockquote></li><li>分类2：集合结构、线性结构、树状结构、网状结构<blockquote><ul><li>集合结构<br>该结构的数据元素之间的关系是“同属于一个集合“，别无其他关系<br>三个特征：<blockquote><ul><li>确定性（集合中的元素必须是确定的）</li><li>唯一性（集合中的元素互不相同）、</li><li>无序性（集合中的元素没有前后之分）</li></ul></blockquote></li><li>线性结构<blockquote><ul><li>数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构</li></ul></blockquote></li><li>树状结构<blockquote><ul><li>除了一个元素外，每一个数据元素有且只有一个直接前驱元素，但是可以有多个直接的后续元素，特点是数据元素之间是一对多。</li></ul></blockquote></li><li>网状结构<blockquote><ul><li>每个数据元素之间都可以有多个直接前驱元素，也可以有多个直接后继元素，特点是数据元素之间是多对多的关系。</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><h4 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h4><blockquote><blockquote><blockquote><ul><li>数据的存储结构主要包括数据元素本身的存储结构以及数据元素之间关系表示，是数据的逻辑结构在计算机中的表示。<br>分类：顺序储存、链式储存、索引储存以及散列储存</li><li>顺序存储结构</li><li>把逻辑上相邻的节点存储在物理位置上相邻的存储单元，结点之间的逻辑关系由存储单元的邻接关系来体现</li><li>优点：是节省存储空间，因为分配给数据的存储单元全用存放结点的数据，结点之间没有占用额外的存储空间。</li><li>采用这种方法时，可实现对结点的随机存取，即每一个结点对应一个序号，由该序号可以直接计算出来结点的存储地址。</li><li>缺点：插入和删除需要移动元素，效率较低。</li><li>链式储存结构</li><li>数据元素的存储空间对应的不连续的存储空间，每个存储空间节点对应一个需要存储的元素。<br>每个结点是由数据域和指针域组成。元素之间的逻辑关系通过存储节点之间的链接关系反映出来。</li><li>特点：<blockquote><ul><li>比顺序存储结构的存储密度要小；</li><li>逻辑上相邻的节点物理上不必相邻；</li><li>插入、删除灵活，不需要改变位置，只需要改变指针中的地址；</li><li>查找结点是链式存储要比顺序存储慢。</li></ul></blockquote></li><li>索引储存结构</li><li>除了建立存储结点信息外，还建立附加的索引来标识结点的位置</li><li>散列存储结构</li><li>根据结点的关键字直接计算出该结点的存储地址</li></ul></blockquote></blockquote></blockquote><h2 id="一种神奇的存储结构，添加，查询速度快。"><a href="#一种神奇的存储结构，添加，查询速度快。" class="headerlink" title="一种神奇的存储结构，添加，查询速度快。"></a>一种神奇的存储结构，添加，查询速度快。</h2><h3 id="二、集合"><a href="#二、集合" class="headerlink" title="二、集合"></a>二、集合</h3><h5 id="常见有Set-Queue，List，Map接口，全部继承Collection接口。"><a href="#常见有Set-Queue，List，Map接口，全部继承Collection接口。" class="headerlink" title="常见有Set,Queue，List，Map接口，全部继承Collection接口。"></a>常见有Set,Queue，List，Map接口，全部继承Collection接口。</h5><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><blockquote><ul><li>线性数据结构的主要表现，通常存在明确的上一个和下一个元素，也UC你在明确的第一个元素和最后一个元素。常见的又ArrayList和LinkedList两个集合类。<blockquote><ul><li>ArrayList：容量可以改变的非线程安全集合。内部使用数组存储，集合扩容时会创建更大的数组空间，把原有的数组复制到新数组中。<blockquote><ul><li>优点：能够快速的随机访问</li><li>缺点: 插入和删除时候速度很慢，需要移动元素。</li></ul></blockquote></li><li>LinkedList:本质是双向链表，和ArrayList相比，插入和删除速度更快，但是随机访问速度慢。这个接口同时有队列和栈的性质，包含3个重要成员：size、first、size。size是双向链表中节点的个数。first和last分别指向第一个和最后 一个节点。<blockquote><ul><li>优点：可以将零散的内存单元通过附加引用的方式关联起来，形成按链路顺序查找的线性结构，内存利用率较高。</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><h4 id="Queue集合"><a href="#Queue集合" class="headerlink" title="Queue集合"></a>Queue集合</h4><blockquote><ul><li>一种先入先出的数据结构。队列是一种特殊的线性表，它只允许在表的一端进行获取操作，另一端进行插入操作。当队列为空时，称为空队列。由于其本身FIFO的特性和阻塞操作的特点，常常被作为Buffer(数据缓冲区)使用。</li></ul></blockquote><h4 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h4><blockquote><ul><li>以Key-Value键值作为存储元素实现的哈希结构，Key唯一，value可以重复。最早用于存储键值对的Hashtable因为性能瓶颈已经被淘汰，HashMap线程不安全，ConcurrentHashMap是线程安全的，在多线程中，优先使用ConcurrentHashMap。TreeMap是Key有序的Map类集合。</li></ul></blockquote><h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h4><blockquote><ul><li>不允许出现重复元素的集合类型。最常用的有HashSet、TreeSet和LinkedHashSet。HashSet是使用HashMap来实现的，只是value固定为一个静态对象，使用Key保证集合元素的唯一性，但是它不能保证集合元素的顺序。TreeSet是使用TreeMap来实现的，底层作为树结构，在添加新元素到集合中时，按照某种比较规则将其插入合适的位置，保证插入后的集合仍然有序。LinkedHashSet继承自HashSet，具有HashSet的优点，内部使用链表维护元素插入的顺序。</li></ul></blockquote><hr><h3 id="三、集合初始化"><a href="#三、集合初始化" class="headerlink" title="三、集合初始化"></a>三、集合初始化</h3><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><blockquote><ul><li>如果原始容量13，当添加一个元素时，根据程序中的计算方法，得出113的二进制数右移以为后得到的二进制数110，即十进制数6，最终扩容的大小计算结果为：oledCapacitiy + (oldCapacitiy&gt;&gt;1)=13 + 6 = 19。</li><li>当使用无参数的构造方法时，默认大小为10，也就说第一次add的时候，分配10的容量，每次都调用Array.copyOf方法。当需要把1000个元素放入集合时候，如果我们没有定义容量，将会产生被动扩容和数组复制的额外开销，甚至有可能导致OOM的风险。</li></ul></blockquote><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><blockquote><ul><li>默认容量16，负载因子0.75，基于两数乘积来决定什么时候扩容，第一次扩容按着这个2的幂初始化数组大小，以后每次扩容都是2倍，若没有指定初始值，则为9.96。</li></ul></blockquote><hr><h3 id="四、数组与集合"><a href="#四、数组与集合" class="headerlink" title="四、数组与集合"></a>四、数组与集合</h3><h4 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h4><blockquote><ul><li>注意是否使用了视图方式直接返回数组中的数据。我们以Arrays.asList()为例，它把数组转换成集合时，不能使用其修改集合的相关方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String[] strings = new String[3];</span><br><span class="line">    strings[0] = &quot;one&quot;;</span><br><span class="line">    strings[1] = &quot;two&quot;;</span><br><span class="line">    strings[2] = &quot;three&quot;;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; stringList = Arrays.asList(strings);</span><br><span class="line">    //修改转换后的集合，成功的把第一个元素&quot;one&quot;变&quot;oneList&quot;</span><br><span class="line">    stringList.set(0,&quot;oneList&quot;);</span><br><span class="line">    System.out.println(strings[0]);</span><br><span class="line"></span><br><span class="line">    //以下三个方法编译正确，为什么会抛出运行时异常</span><br><span class="line">    stringList.add(&quot;four&quot;);</span><br><span class="line">    stringList.remove(2);</span><br><span class="line">    stringList.clear();</span><br><span class="line">    //因为asList返回的对象是一个Arrays内部类，并不是真正的ArrayList。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="正确使用："><a href="#正确使用：" class="headerlink" title="正确使用："></a>正确使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//正确使用</span><br><span class="line"> List&lt;String&gt; stringList1 = new ArrayList&lt;&gt;(Arrays.asList(strings));</span><br><span class="line"> stringList1.add(&quot;four&quot;);</span><br><span class="line"> stringList1.remove(2);</span><br><span class="line"> stringList1.clear();</span><br></pre></td></tr></table></figure><h4 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;(3);</span><br><span class="line">    list.add(&quot;one&quot;);</span><br><span class="line">    list.add(&quot;two&quot;);</span><br><span class="line">    list.add(&quot;three&quot;);</span><br><span class="line"></span><br><span class="line">    //泛型丢失，无法使用String[]接收返回的结果</span><br><span class="line">    Object[] array1 = list.toArray();</span><br><span class="line"></span><br><span class="line">    //数组长度小于元素长度</span><br><span class="line">    String[] array2 = new String[2];</span><br><span class="line">    list.toArray(array2);</span><br><span class="line">    System.out.println(Arrays.asList(array2));</span><br><span class="line"></span><br><span class="line">    //数组长度等于正确长度</span><br><span class="line">    String[] array3 = new String[3];</span><br><span class="line">    list.toArray(array3);</span><br><span class="line">    System.out.println(Arrays.asList(array3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>当数组容量等于集合大小时 运行总是最快的，空间消耗也是最少的。由此证明，如果数组初始大小设 不当，不仅会降低性能，还会浪费空间。使用集合的toArray(T[] array) 方法，转换为数组时 注意需要传入类型完全一样的数组并且它的容量大小为list.size();</li></ul></blockquote><hr><h3 id="五、集合与泛型"><a href="#五、集合与泛型" class="headerlink" title="五、集合与泛型"></a>五、集合与泛型</h3><h4 id="List、List、List-lt-gt-的区别？"><a href="#List、List、List-lt-gt-的区别？" class="headerlink" title="List、List、List&lt;?&gt;的区别？"></a>List、List<object>、List&lt;?&gt;的区别？</object></h4><blockquote><ul><li>List完全没有类型限制和赋值限定，如果天马行空的乱用，迟早会遭遇类型转换错误；List<object>在接收其他泛型赋值时会编译报错;List&lt;?&gt;是一个泛型，在没有赋值之前可以接收任何类型的集合赋值，赋值之后就不能随便添加了。</object></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //第一段：泛型出现之前的集合定义方式</span><br><span class="line">        List a1 = new ArrayList();</span><br><span class="line">        a1.add(new Object());</span><br><span class="line">        a1.add(new Integer(111));</span><br><span class="line">        a1.add(new String(&quot;hello a1a1&quot;));</span><br><span class="line"></span><br><span class="line">        //第二段：把a1引用赋值给a2，注意a2和a1的区别是增加了泛型限制&lt;Object&gt;</span><br><span class="line">        List&lt;Object&gt; a2 = a1;</span><br><span class="line">        a2.add(new Object());</span><br><span class="line">        a2.add(new Integer(222));</span><br><span class="line">        a2.add(new String(&quot;hello a2a2&quot;));</span><br><span class="line"></span><br><span class="line">        //第三段：把a1引用赋值给a3，注意a3和a1的区别就是增加了泛型&lt;Integer&gt;</span><br><span class="line">        List&lt;Integer&gt; a3 = a1; </span><br><span class="line">        a3.add(new Integer(333));</span><br><span class="line">        //下面两行出错，不允许加入非Integer的元素加入集合</span><br><span class="line">        a3.add(new Object());</span><br><span class="line">        a3.add(new String(&quot;hello a3a3&quot;));</span><br><span class="line"></span><br><span class="line">        //第四段：把a1引用赋值给a4，a1与a4的区别是增加了通配符</span><br><span class="line">        List&lt;?&gt; a4 = a1;</span><br><span class="line">        //运行删除和清楚元素</span><br><span class="line">        a1.remove(0);</span><br><span class="line">        a4.clear();</span><br><span class="line">        //编译出错，不允许增加任何元素</span><br><span class="line">        a4.add(new Object());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="lt-extends-T-gt-与-lt-super-T-gt-的区别？"><a href="#lt-extends-T-gt-与-lt-super-T-gt-的区别？" class="headerlink" title="&lt;? extends T&gt;与&lt;? super T&gt;的区别？"></a>&lt;? extends T&gt;与&lt;? super T&gt;的区别？</h4><blockquote><ul><li>&lt;? extends T&gt;是Get First，适用于消费集合元素的场景，称为上界通配符，可以赋值给任何T或者T的子类的集合，上界为T，取出来的类型带有泛型限制，向上转型为T。</li><li>&lt;? super T&gt;可以赋值给任何T及T父类的集合，下界为T，称为下界通配符。例如选举代表时，你只能往里投票，取票时，根本不知道谁的票，相当于泛型丢失。</li><li>extends的场景是put功能受限，而super的场景是get功能受限。</li></ul></blockquote><hr><h3 id="六、元素比较"><a href="#六、元素比较" class="headerlink" title="六、元素比较"></a>六、元素比较</h3><h4 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h4><h5 id="原理图："><a href="#原理图：" class="headerlink" title="原理图："></a>原理图：</h5><p><img src="https://images2017.cnblogs.com/blog/1216886/201710/1216886-20171016205125521-1228601863.jpg" alt="avatar"></p><h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//两路归并算法，两个排好序的子序列合并为一个子序列</span><br><span class="line">    public void merge(int []a,int left,int mid,int right)&#123;</span><br><span class="line">        int []tmp=new int[a.length];//辅助数组</span><br><span class="line">        int p1=left,p2=mid+1,k=left;//p1、p2是检测指针，k是存放指针</span><br><span class="line"></span><br><span class="line">        while(p1&lt;=mid &amp;&amp; p2&lt;=right)&#123;</span><br><span class="line">            if(a[p1]&lt;=a[p2])</span><br><span class="line">                tmp[k++]=a[p1++];</span><br><span class="line">            else</span><br><span class="line">                tmp[k++]=a[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(p1&lt;=mid) tmp[k++]=a[p1++];//如果第一个序列未检测完，直接将后面所有元素加到合并的序列中</span><br><span class="line">        while(p2&lt;=right) tmp[k++]=a[p2++];//同上</span><br><span class="line"></span><br><span class="line">        //复制回原素组</span><br><span class="line">        for (int i = left; i &lt;=right; i++)</span><br><span class="line">            a[i]=tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void mergeSort(int [] a,int start,int end)&#123;</span><br><span class="line">        if(start&lt;end)&#123;//当子序列中只有一个元素时结束递归</span><br><span class="line">            int mid=(start+end)/2;//划分子序列</span><br><span class="line">            mergeSort(a, start, mid);//对左侧子序列进行递归排序</span><br><span class="line">            mergeSort(a, mid+1, end);//对右侧子序列进行递归排序</span><br><span class="line">            merge(a, start, mid, end);//合并</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        int[] a = &#123; 49, 38, 65, 97, 76, 13, 27, 50 &#125;;</span><br><span class="line">        mergeSort(a, 0, a.length-1);</span><br><span class="line">        System.out.println(&quot;排好序的数组：&quot;);</span><br><span class="line">        for (int e : a)</span><br><span class="line">            System.out.print(e+&quot; &quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h4><h5 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] arr = &#123;1,4,6,8,2,5,3,7,9&#125;;</span><br><span class="line">    System.out.println(&quot;数组排序前顺序&quot;);</span><br><span class="line">    for (int a : arr) &#123;</span><br><span class="line">        System.out.print(a + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    insertSort(arr);</span><br><span class="line">    System.out.println(&quot;\n数组排序后的顺序&quot;);</span><br><span class="line">    for (int a : arr) &#123;</span><br><span class="line">        System.out.print(a + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 直接插入排序</span><br><span class="line"> * @param arr</span><br><span class="line"> */</span><br><span class="line">private static void insertSort(int[] arr)&#123;</span><br><span class="line">    for (int i = 1; i &lt; arr.length; i++) &#123; //必须i = 1，因为开始从第二个数与第一个数进行比较</span><br><span class="line">        int temp = arr[i]; //待比较值</span><br><span class="line">        int j = i - 1;</span><br><span class="line">        //内存循环为待比较值确定其最终位置</span><br><span class="line">        for (;j &gt;= 0 &amp;&amp; arr[j] &gt; temp;j--)&#123;//如果待比较值比前一位值小，应该往前插一位</span><br><span class="line">            //将大于temp的值整体后移一位</span><br><span class="line">            arr[j+1] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+1] = temp;//待比较值值比前一位值大，确定最终位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TimSort："><a href="#TimSort：" class="headerlink" title="TimSort："></a>TimSort：</h4><h5 id="结合归并排序和插入排序的优点，相对于传统归并排序，减少了并归次数，相对于插入排序，引入了二分排序概念，提升排序效率。它主要有两个优化："><a href="#结合归并排序和插入排序的优点，相对于传统归并排序，减少了并归次数，相对于插入排序，引入了二分排序概念，提升排序效率。它主要有两个优化：" class="headerlink" title="结合归并排序和插入排序的优点，相对于传统归并排序，减少了并归次数，相对于插入排序，引入了二分排序概念，提升排序效率。它主要有两个优化："></a>结合归并排序和插入排序的优点，相对于传统归并排序，减少了并归次数，相对于插入排序，引入了二分排序概念，提升排序效率。它主要有两个优化：</h5><blockquote><ul><li>归并排序的分段不再从单个元素开始，而是每次先查找当前最大的排序好的组数片段run，然后对run进行拓展并进利用二分排序，之后将该run与其他已经排好的run进行归并，产生排好序的大run。</li><li>引入二分排序，即binarySort。二分排序是对插入排序的优化，在排序中不再是从后往前逐个排序，而是引入了二分查找的思想，将一次查找新元素合适位置的时间复杂度从<br>O(n)降低到O(logn)。</li></ul></blockquote><h4 id="hashCode和equals"><a href="#hashCode和equals" class="headerlink" title="hashCode和equals"></a>hashCode和equals</h4><h5 id="用来标识对象。两个方法协同工作可以用来判断对象是否相等。对象通过Object-hashCode-生成哈希值，由于不可避免地存在哈希值冲突的情况，因此当hashCode相同时，还需要再调用equals进行一次值的比较。如果hashCode不同，直接返回Obejcts不同，跳过equals，加快冲突处理效率，Object定义要求如下："><a href="#用来标识对象。两个方法协同工作可以用来判断对象是否相等。对象通过Object-hashCode-生成哈希值，由于不可避免地存在哈希值冲突的情况，因此当hashCode相同时，还需要再调用equals进行一次值的比较。如果hashCode不同，直接返回Obejcts不同，跳过equals，加快冲突处理效率，Object定义要求如下：" class="headerlink" title="用来标识对象。两个方法协同工作可以用来判断对象是否相等。对象通过Object.hashCode()生成哈希值，由于不可避免地存在哈希值冲突的情况，因此当hashCode相同时，还需要再调用equals进行一次值的比较。如果hashCode不同，直接返回Obejcts不同，跳过equals，加快冲突处理效率，Object定义要求如下："></a>用来标识对象。两个方法协同工作可以用来判断对象是否相等。对象通过Object.hashCode()生成哈希值，由于不可避免地存在哈希值冲突的情况，因此当hashCode相同时，还需要再调用equals进行一次值的比较。如果hashCode不同，直接返回Obejcts不同，跳过equals，加快冲突处理效率，Object定义要求如下：</h5><blockquote><ul><li>如果两个对象的equals值相等，则两个对象的hashCode的返回结果也一定相等。</li><li>任何时候重写equals，都必须要重写hashCode。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Client(int id, String name) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        Client client = (Client) o;</span><br><span class="line">        return id == client.id &amp;&amp;</span><br><span class="line">                Objects.equals(name, client.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return Objects.hash(id, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;Client&gt; hashSet = new HashSet&lt;&gt;();</span><br><span class="line">        Client a = new Client(1,&quot;one&quot;);</span><br><span class="line">        Client b = new Client(1,&quot;one&quot;);</span><br><span class="line">        Client c = new Client(1,&quot;one&quot;);</span><br><span class="line">        hashSet.add(a);</span><br><span class="line">        hashSet.add(b);</span><br><span class="line">        hashSet.add(c);</span><br><span class="line">        System.out.println(hashSet.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、fail-fast机制"><a href="#七、fail-fast机制" class="headerlink" title="七、fail-fast机制"></a>七、fail-fast机制</h3><blockquote><ul><li>集合常见的错误检查机制，通常出现在遍历集合元素的过程中。在遍历途中出现意料之外的修改时，通过unchecked异常暴力反馈出来，这种机制常常出现在多线程环境下，当前线程会维护一个计数比较器，即expectedModCount，记录已经修改的次数。在进入遍历前，会把实时修改次数modCount赋值给expectedModCount，如果两个数据不相等，则抛出异常。java.util下所有的集合包都是fail-fast。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        List masterList = new ArrayList();</span><br><span class="line">        masterList.add(&quot;one&quot;);</span><br><span class="line">        masterList.add(&quot;two&quot;);</span><br><span class="line">        masterList.add(&quot;three&quot;);</span><br><span class="line">        masterList.add(&quot;four&quot;);</span><br><span class="line">        masterList.add(&quot;five&quot;);</span><br><span class="line"></span><br><span class="line">        List branchList = masterList.subList(0,3);</span><br><span class="line"></span><br><span class="line">        //下面三行代码如果不注释掉，会导致branchList操作出现异常</span><br><span class="line">        masterList.remove(0);</span><br><span class="line">        masterList.add(&quot;ten&quot;);</span><br><span class="line">        masterList.clear();</span><br><span class="line"></span><br><span class="line">        //下面四行全部能执行</span><br><span class="line">        branchList.clear();</span><br><span class="line">        branchList.add(&quot;sex&quot;);</span><br><span class="line">        branchList.add(&quot;seven&quot;);</span><br><span class="line">        branchList.remove(0);</span><br><span class="line"></span><br><span class="line">        //正常遍历，只有一个元素：seven</span><br><span class="line">        for (Object o: branchList) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //子列表修改导致主列表页被改动，输出：seven，four，five</span><br><span class="line">        System.out.println(masterList);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>concurrent包中所有的集合类都是fail-safe，是在安全的副本上进行遍历，集合修改与副本遍历没有任何关系，但是缺点很明显，就是读取不到最新的数据。</li></ul></blockquote><h5 id="Copy-On-Write"><a href="#Copy-On-Write" class="headerlink" title="Copy-On-Write"></a>Copy-On-Write</h5><blockquote><ul><li>它是并发的一种新思路，实行读写分离，如果是写操作，则复制一个新集合，在新集合内添加或删除元素。待一切修改完成后，再将原集合的引用指向新的集合，这样做的好处是可以高并发地对COW进行读和遍历操作，而不需要加锁，因为当前集合不会添加任何元素。</li><li>使用COW时应该注意两点：<blockquote><ul><li>尽量设置合理的容量初始值，它扩容的代价比较大</li><li>使用批量添加或者删除方法，如addAll或removeAll操作，在高并发请求下，可以攒一下要添加或者删除的元素，避免增加一个元素复制整个集合。如果集合数据是100MB，再写入50MB，那么某个时间段内占用的内存就达到了（100MB x 2) + 50MB = 250MB,内存大量占用会导致GC的频繁发生，从而降低服务器性能。</li></ul></blockquote></li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、数据结构&quot;&gt;&lt;a href=&quot;#一、数据结构&quot; class=&quot;headerlink&quot; title=&quot;一、数据结构&quot;&gt;&lt;/a&gt;一、数
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="集合" scheme="http://xingchuan.vip/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>异常和日志</title>
    <link href="http://xingchuan.vip/%E5%BC%82%E5%B8%B8%E5%92%8C%E6%97%A5%E5%BF%97.html"/>
    <id>http://xingchuan.vip/异常和日志.html</id>
    <published>2019-07-22T12:55:00.000Z</published>
    <updated>2019-07-22T05:36:51.648Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --><h3 id="一、异常分类"><a href="#一、异常分类" class="headerlink" title="一、异常分类"></a>一、异常分类</h3><h6 id="JDK中定义了一套完整的异常机制，所有异常都是Throwable的子类，主要有分类如下："><a href="#JDK中定义了一套完整的异常机制，所有异常都是Throwable的子类，主要有分类如下：" class="headerlink" title="JDK中定义了一套完整的异常机制，所有异常都是Throwable的子类，主要有分类如下："></a>JDK中定义了一套完整的异常机制，所有异常都是Throwable的子类，主要有分类如下：</h6><h5 id="Error-致命异常"><a href="#Error-致命异常" class="headerlink" title="Error(致命异常)"></a>Error(致命异常)</h5><blockquote><ul><li>一种非常特殊的异常，它的出现标识着系统发生了不可控制的错误，例如StackOverflowErro、OutOfMemoryErro。针对这种错误，程序无法处理，只能人工介入。</li></ul></blockquote><h5 id="Exception-非致命异常"><a href="#Exception-非致命异常" class="headerlink" title="Exception(非致命异常)"></a>Exception(非致命异常)</h5><blockquote><ul><li>checked异常(受检异常)<blockquote><ul><li>需要在代码中显示处理的异常，否则会编译出错。如果能自行处理可以在当前方法中捕获异常，如果无法处理，则继续向调用方法抛出异常，常见的异常主要有SQLException、ClassNotFoundException等。</li></ul></blockquote></li><li>unchecked异常(运行时异常)，他们都继承自RuntimeException，不需要程序进行显式的捕捉和处理。进一步可细分3类：<blockquote><ul><li>可预测异常,常见的包括IndexOutOfBoundsException，NullPointerException等，基于代码性能和稳定性要求，应该做出提前边界检查，空指针判断等处理。</li><li>需捕获异常,例如在使用Dubbo框架进行RPC调用时产生的远程服务器超时异常DubboTimeoutException，此类异常客户端必须显示处理，可以是重试或者降级处理。</li><li>可透出异常，主要是框架或系统产生会自行处理的异常，程序无需关系，比如调转404页面。</li></ul></blockquote></li></ul></blockquote><hr><h3 id="二、异常处理"><a href="#二、异常处理" class="headerlink" title="二、异常处理"></a>二、异常处理</h3><h5 id="try代码块，例："><a href="#try代码块，例：" class="headerlink" title="try代码块，例："></a>try代码块，例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pub ic static int finallyNotWork () &#123; </span><br><span class="line">int temp = 10000 ; </span><br><span class="line">try &#123; </span><br><span class="line">throw new Excepti on (); </span><br><span class="line">&#125; catch (Exception e ) &#123; </span><br><span class="line">return ++temp ;</span><br><span class="line">&#125; finally&#123;</span><br><span class="line">  temp = 99999；  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="如果没有进入进入finally代码块执行，那么有三种可能："><a href="#如果没有进入进入finally代码块执行，那么有三种可能：" class="headerlink" title="如果没有进入进入finally代码块执行，那么有三种可能："></a>如果没有进入进入finally代码块执行，那么有三种可能：</h6><blockquote><ul><li>没有进入try代码块。</li><li>进入try代码块，但是出现了死循环或者死锁。</li><li>进入try代码块，但是执行了System.exit()操作。</li></ul></blockquote><h6 id="注意：finally是在return表达式运行后执行的，此时将要return的结果暂时被保存起来，待finally代码块执行结束后再将之前保存的结果返回，切勿在finally中执行赋值操作。"><a href="#注意：finally是在return表达式运行后执行的，此时将要return的结果暂时被保存起来，待finally代码块执行结束后再将之前保存的结果返回，切勿在finally中执行赋值操作。" class="headerlink" title="注意：finally是在return表达式运行后执行的，此时将要return的结果暂时被保存起来，待finally代码块执行结束后再将之前保存的结果返回，切勿在finally中执行赋值操作。"></a>注意：finally是在return表达式运行后执行的，此时将要return的结果暂时被保存起来，待finally代码块执行结束后再将之前保存的结果返回，切勿在finally中执行赋值操作。</h6><h5 id="自定义异常，继承Exception或者是RuntimeException，在业务中使用throw-new-XxxException（“xxx错误”）来使用。"><a href="#自定义异常，继承Exception或者是RuntimeException，在业务中使用throw-new-XxxException（“xxx错误”）来使用。" class="headerlink" title="自定义异常，继承Exception或者是RuntimeException，在业务中使用throw new XxxException（“xxx错误”）来使用。"></a>自定义异常，继承Exception或者是RuntimeException，在业务中使用throw new XxxException（“xxx错误”）来使用。</h5><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class XxxException extends RuntimeException&#123;</span><br><span class="line">public XxxException()&#123;&#125;</span><br><span class="line">public XxxException(String msg) &#123;</span><br><span class="line">    super(msg);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、日志"><a href="#三、日志" class="headerlink" title="三、日志"></a>三、日志</h3><h5 id="日志级别："><a href="#日志级别：" class="headerlink" title="日志级别："></a>日志级别：</h5><blockquote><ul><li>DEBUG级别：记录对调试程序有帮助的信息。</li><li>INFO级别：用来记录程序运行现场，虽然此处并未发生错误，但是对排查其他错误具有指导意义。</li><li>WARN级别：也可以用来记录程序运行现场，但是更偏向于表明此处有出现潜在错误的可能。</li><li>ERROR级别：表明当前程序运行发生了错误，需要被关注。但是当前发生的错误，没有影响系统的继续运行。</li><li>FATAL级别：表明当前程序运行出现了严重的错误事件，并且将会导致应用程序中断。</li></ul></blockquote><h5 id="常见用法："><a href="#常见用法：" class="headerlink" title="常见用法："></a>常见用法：</h5><p><del>~</del><br>／／使明条件判断形式<br>if (logger.isDebugEnabled()) {<br>logger.debug (“Erocessing trade with id:”+ id + “and symlbol :” + symbol) ;<br>／／使用占位符形式<br>logger.debug (“Processing trade with id: {} and symbol：{}”,id,symbol);</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、异常分类&quot;&gt;&lt;a href=&quot;#一、异常分类&quot; class=&quot;headerlink&quot; title=&quot;一、异常分类&quot;&gt;&lt;/a&gt;一、异
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="exception" scheme="http://xingchuan.vip/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>走进JVM</title>
    <link href="http://xingchuan.vip/%E8%B5%B0%E8%BF%9BJVM.html"/>
    <id>http://xingchuan.vip/走进JVM.html</id>
    <published>2019-07-22T09:53:00.000Z</published>
    <updated>2019-07-22T02:32:05.074Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --><h3 id="一、字节码"><a href="#一、字节码" class="headerlink" title="一、字节码"></a>一、字节码</h3><h4 id="源码转化成字节码过程："><a href="#源码转化成字节码过程：" class="headerlink" title="源码转化成字节码过程："></a>源码转化成字节码过程：</h4><blockquote><ul><li>Java源文件-&gt;词法解析-&gt;语法解析-&gt;语义分析-&gt;生成字节码</li></ul></blockquote><hr><h3 id="二、类加载过程"><a href="#二、类加载过程" class="headerlink" title="二、类加载过程"></a>二、类加载过程</h3><h6 id="Java的类加载器是一个运行时核心基础设施模块，主要是在启动之初进行类的Load、Link和Init，即加载、链接、初始化。"><a href="#Java的类加载器是一个运行时核心基础设施模块，主要是在启动之初进行类的Load、Link和Init，即加载、链接、初始化。" class="headerlink" title="Java的类加载器是一个运行时核心基础设施模块，主要是在启动之初进行类的Load、Link和Init，即加载、链接、初始化。"></a>Java的类加载器是一个运行时核心基础设施模块，主要是在启动之初进行类的Load、Link和Init，即加载、链接、初始化。</h6><blockquote><ul><li>第一步，Load阶段读取类文件产生二进制流，并转化为特定的数据结构，初步校验cafe babe魔法数、常量池、文件长度、是否有父类，然后创建对应类的java.lang.Class实例。</li><li>第二步，Link阶段包括验证、准备解析三个步骤。验证是更详细的校验，比如final是否合规、类型是否准确静态变量是否合理、准备阶段是为静态变量分配内存，并设定默认值，解析类和方法确保类与类之间的项目引用准确性，完成内存结构布局。</li><li>Init阶段执行类构造器<clinit>方法，如果赋值与那算是通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值。</clinit></li></ul></blockquote><hr><h3 id="三、自定义加载器与双亲委派模型"><a href="#三、自定义加载器与双亲委派模型" class="headerlink" title="三、自定义加载器与双亲委派模型"></a>三、自定义加载器与双亲委派模型</h3><h4 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h4><blockquote><ul><li>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有的那个父加载类在自己的搜索范围内找不到指定的类时，自加载器才会尝试自己去加载。</li></ul></blockquote><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h5><h6 id="默认实现如下："><a href="#默认实现如下：" class="headerlink" title="默认实现如下："></a>默认实现如下：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        return loadClass(name, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="再看看loadClass-String-name-boolean-resolve-函数："><a href="#再看看loadClass-String-name-boolean-resolve-函数：" class="headerlink" title="再看看loadClass(String name, boolean resolve)函数："></a>再看看loadClass(String name, boolean resolve)函数：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从上面面代码可以明显看出，loadClass-String-boolean-函数即是实现了双亲委派模型，大致过程如下："><a href="#从上面面代码可以明显看出，loadClass-String-boolean-函数即是实现了双亲委派模型，大致过程如下：" class="headerlink" title="从上面面代码可以明显看出，loadClass(String,boolean)函数即是实现了双亲委派模型，大致过程如下："></a>从上面面代码可以明显看出，loadClass(String,boolean)函数即是实现了双亲委派模型，大致过程如下：</h5><blockquote><ul><li>首先、检查一下指定名称的类是否已经加载过了，如果加载过了，就不需要加载，直接返回。</li><li>如果此类没有加载过，那么，再判断下是否有父加载器；如果有，则由父加载器加载，或者调用bootstrap类加载器加载。</li><li>如果父加载器及bootstrap类加载器都没有找到指定的类，则调用当前类findClass方法来完成类加载。</li></ul></blockquote><h5 id="换句话说，如果要自定义类加载器，就必要要重写findClas方法。"><a href="#换句话说，如果要自定义类加载器，就必要要重写findClas方法。" class="headerlink" title="换句话说，如果要自定义类加载器，就必要要重写findClas方法。"></a>换句话说，如果要自定义类加载器，就必要要重写findClas方法。</h5><h6 id="默认实现如下：-1"><a href="#默认实现如下：-1" class="headerlink" title="默认实现如下："></a>默认实现如下：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException&#123;</span><br><span class="line">    throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>若果是读取一个指定的名称的类为字节数组，则使用defineClass转换成Class对象，默认实现如下：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</span><br><span class="line">        throws ClassFormatError  &#123;</span><br><span class="line">        return defineClass(name, b, off, len, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数调用过程："><a href="#函数调用过程：" class="headerlink" title="函数调用过程："></a>函数调用过程：</h4><blockquote><ul><li>开始-&gt;loadClass-&gt;父类加载器是否返回Class对象？是的话直接返回，否-&gt;findClass-&gt;根据名称读取文件存入字节数组-&gt;defineClas-&gt;返回Clas对象。</li></ul></blockquote><hr><h3 id="四、内存布局"><a href="#四、内存布局" class="headerlink" title="四、内存布局"></a>四、内存布局</h3><h5 id="主要有类加载子系统、java栈、方法区、Java堆、直接内存、本地方法栈、垃圾回收机制、PC寄存器、执行引擎。"><a href="#主要有类加载子系统、java栈、方法区、Java堆、直接内存、本地方法栈、垃圾回收机制、PC寄存器、执行引擎。" class="headerlink" title="主要有类加载子系统、java栈、方法区、Java堆、直接内存、本地方法栈、垃圾回收机制、PC寄存器、执行引擎。"></a>主要有类加载子系统、java栈、方法区、Java堆、直接内存、本地方法栈、垃圾回收机制、PC寄存器、执行引擎。</h5><blockquote><ul><li>类加载系统和方法区：类加载系统负责从文件系统或者网络中加载class信息，加载的类信息存放在一块称为方法区的内存空间。除了类的信息外，方法区还有可能存放运行时常量池信息，包括字符串常量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）。</li><li>Java堆：Java堆在虚拟机启动的时候建立，它是Java程序中最重要的内存工作区域。几乎所有的java对象实例都存放在java堆中。堆空间的所有线程是共享的，这是一块与java应用密切相关的内存空间。</li><li>直接内存：java的NIO库允许java程序使用直接内存。直接内存是java堆外的，直接向系统申请的工作空间。通常访问直接内存的速度会优于java堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在java堆外，因此它的大小不会受限于xmx指定的最大堆大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li><li>垃圾回收系统：垃圾回收系统是Java虚拟机的重要组成部分，垃圾回收器可以对方法区、java堆和直接内存进行回收。其中，java堆是垃圾收集器的工作重点。和C/C++不同，java中所有的对象空间释放都是隐式的，也就是说，java中没有类似free()或者delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默的查找，标识并释放垃圾对象，完成包括java堆，直接内存和方法区中全自动化管理。</li><li>Java栈：每一个java虚拟机线程都有一个私有的java栈，一个线程的java栈在线程创建的时候被创建，java栈中保存着帧的信息，java栈中保存着局部变量、方法参数、同时和java方法的调用、返回密切相关。</li><li>本地方法栈：本地方法栈和java栈非常类似，最大的不同在于java栈用于方法的调用，而本地方法栈则用于本地方法的调用，作为对java虚拟机的重要拓展，java虚拟机允许java直接调用本地方法（通常使用C编写）。</li><li>PC寄存器：PC寄存器也是每一个线程私有的空间，java虚拟机会为每一个java线程创建PC寄存器。在任意时刻，一个Java线程总是在执行一个方法，这个正在执行的方法称为当前方法。如果当前方法不是本地方法，PC寄存器就会指向正在被执行的指令。如果当前方法是本地方法，那么PC寄存器的值就是undefined。</li><li>执行引擎：执行引擎是Java虚拟机的最核心组件之一，它负责执行虚拟机的字节码文件，现代虚拟机为了提高执行效率，会使用即时编译技术将方法编译成机器码后执行。</li></ul></blockquote><hr><h3 id="五、垃圾回收"><a href="#五、垃圾回收" class="headerlink" title="五、垃圾回收"></a>五、垃圾回收</h3><h4 id="分代策略"><a href="#分代策略" class="headerlink" title="分代策略"></a>分代策略</h4><blockquote><ul><li>JVM内存分代策略<blockquote><ul><li>Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对HotSpot虚拟机而言），这就是JVM内存分代策略。</li></ul></blockquote></li><li>为什么要分代？<blockquote><ul><li>堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收机制最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中，给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾回收，而每次回收都要遍历所有对象，遍历这些对象所花费的时间代价是巨大的，会严重我们的GC效率，这简直太可怕了。</li><li>有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经历过多次回收任然存活下来的对象存放在老年代中，静态属性，类信息存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收的效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾回收算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。</li></ul></blockquote></li><li>内存分代划分<blockquote><ul><li>Java虚拟机将堆内存划分为新生代、老年代和永久代，永久代是HotSpot虚拟机特有的概念，它采用永久代的方式来实现方法区，其他的虚拟机实现没有这一个概念，而且HotSpot也有取消永久代的趋势，在JDK1.7中HotSpot已经开始去“永久化”，把原本放在永久代的字符串常量池移出。永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。</li></ul></blockquote></li><li>新生代<blockquote><ul><li>新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，回收效率很高。</li><li>HoSpot将新生代划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例是8：1：1。划分的目的是因为HotSpot采用主从复制算法来回收新生代，设计这个比例是为了充分利用内存空间，减少浪费。新生成的对象在Eden区分配（大对象除外，大对象直接进入老年代），当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的（作为保留区）。GC进行时，Eden区所有存活的对象都会被复制到To Survivor区，而在From Survivor区中，任然存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认是15，新生代中的对象每熬过一次垃圾回收，年龄值就加一，GC分代年龄储存在对象的header中）的对象就会被移到老年区，没有达到阀值的对象都在To Survivor区。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区，接着From Survivor区和To Survivor区会交换他们的角色，不管怎样都会保证To Survivor区在一轮GC后是空的。GC时当To Survivor区没有足够的空间存放上一次新生代收集下来的存活对象，需要依赖老年代进行分配担，将这些对象放在老年代区。</li></ul></blockquote></li><li>老年代<blockquote><ul><li>在新生代中经历了多次GC后任然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，在老年代中进行GC的频率相对而言较低，而且回收的速度较慢。</li></ul></blockquote></li><li>永久代<blockquote><ul><li>永久代存储类信息、常量、静态变量、即时编译器编译之后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾回收收集，一般而言不会进行垃圾回收。</li></ul></blockquote></li></ul></blockquote><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><blockquote><ul><li>比较古老的算法，原理是此对象有一个引用，既增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象，此算法最致命的是无法处理循环引用的问题。</li></ul></blockquote><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><blockquote><p>*此算法把内存空间分配成两个相等的区域，每次只使用其中的一个区域。垃圾回收时，遍历当前的使用区域，把正在使用的对象复制在另一个区域中，算法每次只处理正在使用中的对象，因此复制都成本较小，同时复制过去还能进行相应的内存整理，不会出现“碎片”问题，当然，此算法的缺点也是很明显的，就是需要两倍的内存空间。</p></blockquote><h5 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h5><blockquote><ul><li>此算法执行分两阶段，第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</li></ul></blockquote><h5 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h5><blockquote><ul><li>此算法整合了“标记-清除”和“复制”两个算法的优点，也是分两个阶段，第一个阶段从根节点开始标记所有被引用的对象，第二个阶段遍历整个堆，清除未标记的对象并且把存活的对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了”复制“算法的空间问题。</li></ul></blockquote><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="Scavenge-GC（次收集）和Full-GC的区别（全收集）"><a href="#Scavenge-GC（次收集）和Full-GC的区别（全收集）" class="headerlink" title="Scavenge GC（次收集）和Full GC的区别（全收集）"></a>Scavenge GC（次收集）和Full GC的区别（全收集）</h5><blockquote><ul><li>新生代GC（Scavenge GC）：<blockquote><ul><li>指发生在新生代的GC，因此新生代的Java对象大多都是朝生夕死，所以Scaveng GC非常频繁，一般回收速度也比较快。当Eden空间不足以为对象分配内存时，会触发Scavenge GC。</li></ul></blockquote></li><li>老年代GC（Full GC/Major GC）：<blockquote><ul><li>Full GC指发生在老年代的GC，出现了Full GC一般都伴随着至少一次的Minor GC（老年代的对象大部分是Minor GC过程中从新生代进入老年代），比如：分配担保失败，Full GC的速度一般会比Minor GC慢10倍以上。当老年代内存不足或者显式调用System.gc()方法时，会触发Full GC。</li></ul></blockquote></li><li>次收集<blockquote><ul><li>当年轻的空间紧张时会被触发</li><li>相对于全收集来说，收集间隔较短</li></ul></blockquote></li><li>全收集<blockquote><ul><li>当老年代或者持久代堆空间满了，会触发全收集操作</li><li>可以使用System.gc()方法来显式的启动全收集<br>全收集一般根据堆大小的不同，需要的时间不尽相同，但是一般会比较长，不过，如果全收集时间超过了3到5秒钟，那就太长了。</li></ul></blockquote></li></ul></blockquote><h5 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h5><blockquote><ul><li>串行收集器（Serial）<blockquote><ul><li>Serial收集器HotSpot运行在client模式下默认的新生代收集器，它的特点是只有一个cpu/一条收集线程去完成GC工作，且在进行垃圾收集时必须暂停其它所有的工作线程。<br>新生代采用复制算法，老年代采用标记-整理算法。</li></ul></blockquote></li><li>并行收集器（ParNew）<blockquote><ul><li>ParNew是Serial的多线程版本，除了使用多线程进行GC之外，包括Serial可用的所有控制参数、收集算法、STW、对象分配规则、回收策略等都与Serial完全一样，由于存在线程切换的开销，ParNew在单cpu的环境中比不上Serial，但是随着线程的增加，效率会大大增加。<br>新生代采用复制算法，老年代采用标记-整理算法。</li></ul></blockquote></li><li>Parallel Scavenge收集器<blockquote><ul><li>与ParNew类似，也是使用复制算法，也是并行多线程收集器，但与其他收集器关注尽可能缩短垃圾收集时间不同，Parallel Scavenge收集器更关注系统吞吐量。<br>系统吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。<br>停顿时间越短越适用于用户交互的程序，而高吞吐量则适用于后台运算而不需要太多交互的任务，可以最高效的利用cpu时间，尽快地完成程序的运算任务。</li></ul></blockquote></li></ul></blockquote><h5 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h5><blockquote><ul><li>erial Old收集器<br>Serial Old是Serial收集器的老年代版本，同样是单线程收集器，使用标记-整理算法。</li><li>Parallel Old收集器<br>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法，吞吐量优先，主要是和Parallel Scavenge在注重吞吐量及cpu资源敏感系统内使用。</li><li>CMS收集器<blockquote><ul><li>CMS是一个具有跨时代的收集器，一款真正意义上的并发收集器，虽然已经有了理论意义上表现更好的G1收集器，但现在主流互联网企业线上仍然是CMS。</li><li>CMS是一种以获取最短回收停顿时间为目标的收集器，又称为多并发低暂停的收集器，基于标记-清除算法实现，整个GC过程分为以下4个步骤：<blockquote><ul><li>初始标记；</li><li>并发标记；</li><li>重新标记；</li><li>并发清除。</li></ul></blockquote></li><li>由于CMD采用标记-清除算法实现，可能会产生大量的内存碎片，内存碎片过多会导致无法分配大对象而提前触发Full GC，因此CMS提供了-xx：+UseCMSCompactAtFullCollection开关参数。用于在Full GC之后再执行一次碎片整理过程，但是内存整理是无法并发的，内存碎片问题虽然没有了， 但是停顿时间也因此变长了，因此CMS还提供了一个参数-xx：CMSFullGCsBeforeCompaction用于设置在执行N次不进行内存整理的Full GC后，跟着来一次带整理的。</li></ul></blockquote></li></ul></blockquote><h5 id="分区收集-G1收集器（Garbage-First）"><a href="#分区收集-G1收集器（Garbage-First）" class="headerlink" title="分区收集-G1收集器（Garbage-First）"></a>分区收集-G1收集器（Garbage-First）</h5><blockquote><ul><li>G1是一款面向服务端应用的收集器，主要目标用于配备多频cpu的服务器治理大内存</li></ul><p>–XX:+UseG1GC，启动G1收集<br>与其他基于分代的收集器不同，G1将整个Java堆划分分为多个大小相等的独立区域，虽然还保留着新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、字节码&quot;&gt;&lt;a href=&quot;#一、字节码&quot; class=&quot;headerlink&quot; title=&quot;一、字节码&quot;&gt;&lt;/a&gt;一、字节码&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="JVM" scheme="http://xingchuan.vip/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型知识点</title>
    <link href="http://xingchuan.vip/%E6%B3%9B%E5%9E%8B.html"/>
    <id>http://xingchuan.vip/泛型.html</id>
    <published>2019-07-19T17:21:00.000Z</published>
    <updated>2019-07-22T01:00:15.775Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --><h3 id="一、什么是泛型？"><a href="#一、什么是泛型？" class="headerlink" title="一、什么是泛型？"></a>一、什么是泛型？</h3><blockquote><ul><li>本质就是类型参数化，可以定义在类、接口、方法中，编辑器通过识别尖括号和尖括号内的字母来解析泛型。在定义泛型时，约定俗称的符号包括：E代表Element，用户集合中的元素；T代表the type of object，表示某个类；K代表Key，V代表Value，用户键值对元素。</li></ul></blockquote><hr><h3 id="二、使用泛型的好处"><a href="#二、使用泛型的好处" class="headerlink" title="二、使用泛型的好处"></a>二、使用泛型的好处</h3><blockquote><ul><li>类型安全。放置的是什么，取回来的自然是什么，不用担心会抛出ClassCastException异常。</li><li>提升可读性，从编码阶段就显式地知道泛型集合、泛型方法等处理的对象类型是什么。</li><li>代码重用。泛型合并了同类型的处理代码，使代码重用度变高。</li></ul></blockquote><hr><h3 id="三、常见用法"><a href="#三、常见用法" class="headerlink" title="三、常见用法"></a>三、常见用法</h3><h5 id="泛型类："><a href="#泛型类：" class="headerlink" title="泛型类："></a>泛型类：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class DateHolder&lt;T&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line">    </span><br><span class="line">    public void setData(T t)&#123;</span><br><span class="line">        this.item = t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public T getDat()&#123;</span><br><span class="line">        return this.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class DateHolder&lt;T&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line">    </span><br><span class="line">    public void setData(T t)&#123;</span><br><span class="line">        this.item = t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public T getDat()&#123;</span><br><span class="line">        return this.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   /**</span><br><span class="line">    * 泛型方法</span><br><span class="line">    * @param e</span><br><span class="line">    */</span><br><span class="line">    public &lt;E&gt; void PrinterInfo(E e)&#123;</span><br><span class="line">        system.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//定义一个泛型接口</span><br><span class="line">public interface Generator&lt;T&gt;&#123;</span><br><span class="line">    public T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、泛型擦除及其相关内容"><a href="#四、泛型擦除及其相关内容" class="headerlink" title="四、泛型擦除及其相关内容"></a>四、泛型擦除及其相关内容</h3><h5 id="我们下面看一个例子："><a href="#我们下面看一个例子：" class="headerlink" title="我们下面看一个例子："></a>我们下面看一个例子：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1 = new ArrayList&lt;String&gt;().getClass();</span><br><span class="line">Class&lt;?&gt; class2 = new ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">System.out.println(class1);</span><br><span class="line">System.out.println(class2);</span><br><span class="line">System.out.println(class1.equals(class2);</span><br><span class="line"></span><br><span class="line">结果： </span><br><span class="line">    java.util.ArrayList</span><br><span class="line">    java.util.ArrayList</span><br><span class="line">    true</span><br></pre></td></tr></table></figure><blockquote><ul><li>我们看输出发现，class1和class2居然是同一个类型ArrayList，在运行时我们传入的类型变量String和Integer都被丢掉了。Java语言泛型在设计的时候为了兼容原来的旧代码，Java的泛型机制使用了”擦除机制”。</li></ul></blockquote><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><ul><li>编译器虽然会在编译过程中移除参数的类型信息，但是会保证类或方法内部参数类型的一致性。</li><li>泛型参数将会被擦除到它的第一个边界，如果没有指明边界，那么类型将会被擦除到Object。</li></ul></blockquote><h5 id="类型擦除原理："><a href="#类型擦除原理：" class="headerlink" title="类型擦除原理："></a>类型擦除原理：</h5><blockquote><ul><li>在编译过程中，类型变量的信息是能拿到的。所以，set方法在编辑器可以做类型检查，非法类型不能通过编译。但是对于get方法，由于擦除机制，运行时的实际引用为Object类型，为了还原返回结果的类型，编辑器在get方法后面添加了类型转换。</li></ul></blockquote><h5 id="类型擦除的缺陷和补救措施"><a href="#类型擦除的缺陷和补救措施" class="headerlink" title="类型擦除的缺陷和补救措施"></a>类型擦除的缺陷和补救措施</h5><p>泛型类型不能显示地运用在运行时类型的操作中，例如：转型、instanceof 和 new。因为在运行中，所有参数的类型都丢失了。类似如下代码则无法通过编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Erased&lt;T&gt;&#123;</span><br><span class="line">    private final int SIZE = 100;</span><br><span class="line">    public static void f(Object arg)&#123;</span><br><span class="line">        //编译不通过</span><br><span class="line">        if(arg instanceof T)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        //编译不通过</span><br><span class="line">        T var = new T();</span><br><span class="line">        //编译不通过</span><br><span class="line">        T[] array = new T[SIZE];</span><br><span class="line">        //编译不通过</span><br><span class="line">        T[] array = (T) new Object[SIZE]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决措施："><a href="#解决措施：" class="headerlink" title="解决措施："></a>解决措施：</h5><blockquote><ul><li>类型判断问题</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 泛型类型判断封装类</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class GenericType&lt;T&gt;&#123;</span><br><span class="line">    Class&lt;?&gt; classType;</span><br><span class="line">    </span><br><span class="line">    public GenericType(Class&lt;?&gt; type)&#123;</span><br><span class="line">        this.classType = type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean isInstance(Object object)&#123;</span><br><span class="line">        return classType.inInstance(Object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>创建类型实例</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *使用工厂方法来创建实例</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">interface Factory&lt;T&gt;&#123;</span><br><span class="line">    T create();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class creater&lt;T&gt;&#123;</span><br><span class="line">    T instance;</span><br><span class="line">    public &lt;F extends Factory&lt;T&gt;&gt;T newInstance(F f)&#123;</span><br><span class="line">    instance = f.create();</span><br><span class="line">    return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class IntegerFactory implements Factory&lt;Integer&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer create()&#123;</span><br><span class="line">        Integer integer = new Integer(9);</span><br><span class="line">        return integer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>创建泛型数组<blockquote><p>一般不建议创建泛型数组，尽量使用ArrayList来代替泛型数组。</p></blockquote></li></ul></blockquote><hr><h3 id="五、Java泛型的通配符"><a href="#五、Java泛型的通配符" class="headerlink" title="五、Java泛型的通配符"></a>五、Java泛型的通配符</h3><h5 id="上界通配符-lt-extends-T-gt"><a href="#上界通配符-lt-extends-T-gt" class="headerlink" title="上界通配符&lt;? extends T&gt;:"></a>上界通配符&lt;? extends T&gt;:</h5><blockquote><ul><li>只适合频繁读取的场景，例：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Food&#123;&#125;</span><br><span class="line">class Fruit extends Food&#123;&#125;</span><br><span class="line">class Apple extends Fruit&#123;&#125;</span><br><span class="line">class Banana extends Fruit&#123;&#125;</span><br></pre></td></tr></table></figure><p>在上面这个层次，可以用Plate&lt;? extends Fruit&gt;,无法存放，因为编译器只知道容器里存放的是Fruit和它的派生类，不知道具体类，但是可以进行读取操作。</p><h5 id="下界通配符-lt-super-T-gt"><a href="#下界通配符-lt-super-T-gt" class="headerlink" title="下界通配符&lt;? super T&gt;:"></a>下界通配符&lt;? super T&gt;:</h5><blockquote><ul><li>不影响往里面存储，但是读取出来的数据只能是Object类型，里面存储的都是T及其基类，无法转换成任何一种类型，只能转换成Object基类才能放下。</li></ul></blockquote><h5 id="lt-gt-无限通配符"><a href="#lt-gt-无限通配符" class="headerlink" title="&lt;?&gt;无限通配符"></a>&lt;?&gt;无限通配符</h5><blockquote><ul><li>无界通配符修饰的容器持有的是某种具体的类型。举个例子，在List&lt;？&gt;类型的引用中，不能向其中添加Object，而在List类型的引用中，可以添加Object对象。</li></ul></blockquote><h5 id="PECS原则："><a href="#PECS原则：" class="headerlink" title="PECS原则："></a>PECS原则：</h5><blockquote><ul><li>上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。</li><li>下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、什么是泛型？&quot;&gt;&lt;a href=&quot;#一、什么是泛型？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是泛型？&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="泛型" scheme="http://xingchuan.vip/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>HTTP/HTTPS</title>
    <link href="http://xingchuan.vip/http%E5%92%8Chttps.html"/>
    <id>http://xingchuan.vip/http和https.html</id>
    <published>2019-07-19T15:00:00.000Z</published>
    <updated>2019-07-19T07:44:33.747Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --><h3 id="一、什么是HTTP和HTTPS？"><a href="#一、什么是HTTP和HTTPS？" class="headerlink" title="一、什么是HTTP和HTTPS？"></a>一、什么是HTTP和HTTPS？</h3><h5 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h5><blockquote><ul><li>超文本传输协议，所有的www文件都必须遵守这个标准，互联网上应用最广泛的一种网络协议。</li></ul></blockquote><h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS:"></a>HTTPS:</h5><blockquote><ul><li>是以安全为目标的HTTP通道，简单来说就是HTTP的安全办，即HTTP下加入SLL层，HTTPS的安全基础是SLL，因此加密的详细内容就需要要SSL。</li><li>主要作用：建立一个信息安全通道，保证数据安全；确定网站真实性。</li></ul></blockquote><hr><h3 id="二、两者区别"><a href="#二、两者区别" class="headerlink" title="二、两者区别"></a>二、两者区别</h3><blockquote><ul><li>http免费试用，https协议需要ca申请证书，一般免费证书很少，需要交费。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的完全不一样的端口，前者是80，后者是443。</li><li>http的连接很简单，是无状态的。</li><li>https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</li></ul></blockquote><hr><h3 id="三、HTTPS工作流程"><a href="#三、HTTPS工作流程" class="headerlink" title="三、HTTPS工作流程"></a>三、HTTPS工作流程</h3><blockquote><ul><li>客户端使用https的URL访问Web服务器，要求与Web服务器建立SSL连接；</li><li>Web服务器接收客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端；</li><li>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级；</li><li>客户端浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站；</li><li>Web服务器利用自己的私钥解密会话密钥；</li><li>Web服务器利用会话密钥加密与客户端之间的通信。</li></ul></blockquote><hr><h3 id="四、一句话总结HTTPS"><a href="#四、一句话总结HTTPS" class="headerlink" title="四、一句话总结HTTPS"></a>四、一句话总结HTTPS</h3><blockquote><ul><li>HTTPS要使客户端与服务器端的通信过程得到安全的保证。必须使用对称加密，但是协商对称密钥的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身就不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这种机制协商出一个对称加密算法，之后双方再使用该算法进行加解密，从而解决了客户端与服务端之间的通信安全问题。</li></ul></blockquote><hr><h3 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a>五、常见问题</h3><h5 id="TLS和SLL的区别？"><a href="#TLS和SLL的区别？" class="headerlink" title="TLS和SLL的区别？"></a>TLS和SLL的区别？</h5><blockquote><ul><li>TLS可以理解成SSL协议3.0版本的升级，所以TLS的1.0版本也被标识为SSL3.1版本。</li></ul></blockquote><h5 id="什么是对称加密和非对称加密？"><a href="#什么是对称加密和非对称加密？" class="headerlink" title="什么是对称加密和非对称加密？"></a>什么是对称加密和非对称加密？</h5><blockquote><ul><li>对称加密：最快速、最简单的加密方式，加密与解密同样的密钥，这种方法在密码学中叫做对称加密算法。最大缺点是密钥的管理和分配，在发送密钥的过程中，密钥有很大的风险会被黑客拦截。通常做法是将对称加密的密钥进行非对称加密，然后传输给需要他的人。</li><li>非对称加密：为数据加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥和私钥。私钥只能由一方保管，不能外泄，而公钥则可以发送给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发送给你，你使用公钥对数据加密，只有私钥的持有人银行才能对你的消息进行解密，安全性大大提高。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、什么是HTTP和HTTPS？&quot;&gt;&lt;a href=&quot;#一、什么是HTTP和HTTPS？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="https" scheme="http://xingchuan.vip/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>网络安全</title>
    <link href="http://xingchuan.vip/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.html"/>
    <id>http://xingchuan.vip/网络安全.html</id>
    <published>2019-07-19T13:15:00.000Z</published>
    <updated>2019-07-19T05:53:54.847Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --><h3 id="一、黑客与安全"><a href="#一、黑客与安全" class="headerlink" title="一、黑客与安全"></a>一、黑客与安全</h3><h5 id="黑客："><a href="#黑客：" class="headerlink" title="黑客："></a>黑客：</h5><blockquote><ul><li>攻击手段分为非破坏性攻击和破坏性攻击。<blockquote><ul><li>非破坏型攻击：一般是为了扰乱系统的运行，使之暂时失去对外提供服务的能力，比如DDos攻击。</li><li>破坏性攻击：主要会造成两种后果:系统数据收送或者信息被窃取，比如CSRF攻击。</li></ul></blockquote></li><li>攻击手段有病毒式、洪水式、系统漏洞式。</li></ul></blockquote><h5 id="安全："><a href="#安全：" class="headerlink" title="安全："></a>安全：</h5><blockquote><ul><li>互联网企业都要建立一套完整的信息安全体系，遵循CIA原则，即保密性、完整性、可用性。<blockquote><ul><li>保密性：对需要保护的数据（例如用户的私人信息等）进行保密操作，无论是存储还是传输，都要保证用户数据及相关资源的安全。</li><li>完整性：访问的数据需要是完整的，而不是缺失或者篡改的，必然用户访问的数据就是不正确的。</li><li>可用性：服务必须是可用的。</li></ul></blockquote></li></ul></blockquote><hr><h3 id="二、SQL注入"><a href="#二、SQL注入" class="headerlink" title="二、SQL注入"></a>二、SQL注入</h3><blockquote><ul><li>SQL注入是注入式攻击中常见的类型，是未将代码与数据进行严格的隔离，导致在读取用户数据时候，错误的把数据作为代码的一部分执行，从而导致安全问题。</li></ul></blockquote><h5 id="常见案例："><a href="#常见案例：" class="headerlink" title="常见案例："></a>常见案例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var testCondition;</span><br><span class="line">testCondition = Request.from(&quot;testCondition&quot;)</span><br><span class="line">var sql = &quot;select * from TableA where id =&apos;&quot;+ testCondition +&quot;&apos;&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>上面例子，若果用户只输入ID是一个数字是没有问题的，但是如果用”;”隔开，在testCondition中插入其他SQL，则会带来意想不到的结果。</p></blockquote><h5 id="如何预防？"><a href="#如何预防？" class="headerlink" title="如何预防？"></a>如何预防？</h5><blockquote><ul><li>过滤用户输入参数中的特殊字符，从而降低被SQL注入的风险；</li><li>禁止通过字符串凭借的SQL语句，严格使用参数绑定传入的SQL参数；</li><li>合理使用数据库访问框架提供的防注入机制。例如Mybatis提供的#{} 绑定数据，从而防止SQL注入。同时谨慎使用${},${}相当于使用字符串拼接SQL，拒绝拼接的SQL语句，使用参数化的语句。</li></ul></blockquote><hr><h3 id="三、XSS与CSRF"><a href="#三、XSS与CSRF" class="headerlink" title="三、XSS与CSRF"></a>三、XSS与CSRF</h3><h5 id="XSS"><a href="#XSS" class="headerlink" title="XSS:"></a>XSS:</h5><blockquote><ul><li>跨站脚本攻击，指黑客通过技术手段，向正常用户请求的HTML页面中插入恶意的脚本，从而可以执行任意脚本,比如如下代码可能造成XSS漏洞</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h3&gt;反射型xss示例&lt;h3&gt;</span><br><span class="line">&lt;br&gt;用户：&lt;%= request.getParameter(&quot;userName&quot;) %&gt;</span><br><span class="line">&lt;br&gt;系统错误信息：&lt;%= request.getParameter(&quot;errorMessage&quot;) %&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码从HTTP请求中获取了userName和errorMessage两个参数，并直接输出到HTML中展示，当黑客构造如下的URL时出现了反射型XSS</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xss.demo/self-xss.jsp?userName= 张三&lt;script&gt;alert(&quot;张三&quot;)&lt;/script&gt;&amp;errorMessage=XSS示例&lt;script src=http://hacker.demo/xss-script.js /&gt;</span><br></pre></td></tr></table></figure><h6 id="防范措施："><a href="#防范措施：" class="headerlink" title="防范措施："></a>防范措施：</h6><blockquote><ul><li>使用Jsonp框架对用户输入字符串做XSS过滤；</li><li>使用框架的工具类对用户输入的字符串做HTML转义，例如Spring提供的HtmlUtils；</li><li>前端展示数据时使用innerText而不是innerHTML。</li></ul></blockquote><h5 id="CSRF："><a href="#CSRF：" class="headerlink" title="CSRF："></a>CSRF：</h5><blockquote><ul><li>跨站请求伪造，在用户不知情的情况下，冒用用户发起请求，在当前已经登录的Web应用上执行恶意操作，如恶意发帖，修改密码等。比如某用户A登录了网上银行，这时黑客给他发了一条连接如下：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https//net_bank.demo/transfer.do?targetAccount=12345&amp;amount=100</span><br></pre></td></tr></table></figure><blockquote><p>如果用户在打开网银的浏览器中点开了黑客发送的URL,那么就有可能给黑客转账100元。</p></blockquote><h6 id="防范措施：-1"><a href="#防范措施：-1" class="headerlink" title="防范措施："></a>防范措施：</h6><blockquote><ul><li>CSRF Token验证，利用浏览器的同源限制，在HTTP接口执行前验证页面或者Cookie中设置的Token，只有验证通过才能继续执行请求；</li><li>人机交互，比如在调用网上银行转账时校验短信验证码。</li></ul></blockquote><hr><h3 id="四、两者差别"><a href="#四、两者差别" class="headerlink" title="四、两者差别"></a>四、两者差别</h3><blockquote><ul><li>XSS是在正常用户请求的HTML页面中执行了黑客提供的恶意代码；CSRF是黑客直接盗用浏览器中的登录信息，冒充用户去执行黑客指定的操作。XSS问题出在用户数据没有过滤、转义；CSRF问题出现在HTTP接口没有防范不受信任的调用。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、黑客与安全&quot;&gt;&lt;a href=&quot;#一、黑客与安全&quot; class=&quot;headerlink&quot; title=&quot;一、黑客与安全&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="socket" scheme="http://xingchuan.vip/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>什么是TCP/IP</title>
    <link href="http://xingchuan.vip/TCP-IP.html"/>
    <id>http://xingchuan.vip/TCP-IP.html</id>
    <published>2019-07-19T09:44:00.000Z</published>
    <updated>2019-07-19T02:25:09.012Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --><h3 id="一、网络协议"><a href="#一、网络协议" class="headerlink" title="一、网络协议"></a>一、网络协议</h3><h5 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP :"></a>TCP/IP :</h5><blockquote><ul><li>中文翻译为传输控制协议，通常有4层协议：应用层、传输层、网络层、链路层。</li></ul></blockquote><h5 id="链路层："><a href="#链路层：" class="headerlink" title="链路层："></a>链路层：</h5><blockquote><ul><li>主要有IEEE 802.x/PPP 等，以字节为单位把0与1进行分组，定义数据帧，写入源和目标机器的物理地址、数据、校验位来传输数据。</li></ul></blockquote><h5 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h5><blockquote><ul><li>主要有IP/APR等，根据IP定义网络地址，区分网段。子网内根据地址解析协议（ARP）进行MAC寻址，子网外进行路由转发数据包，这个数据包即为IP数据包。</li></ul></blockquote><h5 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h5><blockquote><ul><li>主要有TPC/UDP等，数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份，把数据包交给应用程序，实现端口与端口间的通信。</li></ul></blockquote><h5 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h5><blockquote><ul><li>主要有HTTP/FTP/SMTP等，传输层的数据到达应用程序后，以某种统一规定的协议格式解读数据。</li></ul></blockquote><hr><h3 id="二、IP协议"><a href="#二、IP协议" class="headerlink" title="二、IP协议"></a>二、IP协议</h3><blockquote><ul><li>IP协议是面向无连接、无状态、没有额外的机制保证发送的包是否有序到达。</li><li>是TCP/IP的基石，几乎所有其他协议都是建立在IP所提供的服务基础上进行传输，其中包括在实际应用中用于传输稳定有序数据的TCP。</li></ul></blockquote><hr><h3 id="三、TPC建立链接"><a href="#三、TPC建立链接" class="headerlink" title="三、TPC建立链接"></a>三、TPC建立链接</h3><blockquote><ul><li>传输控制协议。是一种面向连接、确保数据在端与端之间可靠传输的协议。</li><li>三次握手:<blockquote><ul><li>A机器发出一个数据包并将SYN置1，表示希望建立连接；</li><li>B机器收到A机器发过来的数据包，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置为1。假设这个包中的序列号是y，而确认序列号必须是x+1，表示收到了A发过来的SYN，在TCP中，SYN被当做数据部分的一个字节；</li><li>A收到B的响应包后进行确认，确认包中将ACK置为1，并将确认序列号置为y+1，表示收到来自B的SYN。</li></ul></blockquote></li><li>目的： 信息对等，防止超时。</li></ul></blockquote><hr><h3 id="四、TCP断开连接"><a href="#四、TCP断开连接" class="headerlink" title="四、TCP断开连接"></a>四、TCP断开连接</h3><blockquote><ul><li>四次挥手：<blockquote><ul><li>A机器想要关闭连接，则待本方数据发送完毕之后，传递FIN信号给B机器；</li><li>B机器应答ACK，告诉A机器可以断开，但是要等B机器处理完数据，再主动给A机器发送FIN信号，此时A机器处于半关闭状态，无法发送新的数据；</li><li>B机器做好链接关闭的准备后，发送FIN信号给A机器，此时B机器也进入半关闭状态；</li><li>A机器发送针对B机器FIN的ACK后，进入TIME-WAIT状态，经过2MSL后，没有收到B发送的报文，则确定B机器已经收到A机器最后发送的ACK命令，此时TCP正式释放。</li></ul></blockquote></li></ul></blockquote><hr><h3 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a>五、常见问题</h3><h5 id="1-TCP和UDP区别？"><a href="#1-TCP和UDP区别？" class="headerlink" title="1. TCP和UDP区别？"></a>1. TCP和UDP区别？</h5><blockquote><ul><li>TCP:<blockquote><ul><li>面向连接</li><li>点到点通信</li><li>高可靠性</li><li>占用系统资源多、效率低</li><li>利用IO流实现数据的传输</li><li>响应式请求</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>UDP:<blockquote><ul><li>非面向连接，传输不可靠，可能丢失</li><li>发送不管对方是否准备好，接受到也不确认</li><li>可以广播发送</li><li>非常简单的协议，开销小</li><li>效率高，不用IO流实现数据的传输</li></ul></blockquote></li></ul></blockquote><h5 id="2-为什么连接的时候是三次握手，断开的时候是四次挥手？"><a href="#2-为什么连接的时候是三次握手，断开的时候是四次挥手？" class="headerlink" title="2. 为什么连接的时候是三次握手，断开的时候是四次挥手？"></a>2. 为什么连接的时候是三次握手，断开的时候是四次挥手？</h5><blockquote><ul><li>当服务端收到客户端的连接请求报文时，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的，但是关闭连接时候，当服务端收到FIN报文时，不会立刻关闭SOCKET，只能先回复一个ACK报文，告诉客户端你的FIN报文收到了，只有等我服务端所有的报文发送完，我才能发送FIN报文，因此不能一次发送，需要四步。</li></ul></blockquote><h5 id="3-为什么不用两次握手链接？"><a href="#3-为什么不用两次握手链接？" class="headerlink" title="3.为什么不用两次握手链接？"></a>3.为什么不用两次握手链接？</h5><blockquote><ul><li>容易发生死锁，客户端在服务端的应答分组在传输中被丢失的情况下，将不知道服务端是否准备好，不知道服务端建立什么样的序列号，在这种情况下，客户端认为链接还未建立，将忽略服务端发来的任何数据分组，只能等待链接确认才应答f分组，而服务端发出的分组超时后，重复发送同样的分组，这样就行成了死锁。</li></ul></blockquote><h5 id="4-为什么TIME-WAIT状态需要经过2MSL才能返回到Close状态？"><a href="#4-为什么TIME-WAIT状态需要经过2MSL才能返回到Close状态？" class="headerlink" title="4.为什么TIME-WAIT状态需要经过2MSL才能返回到Close状态？"></a>4.为什么TIME-WAIT状态需要经过2MSL才能返回到Close状态？</h5><blockquote><ul><li>按照道理来说，四个报文发送完毕，我们可以直接进入CLOSE状态，但是我们假象网络是不可靠的，有可能最后一个ACK丢失，所以TIME-WAIT状态是用来重发可能丢失的ACK报文。在客户端发送出最后的ACK回复，但该ACK可能丢失，服务端如果没有收到ACK，则不断的发送FIN片段，所以客户端不能立即关闭，它必须确认客户端收到了该ACK，此时设置了一个定时器，如果直到2MSL，客户端都没有收到FIN，则推断ACK已经成功被接收，关闭连接。</li></ul></blockquote><h5 id="5-如果已经建立了连接，但是客户端突然出现故障怎么办？"><a href="#5-如果已经建立了连接，但是客户端突然出现故障怎么办？" class="headerlink" title="5.如果已经建立了连接，但是客户端突然出现故障怎么办？"></a>5.如果已经建立了连接，但是客户端突然出现故障怎么办？</h5><blockquote><ul><li>TPC设有一个保活计时器，服务端每次接收到请求都会重新复位这个计时器，时间通常是2小时，若2小时没有收到客户端的任何数据，则服务端会发送一个探测报文段，以后每隔75秒发送一次，若一连发送10个探测报文都没有反应，则认为客户端发生故障，关闭连接。</li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jul 24 2019 13:41:32 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、网络协议&quot;&gt;&lt;a href=&quot;#一、网络协议&quot; class=&quot;headerlink&quot; title=&quot;一、网络协议&quot;&gt;&lt;/a&gt;一、网
      
    
    </summary>
    
      <category term="笔记" scheme="http://xingchuan.vip/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xingchuan.vip/tags/java/"/>
    
      <category term="socket" scheme="http://xingchuan.vip/tags/socket/"/>
    
  </entry>
  
</feed>
