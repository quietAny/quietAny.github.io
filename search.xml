<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP/HTTPS]]></title>
    <url>%2Fhttp%E5%92%8Chttps.html</url>
    <content type="text"><![CDATA[一、什么是HTTP和HTTPS？HTTP：超文本传输协议，所有的www文件都必须遵守这个标准，互联网上应用最广泛的一种网络协议。HTTPS:是以安全为目标的HTTP通道，简单来说就是HTTP的安全办，即HTTP下加入SLL层，HTTPS的安全基础是SLL，因此加密的详细内容就需要要SSL。主要作用：建立一个信息安全通道，保证数据安全；确定网站真实性。二、两者区别http免费试用，https协议需要ca申请证书，一般免费证书很少，需要交费。http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。http和https使用的完全不一样的端口，前者是80，后者是443。http的连接很简单，是无状态的。https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。三、HTTPS工作流程客户端使用https的URL访问Web服务器，要求与Web服务器建立SSL连接；Web服务器接收客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端；客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级；客户端浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站；Web服务器利用自己的私钥解密会话密钥；Web服务器利用会话密钥加密与客户端之间的通信。四、一句话总结HTTPSHTTPS要使客户端与服务器端的通信过程得到安全的保证。必须使用对称加密，但是协商对称密钥的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身就不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这种机制协商出一个对称加密算法，之后双方再使用该算法进行加解密，从而解决了客户端与服务端之间的通信安全问题。五、常见问题TLS和SLL的区别？TLS可以理解成SSL协议3.0版本的升级，所以TLS的1.0版本也被标识为SSL3.1版本。什么是对称加密和非对称加密？对称加密：最快速、最简单的加密方式，加密与解密同样的密钥，这种方法在密码学中叫做对称加密算法。最大缺点是密钥的管理和分配，在发送密钥的过程中，密钥有很大的风险会被黑客拦截。通常做法是将对称加密的密钥进行非对称加密，然后传输给需要他的人。非对称加密：为数据加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥和私钥。私钥只能由一方保管，不能外泄，而公钥则可以发送给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发送给你，你使用公钥对数据加密，只有私钥的持有人银行才能对你的消息进行解密，安全性大大提高。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络安全]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.html</url>
    <content type="text"><![CDATA[一、黑客与安全黑客：攻击手段分为非破坏性攻击和破坏性攻击。非破坏型攻击：一般是为了扰乱系统的运行，使之暂时失去对外提供服务的能力，比如DDos攻击。破坏性攻击：主要会造成两种后果:系统数据收送或者信息被窃取，比如CSRF攻击。攻击手段有病毒式、洪水式、系统漏洞式。安全：互联网企业都要建立一套完整的信息安全体系，遵循CIA原则，即保密性、完整性、可用性。保密性：对需要保护的数据（例如用户的私人信息等）进行保密操作，无论是存储还是传输，都要保证用户数据及相关资源的安全。完整性：访问的数据需要是完整的，而不是缺失或者篡改的，必然用户访问的数据就是不正确的。可用性：服务必须是可用的。二、SQL注入SQL注入是注入式攻击中常见的类型，是未将代码与数据进行严格的隔离，导致在读取用户数据时候，错误的把数据作为代码的一部分执行，从而导致安全问题。常见案例：123var testCondition;testCondition = Request.from(&quot;testCondition&quot;)var sql = &quot;select * from TableA where id =&apos;&quot;+ testCondition +&quot;&apos;&quot;;上面例子，若果用户只输入ID是一个数字是没有问题的，但是如果用”;”隔开，在testCondition中插入其他SQL，则会带来意想不到的结果。如何预防？过滤用户输入参数中的特殊字符，从而降低被SQL注入的风险；禁止通过字符串凭借的SQL语句，严格使用参数绑定传入的SQL参数；合理使用数据库访问框架提供的防注入机制。例如Mybatis提供的#{} 绑定数据，从而防止SQL注入。同时谨慎使用${},${}相当于使用字符串拼接SQL，拒绝拼接的SQL语句，使用参数化的语句。三、XSS与CSRFXSS:跨站脚本攻击，指黑客通过技术手段，向正常用户请求的HTML页面中插入恶意的脚本，从而可以执行任意脚本,比如如下代码可能造成XSS漏洞12345&lt;div&gt;&lt;h3&gt;反射型xss示例&lt;h3&gt;&lt;br&gt;用户：&lt;%= request.getParameter(&quot;userName&quot;) %&gt;&lt;br&gt;系统错误信息：&lt;%= request.getParameter(&quot;errorMessage&quot;) %&gt;&lt;/div&gt;上面的代码从HTTP请求中获取了userName和errorMessage两个参数，并直接输出到HTML中展示，当黑客构造如下的URL时出现了反射型XSS1http://xss.demo/self-xss.jsp?userName= 张三&lt;script&gt;alert(&quot;张三&quot;)&lt;/script&gt;&amp;errorMessage=XSS示例&lt;script src=http://hacker.demo/xss-script.js /&gt;防范措施：使用Jsonp框架对用户输入字符串做XSS过滤；使用框架的工具类对用户输入的字符串做HTML转义，例如Spring提供的HtmlUtils；前端展示数据时使用innerText而不是innerHTML。CSRF：跨站请求伪造，在用户不知情的情况下，冒用用户发起请求，在当前已经登录的Web应用上执行恶意操作，如恶意发帖，修改密码等。比如某用户A登录了网上银行，这时黑客给他发了一条连接如下：1https//net_bank.demo/transfer.do?targetAccount=12345&amp;amount=100如果用户在打开网银的浏览器中点开了黑客发送的URL,那么就有可能给黑客转账100元。防范措施：CSRF Token验证，利用浏览器的同源限制，在HTTP接口执行前验证页面或者Cookie中设置的Token，只有验证通过才能继续执行请求；人机交互，比如在调用网上银行转账时校验短信验证码。四、两者差别XSS是在正常用户请求的HTML页面中执行了黑客提供的恶意代码；CSRF是黑客直接盗用浏览器中的登录信息，冒充用户去执行黑客指定的操作。XSS问题出在用户数据没有过滤、转义；CSRF问题出现在HTTP接口没有防范不受信任的调用。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是TCP/IP]]></title>
    <url>%2FTCP-IP.html</url>
    <content type="text"><![CDATA[一、网络协议TCP/IP :中文翻译为传输控制协议，通常有4层协议：应用层、传输层、网络层、链路层。链路层：主要有IEEE 802.x/PPP 等，以字节为单位把0与1进行分组，定义数据帧，写入源和目标机器的物理地址、数据、校验位来传输数据。网络层：主要有IP/APR等，根据IP定义网络地址，区分网段。子网内根据地址解析协议（ARP）进行MAC寻址，子网外进行路由转发数据包，这个数据包即为IP数据包。传输层：主要有TPC/UDP等，数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份，把数据包交给应用程序，实现端口与端口间的通信。应用层：主要有HTTP/FTP/SMTP等，传输层的数据到达应用程序后，以某种统一规定的协议格式解读数据。二、IP协议IP协议是面向无连接、无状态、没有额外的机制保证发送的包是否有序到达。是TCP/IP的基石，几乎所有其他协议都是建立在IP所提供的服务基础上进行传输，其中包括在实际应用中用于传输稳定有序数据的TCP。三、TPC建立链接传输控制协议。是一种面向连接、确保数据在端与端之间可靠传输的协议。三次握手:A机器发出一个数据包并将SYN置1，表示希望建立连接；B机器收到A机器发过来的数据包，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置为1。假设这个包中的序列号是y，而确认序列号必须是x+1，表示收到了A发过来的SYN，在TCP中，SYN被当做数据部分的一个字节；A收到B的响应包后进行确认，确认包中将ACK置为1，并将确认序列号置为y+1，表示收到来自B的SYN。目的： 信息对等，防止超时。四、TCP断开连接四次挥手：A机器想要关闭连接，则待本方数据发送完毕之后，传递FIN信号给B机器；B机器应答ACK，告诉A机器可以断开，但是要等B机器处理完数据，再主动给A机器发送FIN信号，此时A机器处于半关闭状态，无法发送新的数据；B机器做好链接关闭的准备后，发送FIN信号给A机器，此时B机器也进入半关闭状态；A机器发送针对B机器FIN的ACK后，进入TIME-WAIT状态，经过2MSL后，没有收到B发送的报文，则确定B机器已经收到A机器最后发送的ACK命令，此时TCP正式释放。五、常见问题1. TCP和UDP区别？TCP:面向连接点到点通信高可靠性占用系统资源多、效率低利用IO流实现数据的传输响应式请求UDP:非面向连接，传输不可靠，可能丢失发送不管对方是否准备好，接受到也不确认可以广播发送非常简单的协议，开销小效率高，不用IO流实现数据的传输2. 为什么连接的时候是三次握手，断开的时候是四次挥手？当服务端收到客户端的连接请求报文时，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的，但是关闭连接时候，当服务端收到FIN报文时，不会立刻关闭SOCKET，只能先回复一个ACK报文，告诉客户端你的FIN报文收到了，只有等我服务端所有的报文发送完，我才能发送FIN报文，因此不能一次发送，需要四步。3.为什么不用两次握手链接？容易发生死锁，客户端在服务端的应答分组在传输中被丢失的情况下，将不知道服务端是否准备好，不知道服务端建立什么样的序列号，在这种情况下，客户端认为链接还未建立，将忽略服务端发来的任何数据分组，只能等待链接确认才应答f分组，而服务端发出的分组超时后，重复发送同样的分组，这样就行成了死锁。4.为什么TIME-WAIT状态需要经过2MSL才能返回到Close状态？按照道理来说，四个报文发送完毕，我们可以直接进入CLOSE状态，但是我们假象网络是不可靠的，有可能最后一个ACK丢失，所以TIME-WAIT状态是用来重发可能丢失的ACK报文。在客户端发送出最后的ACK回复，但该ACK可能丢失，服务端如果没有收到ACK，则不断的发送FIN片段，所以客户端不能立即关闭，它必须确认客户端收到了该ACK，此时设置了一个定时器，如果直到2MSL，客户端都没有收到FIN，则推断ACK已经成功被接收，关闭连接。5.如果已经建立了连接，但是客户端突然出现故障怎么办？TPC设有一个保活计时器，服务端每次接收到请求都会重新复位这个计时器，时间通常是2小时，若2小时没有收到客户端的任何数据，则服务端会发送一个探测报文段，以后每隔75秒发送一次，若一连发送10个探测报文都没有反应，则认为客户端发生故障，关闭连接。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>socket</tag>
      </tags>
  </entry>
</search>
