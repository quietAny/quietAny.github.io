<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java泛型知识点]]></title>
    <url>%2F%E6%B3%9B%E5%9E%8B.html</url>
    <content type="text"><![CDATA[一、什么是泛型？本质就是类型参数化，可以定义在类、接口、方法中，编辑器通过识别尖括号和尖括号内的字母来解析泛型。在定义泛型时，约定俗称的符号包括：E代表Element，用户集合中的元素；T代表the type of object，表示某个类；K代表Key，V代表Value，用户键值对元素。二、使用泛型的好处类型安全。放置的是什么，取回来的自然是什么，不用担心会抛出ClassCastException异常。提升可读性，从编码阶段就显式地知道泛型集合、泛型方法等处理的对象类型是什么。代码重用。泛型合并了同类型的处理代码，使代码重用度变高。三、常见用法泛型类：1234567891011class DateHolder&lt;T&gt;&#123; T item; public void setData(T t)&#123; this.item = t; &#125; public T getDat()&#123; return this.item; &#125;&#125;泛型方法12345678910111213141516171819class DateHolder&lt;T&gt;&#123; T item; public void setData(T t)&#123; this.item = t; &#125; public T getDat()&#123; return this.item; &#125; /** * 泛型方法 * @param e */ public &lt;E&gt; void PrinterInfo(E e)&#123; system.out.println(e); &#125;&#125;泛型接口1234//定义一个泛型接口public interface Generator&lt;T&gt;&#123; public T next();&#125;四、泛型擦除及其相关内容我们下面看一个例子：12345678910Class&lt;?&gt; class1 = new ArrayList&lt;String&gt;().getClass();Class&lt;?&gt; class2 = new ArrayList&lt;Integer&gt;().getClass();System.out.println(class1);System.out.println(class2);System.out.println(class1.equals(class2);结果： java.util.ArrayList java.util.ArrayList true我们看输出发现，class1和class2居然是同一个类型ArrayList，在运行时我们传入的类型变量String和Integer都被丢掉了。Java语言泛型在设计的时候为了兼容原来的旧代码，Java的泛型机制使用了”擦除机制”。注意：编译器虽然会在编译过程中移除参数的类型信息，但是会保证类或方法内部参数类型的一致性。泛型参数将会被擦除到它的第一个边界，如果没有指明边界，那么类型将会被擦除到Object。类型擦除原理：在编译过程中，类型变量的信息是能拿到的。所以，set方法在编辑器可以做类型检查，非法类型不能通过编译。但是对于get方法，由于擦除机制，运行时的实际引用为Object类型，为了还原返回结果的类型，编辑器在get方法后面添加了类型转换。类型擦除的缺陷和补救措施泛型类型不能显示地运用在运行时类型的操作中，例如：转型、instanceof 和 new。因为在运行中，所有参数的类型都丢失了。类似如下代码则无法通过编译：1234567891011121314public class Erased&lt;T&gt;&#123; private final int SIZE = 100; public static void f(Object arg)&#123; //编译不通过 if(arg instanceof T)&#123; &#125; //编译不通过 T var = new T(); //编译不通过 T[] array = new T[SIZE]; //编译不通过 T[] array = (T) new Object[SIZE]; &#125;&#125;解决措施：类型判断问题123456789101112131415/** * 泛型类型判断封装类 * */class GenericType&lt;T&gt;&#123; Class&lt;?&gt; classType; public GenericType(Class&lt;?&gt; type)&#123; this.classType = type; &#125; public boolean isInstance(Object object)&#123; return classType.inInstance(Object); &#125;&#125;创建类型实例123456789101112131415161718192021222324/** *使用工厂方法来创建实例 * * */interface Factory&lt;T&gt;&#123; T create();&#125;class creater&lt;T&gt;&#123; T instance; public &lt;F extends Factory&lt;T&gt;&gt;T newInstance(F f)&#123; instance = f.create(); return instance; &#125;&#125;class IntegerFactory implements Factory&lt;Integer&gt;&#123; @Override public Integer create()&#123; Integer integer = new Integer(9); return integer &#125;&#125;创建泛型数组一般不建议创建泛型数组，尽量使用ArrayList来代替泛型数组。五、Java泛型的通配符上界通配符&lt;? extends T&gt;:只适合频繁读取的场景，例：1234class Food&#123;&#125;class Fruit extends Food&#123;&#125;class Apple extends Fruit&#123;&#125;class Banana extends Fruit&#123;&#125;在上面这个层次，可以用Plate&lt;? extends Fruit&gt;,无法存放，因为编译器只知道容器里存放的是Fruit和它的派生类，不知道具体类，但是可以进行读取操作。下界通配符&lt;? super T&gt;:不影响往里面存储，但是读取出来的数据只能是Object类型，里面存储的都是T及其基类，无法转换成任何一种类型，只能转换成Object基类才能放下。&lt;?&gt;无限通配符无界通配符修饰的容器持有的是某种具体的类型。举个例子，在List&lt;？&gt;类型的引用中，不能向其中添加Object，而在List类型的引用中，可以添加Object对象。PECS原则：上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP/HTTPS]]></title>
    <url>%2Fhttp%E5%92%8Chttps.html</url>
    <content type="text"><![CDATA[一、什么是HTTP和HTTPS？HTTP：超文本传输协议，所有的www文件都必须遵守这个标准，互联网上应用最广泛的一种网络协议。HTTPS:是以安全为目标的HTTP通道，简单来说就是HTTP的安全办，即HTTP下加入SLL层，HTTPS的安全基础是SLL，因此加密的详细内容就需要要SSL。主要作用：建立一个信息安全通道，保证数据安全；确定网站真实性。二、两者区别http免费试用，https协议需要ca申请证书，一般免费证书很少，需要交费。http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。http和https使用的完全不一样的端口，前者是80，后者是443。http的连接很简单，是无状态的。https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。三、HTTPS工作流程客户端使用https的URL访问Web服务器，要求与Web服务器建立SSL连接；Web服务器接收客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端；客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级；客户端浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站；Web服务器利用自己的私钥解密会话密钥；Web服务器利用会话密钥加密与客户端之间的通信。四、一句话总结HTTPSHTTPS要使客户端与服务器端的通信过程得到安全的保证。必须使用对称加密，但是协商对称密钥的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身就不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这种机制协商出一个对称加密算法，之后双方再使用该算法进行加解密，从而解决了客户端与服务端之间的通信安全问题。五、常见问题TLS和SLL的区别？TLS可以理解成SSL协议3.0版本的升级，所以TLS的1.0版本也被标识为SSL3.1版本。什么是对称加密和非对称加密？对称加密：最快速、最简单的加密方式，加密与解密同样的密钥，这种方法在密码学中叫做对称加密算法。最大缺点是密钥的管理和分配，在发送密钥的过程中，密钥有很大的风险会被黑客拦截。通常做法是将对称加密的密钥进行非对称加密，然后传输给需要他的人。非对称加密：为数据加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥和私钥。私钥只能由一方保管，不能外泄，而公钥则可以发送给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发送给你，你使用公钥对数据加密，只有私钥的持有人银行才能对你的消息进行解密，安全性大大提高。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络安全]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.html</url>
    <content type="text"><![CDATA[一、黑客与安全黑客：攻击手段分为非破坏性攻击和破坏性攻击。非破坏型攻击：一般是为了扰乱系统的运行，使之暂时失去对外提供服务的能力，比如DDos攻击。破坏性攻击：主要会造成两种后果:系统数据收送或者信息被窃取，比如CSRF攻击。攻击手段有病毒式、洪水式、系统漏洞式。安全：互联网企业都要建立一套完整的信息安全体系，遵循CIA原则，即保密性、完整性、可用性。保密性：对需要保护的数据（例如用户的私人信息等）进行保密操作，无论是存储还是传输，都要保证用户数据及相关资源的安全。完整性：访问的数据需要是完整的，而不是缺失或者篡改的，必然用户访问的数据就是不正确的。可用性：服务必须是可用的。二、SQL注入SQL注入是注入式攻击中常见的类型，是未将代码与数据进行严格的隔离，导致在读取用户数据时候，错误的把数据作为代码的一部分执行，从而导致安全问题。常见案例：123var testCondition;testCondition = Request.from(&quot;testCondition&quot;)var sql = &quot;select * from TableA where id =&apos;&quot;+ testCondition +&quot;&apos;&quot;;上面例子，若果用户只输入ID是一个数字是没有问题的，但是如果用”;”隔开，在testCondition中插入其他SQL，则会带来意想不到的结果。如何预防？过滤用户输入参数中的特殊字符，从而降低被SQL注入的风险；禁止通过字符串凭借的SQL语句，严格使用参数绑定传入的SQL参数；合理使用数据库访问框架提供的防注入机制。例如Mybatis提供的#{} 绑定数据，从而防止SQL注入。同时谨慎使用${},${}相当于使用字符串拼接SQL，拒绝拼接的SQL语句，使用参数化的语句。三、XSS与CSRFXSS:跨站脚本攻击，指黑客通过技术手段，向正常用户请求的HTML页面中插入恶意的脚本，从而可以执行任意脚本,比如如下代码可能造成XSS漏洞12345&lt;div&gt;&lt;h3&gt;反射型xss示例&lt;h3&gt;&lt;br&gt;用户：&lt;%= request.getParameter(&quot;userName&quot;) %&gt;&lt;br&gt;系统错误信息：&lt;%= request.getParameter(&quot;errorMessage&quot;) %&gt;&lt;/div&gt;上面的代码从HTTP请求中获取了userName和errorMessage两个参数，并直接输出到HTML中展示，当黑客构造如下的URL时出现了反射型XSS1http://xss.demo/self-xss.jsp?userName= 张三&lt;script&gt;alert(&quot;张三&quot;)&lt;/script&gt;&amp;errorMessage=XSS示例&lt;script src=http://hacker.demo/xss-script.js /&gt;防范措施：使用Jsonp框架对用户输入字符串做XSS过滤；使用框架的工具类对用户输入的字符串做HTML转义，例如Spring提供的HtmlUtils；前端展示数据时使用innerText而不是innerHTML。CSRF：跨站请求伪造，在用户不知情的情况下，冒用用户发起请求，在当前已经登录的Web应用上执行恶意操作，如恶意发帖，修改密码等。比如某用户A登录了网上银行，这时黑客给他发了一条连接如下：1https//net_bank.demo/transfer.do?targetAccount=12345&amp;amount=100如果用户在打开网银的浏览器中点开了黑客发送的URL,那么就有可能给黑客转账100元。防范措施：CSRF Token验证，利用浏览器的同源限制，在HTTP接口执行前验证页面或者Cookie中设置的Token，只有验证通过才能继续执行请求；人机交互，比如在调用网上银行转账时校验短信验证码。四、两者差别XSS是在正常用户请求的HTML页面中执行了黑客提供的恶意代码；CSRF是黑客直接盗用浏览器中的登录信息，冒充用户去执行黑客指定的操作。XSS问题出在用户数据没有过滤、转义；CSRF问题出现在HTTP接口没有防范不受信任的调用。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是TCP/IP]]></title>
    <url>%2FTCP-IP.html</url>
    <content type="text"><![CDATA[一、网络协议TCP/IP :中文翻译为传输控制协议，通常有4层协议：应用层、传输层、网络层、链路层。链路层：主要有IEEE 802.x/PPP 等，以字节为单位把0与1进行分组，定义数据帧，写入源和目标机器的物理地址、数据、校验位来传输数据。网络层：主要有IP/APR等，根据IP定义网络地址，区分网段。子网内根据地址解析协议（ARP）进行MAC寻址，子网外进行路由转发数据包，这个数据包即为IP数据包。传输层：主要有TPC/UDP等，数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份，把数据包交给应用程序，实现端口与端口间的通信。应用层：主要有HTTP/FTP/SMTP等，传输层的数据到达应用程序后，以某种统一规定的协议格式解读数据。二、IP协议IP协议是面向无连接、无状态、没有额外的机制保证发送的包是否有序到达。是TCP/IP的基石，几乎所有其他协议都是建立在IP所提供的服务基础上进行传输，其中包括在实际应用中用于传输稳定有序数据的TCP。三、TPC建立链接传输控制协议。是一种面向连接、确保数据在端与端之间可靠传输的协议。三次握手:A机器发出一个数据包并将SYN置1，表示希望建立连接；B机器收到A机器发过来的数据包，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置为1。假设这个包中的序列号是y，而确认序列号必须是x+1，表示收到了A发过来的SYN，在TCP中，SYN被当做数据部分的一个字节；A收到B的响应包后进行确认，确认包中将ACK置为1，并将确认序列号置为y+1，表示收到来自B的SYN。目的： 信息对等，防止超时。四、TCP断开连接四次挥手：A机器想要关闭连接，则待本方数据发送完毕之后，传递FIN信号给B机器；B机器应答ACK，告诉A机器可以断开，但是要等B机器处理完数据，再主动给A机器发送FIN信号，此时A机器处于半关闭状态，无法发送新的数据；B机器做好链接关闭的准备后，发送FIN信号给A机器，此时B机器也进入半关闭状态；A机器发送针对B机器FIN的ACK后，进入TIME-WAIT状态，经过2MSL后，没有收到B发送的报文，则确定B机器已经收到A机器最后发送的ACK命令，此时TCP正式释放。五、常见问题1. TCP和UDP区别？TCP:面向连接点到点通信高可靠性占用系统资源多、效率低利用IO流实现数据的传输响应式请求UDP:非面向连接，传输不可靠，可能丢失发送不管对方是否准备好，接受到也不确认可以广播发送非常简单的协议，开销小效率高，不用IO流实现数据的传输2. 为什么连接的时候是三次握手，断开的时候是四次挥手？当服务端收到客户端的连接请求报文时，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的，但是关闭连接时候，当服务端收到FIN报文时，不会立刻关闭SOCKET，只能先回复一个ACK报文，告诉客户端你的FIN报文收到了，只有等我服务端所有的报文发送完，我才能发送FIN报文，因此不能一次发送，需要四步。3.为什么不用两次握手链接？容易发生死锁，客户端在服务端的应答分组在传输中被丢失的情况下，将不知道服务端是否准备好，不知道服务端建立什么样的序列号，在这种情况下，客户端认为链接还未建立，将忽略服务端发来的任何数据分组，只能等待链接确认才应答f分组，而服务端发出的分组超时后，重复发送同样的分组，这样就行成了死锁。4.为什么TIME-WAIT状态需要经过2MSL才能返回到Close状态？按照道理来说，四个报文发送完毕，我们可以直接进入CLOSE状态，但是我们假象网络是不可靠的，有可能最后一个ACK丢失，所以TIME-WAIT状态是用来重发可能丢失的ACK报文。在客户端发送出最后的ACK回复，但该ACK可能丢失，服务端如果没有收到ACK，则不断的发送FIN片段，所以客户端不能立即关闭，它必须确认客户端收到了该ACK，此时设置了一个定时器，如果直到2MSL，客户端都没有收到FIN，则推断ACK已经成功被接收，关闭连接。5.如果已经建立了连接，但是客户端突然出现故障怎么办？TPC设有一个保活计时器，服务端每次接收到请求都会重新复位这个计时器，时间通常是2小时，若2小时没有收到客户端的任何数据，则服务端会发送一个探测报文段，以后每隔75秒发送一次，若一连发送10个探测报文都没有反应，则认为客户端发生故障，关闭连接。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走进JVM]]></title>
    <url>%2F%E8%B5%B0%E8%BF%9BJVM.html</url>
    <content type="text"><![CDATA[一、字节码源码转化成字节码过程：Java源文件-&gt;词法解析-&gt;语法解析-&gt;语义分析-&gt;生成字节码二、类加载过程Java的类加载器是一个运行时核心基础设施模块，主要是在启动之初进行类的Load、Link和Init，即加载、链接、初始化。第一步，Load阶段读取类文件产生二进制流，并转化为特定的数据结构，初步校验cafe babe魔法数、常量池、文件长度、是否有父类，然后创建对应类的java.lang.Class实例。第二步，Link阶段包括验证、准备解析三个步骤。验证是更详细的校验，比如final是否合规、类型是否准确静态变量是否合理、准备阶段是为静态变量分配内存，并设定默认值，解析类和方法确保类与类之间的项目引用准确性，完成内存结构布局。Init阶段执行类构造器方法，如果赋值与那算是通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值。三、自定义加载器与双亲委派模型什么是双亲委派模型？如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有的那个父加载类在自己的搜索范围内找不到指定的类时，自加载器才会尝试自己去加载。自定义类加载器loadClass默认实现如下：123public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false);&#125;再看看loadClass(String name, boolean resolve)函数：12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125;从上面面代码可以明显看出，loadClass(String,boolean)函数即是实现了双亲委派模型，大致过程如下：首先、检查一下指定名称的类是否已经加载过了，如果加载过了，就不需要加载，直接返回。如果此类没有加载过，那么，再判断下是否有父加载器；如果有，则由父加载器加载，或者调用bootstrap类加载器加载。如果父加载器及bootstrap类加载器都没有找到指定的类，则调用当前类findClass方法来完成类加载。换句话说，如果要自定义类加载器，就必要要重写findClas方法。默认实现如下：123protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException&#123; throw new ClassNotFoundException(name);&#125;若果是读取一个指定的名称的类为字节数组，则使用defineClass转换成Class对象，默认实现如下：1234protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError &#123; return defineClass(name, b, off, len, null);&#125;函数调用过程：开始-&gt;loadClass-&gt;父类加载器是否返回Class对象？是的话直接返回，否-&gt;findClass-&gt;根据名称读取文件存入字节数组-&gt;defineClas-&gt;返回Clas对象。四、内存布局主要有类加载子系统、java栈、方法区、Java堆、直接内存、本地方法栈、垃圾回收机制、PC寄存器、执行引擎。类加载系统和方法区：类加载系统负责从文件系统或者网络中加载class信息，加载的类信息存放在一块称为方法区的内存空间。除了类的信息外，方法区还有可能存放运行时常量池信息，包括字符串常量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）。Java堆：Java堆在虚拟机启动的时候建立，它是Java程序中最重要的内存工作区域。几乎所有的java对象实例都存放在java堆中。堆空间的所有线程是共享的，这是一块与java应用密切相关的内存空间。直接内存：java的NIO库允许java程序使用直接内存。直接内存是java堆外的，直接向系统申请的工作空间。通常访问直接内存的速度会优于java堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在java堆外，因此它的大小不会受限于xmx指定的最大堆大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。垃圾回收系统：垃圾回收系统是Java虚拟机的重要组成部分，垃圾回收器可以对方法区、java堆和直接内存进行回收。其中，java堆是垃圾收集器的工作重点。和C/C++不同，java中所有的对象空间释放都是隐式的，也就是说，java中没有类似free()或者delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默的查找，标识并释放垃圾对象，完成包括java堆，直接内存和方法区中全自动化管理。Java栈：每一个java虚拟机线程都有一个私有的java栈，一个线程的java栈在线程创建的时候被创建，java栈中保存着帧的信息，java栈中保存着局部变量、方法参数、同时和java方法的调用、返回密切相关。本地方法栈：本地方法栈和java栈非常类似，最大的不同在于java栈用于方法的调用，而本地方法栈则用于本地方法的调用，作为对java虚拟机的重要拓展，java虚拟机允许java直接调用本地方法（通常使用C编写）。PC寄存器：PC寄存器也是每一个线程私有的空间，java虚拟机会为每一个java线程创建PC寄存器。在任意时刻，一个Java线程总是在执行一个方法，这个正在执行的方法称为当前方法。如果当前方法不是本地方法，PC寄存器就会指向正在被执行的指令。如果当前方法是本地方法，那么PC寄存器的值就是undefined。执行引擎：执行引擎是Java虚拟机的最核心组件之一，它负责执行虚拟机的字节码文件，现代虚拟机为了提高执行效率，会使用即时编译技术将方法编译成机器码后执行。五、垃圾回收分代策略JVM内存分代策略Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对HotSpot虚拟机而言），这就是JVM内存分代策略。为什么要分代？堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收机制最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中，给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾回收，而每次回收都要遍历所有对象，遍历这些对象所花费的时间代价是巨大的，会严重我们的GC效率，这简直太可怕了。有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经历过多次回收任然存活下来的对象存放在老年代中，静态属性，类信息存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收的效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾回收算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。内存分代划分Java虚拟机将堆内存划分为新生代、老年代和永久代，永久代是HotSpot虚拟机特有的概念，它采用永久代的方式来实现方法区，其他的虚拟机实现没有这一个概念，而且HotSpot也有取消永久代的趋势，在JDK1.7中HotSpot已经开始去“永久化”，把原本放在永久代的字符串常量池移出。永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。新生代新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，回收效率很高。HoSpot将新生代划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例是8：1：1。划分的目的是因为HotSpot采用主从复制算法来回收新生代，设计这个比例是为了充分利用内存空间，减少浪费。新生成的对象在Eden区分配（大对象除外，大对象直接进入老年代），当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的（作为保留区）。GC进行时，Eden区所有存活的对象都会被复制到To Survivor区，而在From Survivor区中，任然存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认是15，新生代中的对象每熬过一次垃圾回收，年龄值就加一，GC分代年龄储存在对象的header中）的对象就会被移到老年区，没有达到阀值的对象都在To Survivor区。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区，接着From Survivor区和To Survivor区会交换他们的角色，不管怎样都会保证To Survivor区在一轮GC后是空的。GC时当To Survivor区没有足够的空间存放上一次新生代收集下来的存活对象，需要依赖老年代进行分配担，将这些对象放在老年代区。老年代在新生代中经历了多次GC后任然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，在老年代中进行GC的频率相对而言较低，而且回收的速度较慢。永久代永久代存储类信息、常量、静态变量、即时编译器编译之后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾回收收集，一般而言不会进行垃圾回收。回收算法引用计数法比较古老的算法，原理是此对象有一个引用，既增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象，此算法最致命的是无法处理循环引用的问题。复制*此算法把内存空间分配成两个相等的区域，每次只使用其中的一个区域。垃圾回收时，遍历当前的使用区域，把正在使用的对象复制在另一个区域中，算法每次只处理正在使用中的对象，因此复制都成本较小，同时复制过去还能进行相应的内存整理，不会出现“碎片”问题，当然，此算法的缺点也是很明显的，就是需要两倍的内存空间。标记-清除此算法执行分两阶段，第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。标记-整理此算法整合了“标记-清除”和“复制”两个算法的优点，也是分两个阶段，第一个阶段从根节点开始标记所有被引用的对象，第二个阶段遍历整个堆，清除未标记的对象并且把存活的对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了”复制“算法的空间问题。垃圾回收器Scavenge GC（次收集）和Full GC的区别（全收集）新生代GC（Scavenge GC）：指发生在新生代的GC，因此新生代的Java对象大多都是朝生夕死，所以Scaveng GC非常频繁，一般回收速度也比较快。当Eden空间不足以为对象分配内存时，会触发Scavenge GC。老年代GC（Full GC/Major GC）：Full GC指发生在老年代的GC，出现了Full GC一般都伴随着至少一次的Minor GC（老年代的对象大部分是Minor GC过程中从新生代进入老年代），比如：分配担保失败，Full GC的速度一般会比Minor GC慢10倍以上。当老年代内存不足或者显式调用System.gc()方法时，会触发Full GC。次收集当年轻的空间紧张时会被触发相对于全收集来说，收集间隔较短全收集当老年代或者持久代堆空间满了，会触发全收集操作可以使用System.gc()方法来显式的启动全收集全收集一般根据堆大小的不同，需要的时间不尽相同，但是一般会比较长，不过，如果全收集时间超过了3到5秒钟，那就太长了。新生代收集器串行收集器（Serial）Serial收集器HotSpot运行在client模式下默认的新生代收集器，它的特点是只有一个cpu/一条收集线程去完成GC工作，且在进行垃圾收集时必须暂停其它所有的工作线程。新生代采用复制算法，老年代采用标记-整理算法。并行收集器（ParNew）ParNew是Serial的多线程版本，除了使用多线程进行GC之外，包括Serial可用的所有控制参数、收集算法、STW、对象分配规则、回收策略等都与Serial完全一样，由于存在线程切换的开销，ParNew在单cpu的环境中比不上Serial，但是随着线程的增加，效率会大大增加。新生代采用复制算法，老年代采用标记-整理算法。Parallel Scavenge收集器与ParNew类似，也是使用复制算法，也是并行多线程收集器，但与其他收集器关注尽可能缩短垃圾收集时间不同，Parallel Scavenge收集器更关注系统吞吐量。系统吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。停顿时间越短越适用于用户交互的程序，而高吞吐量则适用于后台运算而不需要太多交互的任务，可以最高效的利用cpu时间，尽快地完成程序的运算任务。老年代收集器erial Old收集器Serial Old是Serial收集器的老年代版本，同样是单线程收集器，使用标记-整理算法。Parallel Old收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法，吞吐量优先，主要是和Parallel Scavenge在注重吞吐量及cpu资源敏感系统内使用。CMS收集器CMS是一个具有跨时代的收集器，一款真正意义上的并发收集器，虽然已经有了理论意义上表现更好的G1收集器，但现在主流互联网企业线上仍然是CMS。CMS是一种以获取最短回收停顿时间为目标的收集器，又称为多并发低暂停的收集器，基于标记-清除算法实现，整个GC过程分为以下4个步骤：初始标记；并发标记；重新标记；并发清除。由于CMD采用标记-清除算法实现，可能会产生大量的内存碎片，内存碎片过多会导致无法分配大对象而提前触发Full GC，因此CMS提供了-xx：+UseCMSCompactAtFullCollection开关参数。用于在Full GC之后再执行一次碎片整理过程，但是内存整理是无法并发的，内存碎片问题虽然没有了， 但是停顿时间也因此变长了，因此CMS还提供了一个参数-xx：CMSFullGCsBeforeCompaction用于设置在执行N次不进行内存整理的Full GC后，跟着来一次带整理的。分区收集-G1收集器（Garbage-First）G1是一款面向服务端应用的收集器，主要目标用于配备多频cpu的服务器治理大内存–XX:+UseG1GC，启动G1收集与其他基于分代的收集器不同，G1将整个Java堆划分分为多个大小相等的独立区域，虽然还保留着新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
