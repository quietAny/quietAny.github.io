<!-- build time:Fri Aug 30 2019 16:32:48 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="mysql,"><link rel="alternate" href="/atom.xml" title="行川居" type="application/atom+xml"><meta name="description" content="一、为什么查询速度会慢如果把查询看作是是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数。通常来说，查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器时进行解析，生成执行计划，执行，并返回结果给客户端。”执行”是最重要的阶段，包括了大量为检索数据到存储引擎的调用以及调用后的数据"><meta name="keywords" content="mysql"><meta property="og:type" content="article"><meta property="og:title" content="20.高性能MySQL(六)"><meta property="og:url" content="http://www.xingchuan.vip/20.高性能MySQL(六).html"><meta property="og:site_name" content="行川居"><meta property="og:description" content="一、为什么查询速度会慢如果把查询看作是是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数。通常来说，查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器时进行解析，生成执行计划，执行，并返回结果给客户端。”执行”是最重要的阶段，包括了大量为检索数据到存储引擎的调用以及调用后的数据"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-08-16T03:08:12.678Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="20.高性能MySQL(六)"><meta name="twitter:description" content="一、为什么查询速度会慢如果把查询看作是是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数。通常来说，查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器时进行解析，生成执行计划，执行，并返回结果给客户端。”执行”是最重要的阶段，包括了大量为检索数据到存储引擎的调用以及调用后的数据"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"right",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!0,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.xingchuan.vip/20.高性能MySQL(六).html"><title>20.高性能MySQL(六) | 行川居</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><a href="https://github.com/quietAny"><img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1" style="float:right"></a><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">行川居</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook" rel="section"><i class="menu-item-icon fa fa-fw fa-comment"></i><br>留言板</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.xingchuan.vip/20.高性能MySQL(六).html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="川总"><meta itemprop="description" content><meta itemprop="image" content="http://5b0988e595225.cdn.sohucs.com/images/20171030/26ed195281334ba4b1752394b60eb29a.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="行川居"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">20.高性能MySQL(六)</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-07T21:36:00+08:00">2019-08-07 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/笔记/" itemprop="url" rel="index"><span itemprop="name">笔记</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/20.高性能MySQL(六).html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/20.高性能MySQL(六).html" itemprop="commentCount"></span> </a></span><span id="/20.高性能MySQL(六).html" class="leancloud_visitors" data-flag-title="20.高性能MySQL(六)"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数&#58;</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="一、为什么查询速度会慢"><a href="#一、为什么查询速度会慢" class="headerlink" title="一、为什么查询速度会慢"></a>一、为什么查询速度会慢</h3><blockquote><p>如果把查询看作是是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数。</p></blockquote><blockquote><p>通常来说，查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器时进行解析，生成执行计划，执行，并返回结果给客户端。”执行”是最重要的阶段，包括了大量为检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。</p></blockquote><blockquote><p>完成这些任务的时候，查询需要在不同的地方花费时间，包括网络、CPU计算，生成统计信息和执行计划，锁等待，还有内存操作、CPU操作和内存不足时导致I/O操作消耗时间。</p></blockquote><hr><h3 id="二、慢查询基础：优化数据访问"><a href="#二、慢查询基础：优化数据访问" class="headerlink" title="二、慢查询基础：优化数据访问"></a>二、慢查询基础：优化数据访问</h3><blockquote><p>大部分查询性能低下的原因是访问的数据太多，我们可以用下面两个步骤来分析：</p><blockquote><ul><li>确认应用程序是否在检索大量超过需要的数据。通常访问太多行，但有时候也可能是访问太多列。</li><li>确认MySQL服务层是否在分析大量超过需要的数据行。</li></ul></blockquote></blockquote><h4 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h4><h5 id="查询不需要的记录"><a href="#查询不需要的记录" class="headerlink" title="查询不需要的记录"></a>查询不需要的记录</h5><blockquote><ul><li>例如某新闻网站中取出100条记录，但是页面只显示10条，他们认为MySQL会执行查询，并返回10条数据，然后停止查询，实际情况是MySQL会查出所有结果集，客户端接收全部结果集，然后抛弃大部分数据，最有效的解决方法是在查询后面加LIMIT。</li></ul></blockquote><h5 id="多表联查时返回全部列"><a href="#多表联查时返回全部列" class="headerlink" title="多表联查时返回全部列"></a>多表联查时返回全部列</h5><blockquote><ul><li>例如：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * from a INNER JOIN B on a.id =  b.pid</span><br></pre></td></tr></table></figure><h5 id="总是取出全部列"><a href="#总是取出全部列" class="headerlink" title="总是取出全部列"></a>总是取出全部列</h5><blockquote><ul><li>尽量避免使用SELECT *。</li></ul></blockquote><h5 id="重复查询相同的数据"><a href="#重复查询相同的数据" class="headerlink" title="重复查询相同的数据"></a>重复查询相同的数据</h5><blockquote><ul><li>例如在用户评论的地方需要查询用户头像的URL，那么用户多次评论时候，可能会反复查询这个数据，比较好的方案是当初次查询时把数据缓存起来，需要的时候从缓存中取出。</li></ul></blockquote><h4 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h4><blockquote><p>在确定查询只返回需要的数据后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于MySQL，衡量查询的三个指标如下：</p><blockquote><ul><li>响应时间</li><li>扫描行数</li><li>返回行数<br>三个指标都会记录到MySQL的慢日志中，所以查询慢日志是找出扫描行数过多的查询的好办法。</li></ul></blockquote></blockquote><h5 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h5><blockquote><p>是两个部分之和：服务时间和等待时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间————可能是等I/O操作完成，也可能是等待行锁。</p></blockquote><blockquote><p>当你看到一个查询的响应时间时，先问问自己，这个时间是否在一个合理的值。</p></blockquote><h5 id="扫描的行数和返回的行数"><a href="#扫描的行数和返回的行数" class="headerlink" title="扫描的行数和返回的行数"></a>扫描的行数和返回的行数</h5><blockquote><p>分析查询时，查看该查询扫描的行数是非常有帮助的，理想情况下扫描的行数和返回的行数应该是相同的。实际情况这种情况并不多，在关联查询的时候，通常扫描和返回行数比位1:1-10：1之间。</p></blockquote><h5 id="扫描的行数和访问类型"><a href="#扫描的行数和访问类型" class="headerlink" title="扫描的行数和访问类型"></a>扫描的行数和访问类型</h5><blockquote><p>在EXPLAIN语句中type列反应了方位类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。速度从慢到快，扫描的行数也是从大到小。</p></blockquote><blockquote><p>如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引。</p></blockquote><blockquote><p>一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：</p><blockquote><ul><li>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</li><li>使用索引覆盖扫描来返回记录。直接从索引中过滤不需要的记录并返回命中的结果。</li><li>从数据表中返回数据，然后过滤不满足条件的记录。这在MySQL服务器层完成，需要先从数据表读出记录然后过滤。</li></ul></blockquote></blockquote><blockquote><p>如果发现查询需要扫描大量的数据但是只返回少数的行，那么通常可以尝试下面的技巧去优化它：</p><blockquote><ul><li>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对于行就额可以返回结果了。</li><li>改变库表结构。例如使用单独的汇总表。</li><li>重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。</li></ul></blockquote></blockquote><hr><h3 id="三、重构查询的方式"><a href="#三、重构查询的方式" class="headerlink" title="三、重构查询的方式"></a>三、重构查询的方式</h3><h4 id="一个复杂查询还是多个简单查询"><a href="#一个复杂查询还是多个简单查询" class="headerlink" title="一个复杂查询还是多个简单查询"></a>一个复杂查询还是多个简单查询</h4><blockquote><p>在传统实现中，总是强调数据层完成尽可能多的工作，但是有时候，将一个大查询分解为多个小查询是很有比较的。不弱在应用设计的时候，如果一个查询能够胜任还写成多个独立查询是不明智的。例如，我们看到有些应用对一个数据表做10次独立的查询来返回10行数据，每个查询返回一条结果，查询10次！</p></blockquote><h4 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h4><blockquote><p>对于一个大查询我们需要”分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分的查询结果。</p></blockquote><blockquote><p>删除旧数据就是很好的例子，如果使用一个大的语句一次完成的话，则需要一次锁住很多数据，沾满整个事务日志、耗尽系统资源，阻塞很多小的但很重要的查询。例如：我们每个月运行一次下面的查询：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM messages WHERE created &lt; DATE_SUB(NOW()，INTERVAL 3 MONTH);</span><br></pre></td></tr></table></figure><blockquote><ul><li>那么可以用下面的方法来完成同样的工作：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rows_affected = 0</span><br><span class="line">do&#123;</span><br><span class="line">    rows_affected = do_quert(</span><br><span class="line">        &quot;DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(),INTERVAL  3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">    ) where rows_affected &gt; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一次删除一万行是一个比较搞笑而且对服务器影响最小的做法。同事注意的是，每次删除数据之后，都暂停一会再做下一次删除，这样可以将服务器原来一次的压力分散到一个很长的时间段，就可以大大的降低对服务器的影响，还可以大大减少删除时对锁的持有时间。</p></blockquote><h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><blockquote><p>很多应用都会对关联查询进行分解，可以对每一个表进行一次单表查询，然后将结果在应用中关联。例如，下面这个查询：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT  * FROM tag</span><br><span class="line">    -&gt; JOIN tag_post ON tag_post.tag_id = tag.id</span><br><span class="line">    -&gt; JOIN post ON tag_post.post_id = post.id</span><br><span class="line">    -&gt; WHERE tag.tag = &apos;mysql&apos;;</span><br></pre></td></tr></table></figure><blockquote><p>可以分解为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT * FROM tag WHERE tag=&apos;mysql&apos;</span><br><span class="line">mysql&gt;SELECT * FROM tag_post WHERE tag_id = 1234;</span><br><span class="line">mysql&gt;SELECT * FROM post WHERE </span><br><span class="line">post.id in (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><blockquote><ul><li>让缓存效率更高，可以更方便地缓存单表查询对应的结果对象，比如上面查询的tag已经被缓存了，那么就可以跳过第一个查询，拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。</li><li>执行单个查询可以减少锁竞争。</li><li>做应用层管理，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。</li><li>查询本身效率会提示，上面例子中，使用IN()代替关联查询，可以让MySQL按照ID顺序进行查询。</li><li>减少冗余记录查询，意味着某条记录应用只需要查询一次，而在数据库关联，则可能需要重复地访问一部分数据。</li></ul></blockquote><hr><h3 id="四、查询执行的基础"><a href="#四、查询执行的基础" class="headerlink" title="四、查询执行的基础"></a>四、查询执行的基础</h3><blockquote><p>当向MySQL发送一个请求时，MySQL到底做了什么:</p><blockquote><ul><li>客户端发送一条查询给服务器。</li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li><li>服务端进行SQL解析，预处理，再由优化器生成对应的执行计划。</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。</li><li>将结果返回给客户端。</li></ul></blockquote></blockquote><h4 id="MySQL客户端-服务器通信协议。"><a href="#MySQL客户端-服务器通信协议。" class="headerlink" title="MySQL客户端/服务器通信协议。"></a>MySQL客户端/服务器通信协议。</h4><blockquote><p>协议是”半双工”的，意味着在任何时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，两个动作不能同时发生。</p></blockquote><h5 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h5><blockquote><p>对于一个MySQL连接，或者说一个线程，任何时刻都有一个状态，该状态表示了MySQL当前在什么。使用SOW FULL PROCESSLIST命令可以查看，主要有下面几种状态：</p><blockquote><ul><li>Sleep:<br>线程正在等待客户端发送新的请求。</li><li>Query:线程正在执行查询或者正在将结果返回给客户端。</li><li>Locked:在MySQL服务器层，该线程正在等待表锁</li><li>Analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划。</li><li>Copying to tmp table[on disk]:线程正在执行查询，并且将其结果集都复制到一个临时表，这种状态一般要么是在做GROUP BY操作，要么是文件排序操作，或者是UNION操作。如果后面还有”on disk”标记，那表示MySQL正在将一个内存临时表放到磁盘上。</li><li>Sorting result:线程正在对结果集进行排序。</li><li>Sending data:线程可能在多个状态之间传送数据，或者在生成接过戒，或者在向he护短返回数据。</li></ul></blockquote></blockquote><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><blockquote><p>在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。</p></blockquote><blockquote><p>这个检查是通过对一个大小写敏感的哈希查找实现的，即使有一个字节不同，都不会匹配缓存结果。</p></blockquote><blockquote><p>如果命中了缓存，在返回查询结果之前MySQL会检查一次用户权限，如果没有问题，MySQL会跳过其他所有阶段，直接从缓存中拿到结果返回到客户端。</p></blockquote><h4 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h4><blockquote><p>查询的下一步是将一个SQL转换成一个执行计划，MySQL再依照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析SQL、预处理、优化SQL执行计划，这个过程中出现任何错误都会终止查询。</p></blockquote><h5 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h5><blockquote><p>首先MySQL通过关键字将SQL语句进行解析，并生成一颗对应的”解析树”。使用MySQL语法规则验证和解析查询，比如验证是否使用错误的关键词，或者使用关键词的顺序是否正确，验证引号是否能前后正确匹配。</p></blockquote><blockquote><p>预处理器则根据一些MySQL规则进一步检查解析树是否合法。例如检查数据表和数据列是否存储在，还会解析名字和别名，看它们是否有歧义。</p></blockquote><h5 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h5><blockquote><p>作用是找出这其中最好的执行计划。有很多原因会导致MySQL优化器选择错误的执行计划：</p><blockquote><ul><li>统计信息不准确。</li><li>执行计划中的成本估算不等同于实际执行的成本。</li><li>MySQL的最优可能和你想的最优不一样。</li><li>MySQL从不考虑其他并发执行的查询，这可能会影响到当前查询的速度。</li><li>MySQL也并不是任何时候都是基于成本的优化。</li><li>MySQL不会考虑不受其控制的操作的成本，例如执行存储过程或者用户自定义函数的成本。</li></ul></blockquote></blockquote><blockquote><p>优化策略简单的分为两种，一种是静态优化，一种是动态优化。</p><blockquote><ul><li>静态优化：可以直接对解析树进行分析，并完成优化。例如可以通过一些简单的点出变换将WHERE条件转成另一种等价形式。静态优化不依赖于特别的数值，例如WHERE中带入的一些常数。在第一次完成后就一直有效，既是使用不同参数执行查询页不会发生变化。</li><li>动态优化：和查询的上下文有关，也可能和很多其他因素有关，例如WHERE条件中的取值，索引中条目对于的数据行数等。这需要在每次查询的时候重新评估。</li></ul></blockquote></blockquote><blockquote><p>下面是一些MySQL能够处理的优化类型：</p><blockquote><ul><li>重新定义关联表顺序</li><li>将外连接转化成内连接</li><li>使用等价变换规则</li><li>优化COUNT()、MIN()和MAX()</li><li>预估并转化为常数表达式</li><li>覆盖扫描索引</li><li>子查询优化</li><li>提前终止查询</li><li>等值传播</li><li>列表IN()的比较</li></ul></blockquote></blockquote><h5 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a>数据和索引的统计信息</h5><blockquote><p>因为服务器没有任何统计信息，索引MySQL查询优化器在生成查询的执行计划时，需要向存储引擎获取相应的统计信息。存储引擎则提供给优化器对于的统计信息。包括：每个表或者索引有多少个页面、每个表的索引的基数是多少、数据行和索引长度、索引的分布信息等。</p></blockquote><h5 id="MySQL如何执关联查询"><a href="#MySQL如何执关联查询" class="headerlink" title="MySQL如何执关联查询"></a>MySQL如何执关联查询</h5><blockquote><p>总的来说，MySQL任务任何一个查询都是一次”关联”————并不仅仅是一个查询需要到两个表匹配才叫关联。</p></blockquote><blockquote><p>MySQL执行策略很简单：对于任何关联都执行嵌套虚幻关联操作，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到索引表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。</p></blockquote><h5 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h5><blockquote><p>MySQL优化器最重要的一部分就是关联查询优化，它决定了多个表关联时的顺序。通常多表关联的时候，可以有多种不同的关联顺序来获得相同的执行结果。关联查询优化器则通过评估不同顺序时的成本来选择一个代价最小的关联顺序。</p></blockquote><h5 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h5><blockquote><p>两种排序算法</p><blockquote><ul><li>两次排序算法(旧版本使用)：读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。这里需要进行两次数据传输，即需要从数据表中读取两次数据，第二次读取数据的时候，因为是读取排序列进行排序后的所有记录，这会产生大量的随机I/O，所有两次数据传输的成本非常高。</li><li>优点：在排序的时候存储尽可能少的数据，这就让”排序缓冲区”中可能容纳尽可能多的行数进行排序。</li></ul></blockquote></blockquote><blockquote><blockquote><ul><li>单次传输排序：先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。</li><li>缺点：如果返回的列非常多、非常大、会额外占用大量的空间，而这些列对排序操作本身来说没有任何作用。因为单条排序记录很大，所以可能会有更多的排序块需要合并。</li></ul></blockquote></blockquote><h4 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h4><blockquote><p>在解析和优化阶段，MySQL将生产查询对于的执行计划，MySQL的查询执行引擎则根据这个执行计划来完成整个查询。</p></blockquote><h4 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h4><blockquote><p>最后一个阶段是将结果返回给客户端。如果查询可以被缓存，则会将MySQL在这个阶段也会将结果存放到查询缓存中。</p></blockquote><blockquote><ul><li>MySQL将结果集返回客户端是一个增量、逐步返回的过程。当开始生产第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。<blockquote><ul><li>服务端无需存储太多的结果。也就不会 因为要返回太多结果而消耗太多内存，另外，也让MySQL客户端第一时间获得返回的结果。</li></ul></blockquote></li></ul></blockquote><hr><h3 id="五、MySQL查询优化器的局限性"><a href="#五、MySQL查询优化器的局限性" class="headerlink" title="五、MySQL查询优化器的局限性"></a>五、MySQL查询优化器的局限性</h3><h4 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h4><blockquote><p>MySQL会将相关的外层表压倒子查询中，它认为这样可以更高效地查询到数据行。</p></blockquote><h4 id="UNION的限制"><a href="#UNION的限制" class="headerlink" title="UNION的限制"></a>UNION的限制</h4><blockquote><p>无法限制调教从外层”下推”到内层，这使得原本能够限制部分返回的结果的条件应用到内层查询的优化上。</p></blockquote><blockquote><p>例如：如果想将两个子查询结果联合起来，然后再取前20条记录，那么MySQL会将两个表都存放到同一个临时表中，然后再取出前20行记录：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(SELECT first_name,last_name</span><br><span class="line">FROM sakila.actor ORDER BY last_name) </span><br><span class="line">UNION ALL </span><br><span class="line">(SELECT first_name,last_name </span><br><span class="line">FROM sakila,customer ORDER BY last_name) </span><br><span class="line">LIMIT 20;</span><br></pre></td></tr></table></figure><blockquote><p>这条查询将会把actor中的200条记录和customer表中的599条记录存放在一个临时表，然后再从临时表中取出前20条。可以通过在UNION的两个子查询中分别加上一个LIMIT 20来减少临时表中的数据：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(SELECT first_name,last_name</span><br><span class="line">FROM sakila.actor ORDER BY last_name </span><br><span class="line">LIMIT 20) </span><br><span class="line">UNION ALL </span><br><span class="line">(SELECT first_name,last_name </span><br><span class="line">FROM sakila,customer ORDER BY last_name</span><br><span class="line">LIMIT 20) </span><br><span class="line">LIMIT 20;</span><br><span class="line">#### 索引合并优化</span><br><span class="line">&gt; 当WHERE子句中包含多个复杂条件的时候，MySQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行。</span><br></pre></td></tr></table></figure><h4 id="等值传递"><a href="#等值传递" class="headerlink" title="等值传递"></a>等值传递</h4><blockquote><p>会带来一些意想不到的额外消耗。例如，有一个非常大的IN()列表，而MySQL优化器发现存在WHERE、ON或者USING的子句，将这个列表的值和另一个表的某个列相关联。</p></blockquote><h4 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h4><blockquote><p>MySQL无法利用多核特性来并行执行查询。</p></blockquote><h4 id="哈希关联"><a href="#哈希关联" class="headerlink" title="哈希关联"></a>哈希关联</h4><blockquote><p>MySQL并不支持哈希关联，不过可以通过建立一个哈希索引来曲线的实现哈希关联。如果使用的是Memry存储引擎，则所有都是哈希索引，所以关联的时候也类似于哈希关联。</p></blockquote><h4 id="松散索引扫描"><a href="#松散索引扫描" class="headerlink" title="松散索引扫描"></a>松散索引扫描</h4><blockquote><p>假如我们有如下索引(a,b)，有下面的查询：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT ... FROM tb1 WHERE b BETWEEN 2 AND 3;</span><br></pre></td></tr></table></figure><blockquote><p>因为索引的前导字段是列a,但是在查询中只指定了字段b，MySQL无法使用这个索引，只能通过全表扫描找到匹配的行。</p></blockquote><h4 id="最大值和最小值优化"><a href="#最大值和最小值优化" class="headerlink" title="最大值和最小值优化"></a>最大值和最小值优化</h4><blockquote><p>对于MIN()和MAX()查询，MySQL的优化做的并不好，例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT MIN(actor_id)FROM sakila.actor WHERE first_name = &apos;PENELOPE&apos;;</span><br></pre></td></tr></table></figure><blockquote><p>因为咋first_name字段上并没有索引，因此MySQL读到第一个满足条件的记录的时候，就不是外貌需要找的最小值了。但是主键是严格按照actor_id字段的大小顺序排列的。但是MySQL这只会做全表扫描。一个曲线的优化方法是移除MIN(),然后使用LIMIT来将查询重写如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT actor_id FROM sakila.actor USER INDEX(PRIMARY)</span><br><span class="line">    -&gt;WHERE first_name = &apos;PENELOPE&apos; LIMIT 1;</span><br></pre></td></tr></table></figure><hr><h3 id="六、优化特定类型的查询"><a href="#六、优化特定类型的查询" class="headerlink" title="六、优化特定类型的查询"></a>六、优化特定类型的查询</h3><h4 id="优化COUNT-查询"><a href="#优化COUNT-查询" class="headerlink" title="优化COUNT()查询"></a>优化COUNT()查询</h4><h5 id="COUNT-的作用："><a href="#COUNT-的作用：" class="headerlink" title="COUNT()的作用："></a>COUNT()的作用：</h5><blockquote><ul><li>统计某个列的数量，要求列值是非空的。</li><li>统计行数，当MySQL确认括号内的表达式不可能为空时，实际上就是在统计行数。</li></ul></blockquote><h5 id="关于MyISAM的神话"><a href="#关于MyISAM的神话" class="headerlink" title="关于MyISAM的神话"></a>关于MyISAM的神话</h5><blockquote><ul><li>一个容易产生的误解：MyISAM的COUNT()函数非常快，不过这是有前提条件的，即没有WHERE条件的COUNT(*)才非常快。当图片吗个抠带WHERE子句的结果集行数，可以是统计某个列值的数量时，MyISAM的COUNT()和其他存储引擎没有任何不同。</li></ul></blockquote><h5 id="简单的优化"><a href="#简单的优化" class="headerlink" title="简单的优化"></a>简单的优化</h5><blockquote><p>有时候可以通过使用MyISAM在COUNT(*)全表非常快的这个特性，来加速一些特定条件的COUNT()的查询。例如下面例子中，我们要获得所有ID大于5的城市：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT COUNT(*) FROM world.City WHERE ID &gt; 5;</span><br></pre></td></tr></table></figure><blockquote><p>需要查询4097行数量。如果将条件反转下，先查询ID小于5的城市，然后用总城市数一减就能得到相同的结果，却能让扫描的行数减少到5行内。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT (SELECT COUNT(*) FROM world.City)-COUNT(*)</span><br><span class="line">    -FROM world.City WHERE ID &lt;= 5;</span><br></pre></td></tr></table></figure><h5 id="使用近似值"><a href="#使用近似值" class="headerlink" title="使用近似值"></a>使用近似值</h5><blockquote><p>有些业务场景并不需要完全精确的COUNT值，此时可以用近似值来代替，例如统计当前活跃用户数是多少，这个活跃用户数保存在缓存中，过期时间为30分钟，所以每隔30分钟需要重新计算放入缓存，因此这个活跃用户数本身就不是精确值。</p></blockquote><h5 id="更复杂的优化"><a href="#更复杂的优化" class="headerlink" title="更复杂的优化"></a>更复杂的优化</h5><blockquote><p>除了前面的方法，在MySQL层面上还能做的就是索引覆盖扫描。如果这还不够，就需要考虑修改应用的架构，可以增加汇总表。</p></blockquote><h4 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h4><blockquote><ul><li>确保ON或者USING子句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表A和表B用列c关联的时候，如果优化器的关联顺序是B、A，那么就不需要在B表的对应列上建上索引。没有用到的索引只会带来额外的负担。</li><li>确保任何的GROUP BY和ORDER BY中国的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。</li><li>当升级MySQL的时候需要注意：关联语法、运算符优先级等其他可能会发生变化的地方。</li></ul></blockquote><h4 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h4><blockquote><p>尽可能的使用关联查询来代替</p></blockquote><h4 id="优化GROUP-BY和DISTINCT"><a href="#优化GROUP-BY和DISTINCT" class="headerlink" title="优化GROUP BY和DISTINCT"></a>优化GROUP BY和DISTINCT</h4><blockquote><p>很多情况下。MySQL优化器都会使用索引来优化，如果无法使用索引的时候，GROUP BY使用两种策略来完成：使用临时表或者文件排序来做分组。</p></blockquote><blockquote><p>如果需要对关联查询做分组，并且按照查找表中的某个列进行分组，那么铜牛广场采用查找表的标识符列分组的效率会比其他列更高。例如下面的查询效率不会很好</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT actor.first_name,actor.last_name,COUNT(*)</span><br><span class="line">    -&gt; FROM sakila.film_actor</span><br><span class="line">    -&gt;  INNER JOIN sakila.actor USING(actor_id)</span><br><span class="line">    -&gt;GROUP BY actor.first_name,actor.last_name;</span><br></pre></td></tr></table></figure><blockquote><p>如果查询按照下面的写法效率则会更高：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT actor.first_name,actor.last_name,COUNT(*)</span><br><span class="line">    -&gt; FROM sakila.film_actor</span><br><span class="line">    -&gt;  INNER JOIN sakila.actor USING(actor_id)</span><br><span class="line">    -&gt;GROUP BY film_actor.actor_id;</span><br></pre></td></tr></table></figure><h5 id="优化GROUP-BY-WITH-ROLLUP"><a href="#优化GROUP-BY-WITH-ROLLUP" class="headerlink" title="优化GROUP BY WITH ROLLUP"></a>优化GROUP BY WITH ROLLUP</h5><blockquote><p>分组查询的一个变种就是要求MySQL对返回的分组结果再做一次超级聚合，可以使用WITH ROLLUP子句来实现这种逻辑，但可能会不够优化。尽可能的将WITH ROLLUO功能转移到应用程序中处理。</p></blockquote><h4 id="优化LIMIT分页。"><a href="#优化LIMIT分页。" class="headerlink" title="优化LIMIT分页。"></a>优化LIMIT分页。</h4><blockquote><p>通常使用LIMIT加上偏移量的办法实现，同时加上合适的ORDER BY子句。如果有对应的索引，通常效率会不错。但是如果偏移量非常大的时候，例如LIMIT 1000,20这样的查询，这时候MySQL需要查询10029条记录然后只返回最后20条，前面10000条记录都会被抛弃，这样代价非常高。优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。</p></blockquote><blockquote><p>优化此类分页查询最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。考虑如下查询：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT film_id,description FROM sakili.film ORDER BY title LIMIT 50,5;</span><br></pre></td></tr></table></figure><blockquote><p>如果这个表非常大，那么这个查询最好改写成下面的样子：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT film.film_id,film,description</span><br><span class="line">    -&gt; FROM sakila.film</span><br><span class="line">    -&gt;  INNER JOIN(</span><br><span class="line">    -&gt;      SELECT film_id FROM sakila.film </span><br><span class="line">    -&gt;      ORDER BY title LIMIT 50,5</span><br><span class="line">    -&gt;  ) AS lim USING(film_id);</span><br></pre></td></tr></table></figure><blockquote><p>这里的”延迟关联”将大大提升查询效率它让MySQL扫描尽可能少的页面，获得要访问的记录然后再更加关联列回原表查询需要的所有列。</p></blockquote><blockquote><p>有时候也可以将LIMIT查询转换为已知位置的查询，让MySQL通过范围扫描获得到对于的结果。例如，如果在一个位置列上有索引，并且预先计算出边界值，上面的查询就可以改为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT film_id,description FROM sakila.film</span><br><span class="line">    -&gt; WHERE postion BETWEEN 50 AND 54 ORDER BY postion;</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET。</li></ul></blockquote><h4 id="优化-SQL-CALC-FOUND-ROWS"><a href="#优化-SQL-CALC-FOUND-ROWS" class="headerlink" title="优化 SQL_CALC_FOUND_ROWS"></a>优化 SQL_CALC_FOUND_ROWS</h4><blockquote><p>将具体页数转换成”下一页”按钮，假设每页显示20条记录，那么我们每次查询都用LIMIT返回21条记录并只显示20条，如果21条存在，那么我们就显示”下一页”按钮，否则就说明没有更多的数据，也就无须显示”下一页”按钮了。</p></blockquote><blockquote><p>另一种方法就是获取并缓存较多的数据，例如，缓存1000条数据，然后每次分页都从这个缓存中获取，就可以让应用程序根据结果集的大小采取不同的策略，如果结果集少于1000，就可以在页面上显示所有的分页连接，因为数据都是在换乘站，所以这样的性能不会用问题。</p></blockquote><h4 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h4><blockquote><p>MySQL总是创建并填充临时表的方式来执行UNION查询，因此很多优化策略在UNION查询中没法很好地使用。</p></blockquote><blockquote><p>除非区呃呃是需要服务器消除重复的行，否则就一定要使用UNION ALL，这一点很重要。如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项，这会导致对整个临时表的数据做唯一性检查。这样做的代价非常高。即使有ALL关键字，MySQL仍然会使用临时表存储结果。事实上，MySQL总是很结果放入临时表，然后再读出，再返回给客户端。</p></blockquote><h4 id="静态查询分析"><a href="#静态查询分析" class="headerlink" title="静态查询分析"></a>静态查询分析</h4><blockquote><p>Percona Toolkit中的pt-query-advisor能够解析查询日志、分析查询模式，然后给出所有可能存在潜在问题的查询，并给出足够详细的建议。</p></blockquote><h4 id="使用用户自定义变量"><a href="#使用用户自定义变量" class="headerlink" title="使用用户自定义变量"></a>使用用户自定义变量</h4><blockquote><p>是一个用来存储内容的临时容器，在连接MySQL的整个过程中都存在。可以使用下面的SET和SELECT语句来定义它们：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET @one       :=1;</span><br><span class="line">mysql&gt; SET @min_actor :=(SELECT MIN(actor_id) FROM sakila.actor)；</span><br><span class="line">mysql&gt; SET @last_week := CURRENT_DATE-INTERVAL 1 WEEK;</span><br></pre></td></tr></table></figure><blockquote><p>然后可以再任何可以使用表达式的地方使用这些自定义变量：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT ...WHERE col &lt;= @last_week;</span><br></pre></td></tr></table></figure><h5 id="下面情况无法使用自定义变量"><a href="#下面情况无法使用自定义变量" class="headerlink" title="下面情况无法使用自定义变量"></a>下面情况无法使用自定义变量</h5><blockquote><ul><li>使用自定义变量的查询，无法使用查询缓存。</li><li>不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名和LIMIT子句中。</li><li>用户自定义变量的生命周期是在一个链接中有效，所有不能用它们来做连接间的通信。</li><li>如何使用连接池或者持久化连接，自定义变量可能让看起来毫无关系的代码发生交互。</li><li>不能显式地声明自定义变量的类型。确定未定义变量的具体类型的时机在不同MySQL版本中也可能不一样。如果你希望变量是整数类型，那么最好在初始哈的时候就赋值为0，如果希望是浮点型则赋值为0.0，如果希望是字符串则赋值’’,用户自定义变量的类型在赋值的时候会改变。</li><li>MySQL优化器在某些场景下可能会将这些变量优化掉，这可能会导致代码不按预想的方式运行。</li><li>赋值的顺序和赋值的时间点并不总是固定的，这依赖于优化器的决定。</li><li>赋值符号:=的优先级非常低，所有需要注意，赋值表达式应该使用明确的括号。</li><li>使用未定义变量不会产生任何语法错误。</li></ul></blockquote><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><blockquote><ul><li>查询运行时计算总数和平均值。</li><li>模拟GROUP语句中的函数FIRST()和LAST()。</li><li>对大数据做一些数据计算。</li><li>计算一个大表的MD5散列值。</li><li>编写一个样本处理函数，当样本中的数值超过某个边界值的时候将其变成0。</li><li>模拟读/写游标。</li><li>在SHOW语句的WHERE子句中加入变量值。</li></ul></blockquote><hr><h3 id="七、案例学习"><a href="#七、案例学习" class="headerlink" title="七、案例学习"></a>七、案例学习</h3><h4 id="使用MySQL构建一个队列表"><a href="#使用MySQL构建一个队列表" class="headerlink" title="使用MySQL构建一个队列表"></a>使用MySQL构建一个队列表</h4><blockquote><p>是一种取巧的做法。典型的模式是一个表包含多种类型的记录；未处理记录、已处理记录、正在处理记录等。一个或多个消费者线程在表中查找未处理的记录，然后声称正在处理，当处理完后，再将记录更新成已处状态。</p></blockquote><blockquote><p>通常有两个原因认为这样的处理方式并不合适。</p><blockquote><p><strong>第一</strong> :随着队列表越来越大和索引深度的增加，找到未记录的速度会随之变慢，可以通过将队列表分成两个部分来解决这个问题，就是将已处理记录归档或者存放到历史表。这可以始终保证队列表很小。<br><strong>第二</strong> :一般的处理过程分两步，先找到未处理记录然后加锁。找到记录会增加服务器压力，而加锁操作则会让各个消费者进程增加竞争，因为这是一个串行化的操作。</p></blockquote></blockquote><h5 id="基础原则："><a href="#基础原则：" class="headerlink" title="基础原则："></a>基础原则：</h5><blockquote><ul><li>尽量少做事，可以的话不要做任何事情，除非不得已。否则不要使用轮询，因为这会增加负担。</li><li>尽可能地完成需要做的事情。尽量使用UPDATE代替先SELECT FOR UPDATE再UPDATE的写法，因为事务提交的速度越快，持有的锁时间就越短，保证数据集足够小。</li><li>某些查询是无法优化的；考虑使用不同的查询或者不同的策略去实现相同的目的。</li></ul></blockquote><blockquote><p>有时，最好的办法就是将任务队列从数据库中迁移出来。Redis就是一个很好的队列容器，也可以使用memcached来实现。</p></blockquote></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">------------本文结束------------</div></div></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script><script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script><link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"><p><span>本文标题:</span>20.高性能MySQL(六)</p><p><span>文章作者:</span>川总</p><p><span>发布时间:</span>2019年08月07日 - 21:36:00</p><p><span>最后更新:</span>2019年08月16日 - 11:08:12</p><p><span>原始链接:</span><a href="/20.高性能MySQL(六).html" title="20.高性能MySQL(六)">http://www.xingchuan.vip/20.高性能MySQL(六).html</a> <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://www.xingchuan.vip/20.高性能MySQL(六).html" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");clipboard.on("success",$(function(){$(".fa-clipboard").click(function(){swal({title:"",text:"复制成功",html:!1,timer:500,showConfirmButton:!1})})}))</script></div><footer class="post-footer"><div class="post-tags"><a href="/tags/mysql/" rel="tag"># mysql</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/18.高性能MySQL(四).html" rel="next" title="18.高性能MySQL(四)"><i class="fa fa-chevron-left"></i> 18.高性能MySQL(四)</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/13.HTTP长连接和短连接.html" rel="prev" title="13.HTTP长连接和短链接">13.HTTP长连接和短链接 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="bdsharebuttonbox"><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a> <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a> <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a> <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a> <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a> <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a> <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a> <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a> <a href="#" class="bds_more" data-cmd="more"></a> <a class="bds_count" data-cmd="count"></a></div><script>window._bd_share_config={common:{bdText:"",bdMini:"2",bdMiniList:!1,bdPic:""},share:{bdSize:"16",bdStyle:"0"},image:{viewList:["tsina","douban","sqq","qzone","weixin","twi","fbook"],viewText:"分享到：",viewSize:"16"}}</script><script>with(document)0[(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="//bdimg.share.baidu.com/static/api/js/share.js?cdnversion="+~(-new Date/36e5)]</script></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://5b0988e595225.cdn.sohucs.com/images/20171030/26ed195281334ba4b1752394b60eb29a.jpeg" alt="川总"><p class="site-author-name" itemprop="name">川总</p><p class="site-description motion-element" itemprop="description">Talk is cheap.<br>Show me your code.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">28</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/quietAny" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://me.csdn.net/qq_42926943" target="_blank" title="CSDN"><i class="fa fa-fw fa-copyright"></i>CSDN</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://poohbear.club/" title="Miracle" target="_blank">Miracle</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、为什么查询速度会慢"><span class="nav-number">1.</span> <span class="nav-text">一、为什么查询速度会慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、慢查询基础：优化数据访问"><span class="nav-number">2.</span> <span class="nav-text">二、慢查询基础：优化数据访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#是否向数据库请求了不需要的数据"><span class="nav-number">2.1.</span> <span class="nav-text">是否向数据库请求了不需要的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#查询不需要的记录"><span class="nav-number">2.1.1.</span> <span class="nav-text">查询不需要的记录</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多表联查时返回全部列"><span class="nav-number">2.1.2.</span> <span class="nav-text">多表联查时返回全部列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总是取出全部列"><span class="nav-number">2.1.3.</span> <span class="nav-text">总是取出全部列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重复查询相同的数据"><span class="nav-number">2.1.4.</span> <span class="nav-text">重复查询相同的数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL是否在扫描额外的记录"><span class="nav-number">2.2.</span> <span class="nav-text">MySQL是否在扫描额外的记录</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#响应时间"><span class="nav-number">2.2.1.</span> <span class="nav-text">响应时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#扫描的行数和返回的行数"><span class="nav-number">2.2.2.</span> <span class="nav-text">扫描的行数和返回的行数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#扫描的行数和访问类型"><span class="nav-number">2.2.3.</span> <span class="nav-text">扫描的行数和访问类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、重构查询的方式"><span class="nav-number">3.</span> <span class="nav-text">三、重构查询的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一个复杂查询还是多个简单查询"><span class="nav-number">3.1.</span> <span class="nav-text">一个复杂查询还是多个简单查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#切分查询"><span class="nav-number">3.2.</span> <span class="nav-text">切分查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分解关联查询"><span class="nav-number">3.3.</span> <span class="nav-text">分解关联查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点："><span class="nav-number">3.3.1.</span> <span class="nav-text">优点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、查询执行的基础"><span class="nav-number">4.</span> <span class="nav-text">四、查询执行的基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL客户端-服务器通信协议。"><span class="nav-number">4.1.</span> <span class="nav-text">MySQL客户端/服务器通信协议。</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#查询状态"><span class="nav-number">4.1.1.</span> <span class="nav-text">查询状态</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询缓存"><span class="nav-number">4.2.</span> <span class="nav-text">查询缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询优化处理"><span class="nav-number">4.3.</span> <span class="nav-text">查询优化处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#语法解析器和预处理"><span class="nav-number">4.3.1.</span> <span class="nav-text">语法解析器和预处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查询优化器"><span class="nav-number">4.3.2.</span> <span class="nav-text">查询优化器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据和索引的统计信息"><span class="nav-number">4.3.3.</span> <span class="nav-text">数据和索引的统计信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MySQL如何执关联查询"><span class="nav-number">4.3.4.</span> <span class="nav-text">MySQL如何执关联查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#关联查询优化器"><span class="nav-number">4.3.5.</span> <span class="nav-text">关联查询优化器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#排序优化"><span class="nav-number">4.3.6.</span> <span class="nav-text">排序优化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询执行引擎"><span class="nav-number">4.4.</span> <span class="nav-text">查询执行引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回结果给客户端"><span class="nav-number">4.5.</span> <span class="nav-text">返回结果给客户端</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、MySQL查询优化器的局限性"><span class="nav-number">5.</span> <span class="nav-text">五、MySQL查询优化器的局限性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关联子查询"><span class="nav-number">5.1.</span> <span class="nav-text">关联子查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UNION的限制"><span class="nav-number">5.2.</span> <span class="nav-text">UNION的限制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#等值传递"><span class="nav-number">5.3.</span> <span class="nav-text">等值传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行执行"><span class="nav-number">5.4.</span> <span class="nav-text">并行执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希关联"><span class="nav-number">5.5.</span> <span class="nav-text">哈希关联</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#松散索引扫描"><span class="nav-number">5.6.</span> <span class="nav-text">松散索引扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最大值和最小值优化"><span class="nav-number">5.7.</span> <span class="nav-text">最大值和最小值优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、优化特定类型的查询"><span class="nav-number">6.</span> <span class="nav-text">六、优化特定类型的查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优化COUNT-查询"><span class="nav-number">6.1.</span> <span class="nav-text">优化COUNT()查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#COUNT-的作用："><span class="nav-number">6.1.1.</span> <span class="nav-text">COUNT()的作用：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#关于MyISAM的神话"><span class="nav-number">6.1.2.</span> <span class="nav-text">关于MyISAM的神话</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#简单的优化"><span class="nav-number">6.1.3.</span> <span class="nav-text">简单的优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用近似值"><span class="nav-number">6.1.4.</span> <span class="nav-text">使用近似值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#更复杂的优化"><span class="nav-number">6.1.5.</span> <span class="nav-text">更复杂的优化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化关联查询"><span class="nav-number">6.2.</span> <span class="nav-text">优化关联查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化子查询"><span class="nav-number">6.3.</span> <span class="nav-text">优化子查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化GROUP-BY和DISTINCT"><span class="nav-number">6.4.</span> <span class="nav-text">优化GROUP BY和DISTINCT</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优化GROUP-BY-WITH-ROLLUP"><span class="nav-number">6.4.1.</span> <span class="nav-text">优化GROUP BY WITH ROLLUP</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化LIMIT分页。"><span class="nav-number">6.5.</span> <span class="nav-text">优化LIMIT分页。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化-SQL-CALC-FOUND-ROWS"><span class="nav-number">6.6.</span> <span class="nav-text">优化 SQL_CALC_FOUND_ROWS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化UNION查询"><span class="nav-number">6.7.</span> <span class="nav-text">优化UNION查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态查询分析"><span class="nav-number">6.8.</span> <span class="nav-text">静态查询分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用用户自定义变量"><span class="nav-number">6.9.</span> <span class="nav-text">使用用户自定义变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#下面情况无法使用自定义变量"><span class="nav-number">6.9.1.</span> <span class="nav-text">下面情况无法使用自定义变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用场景"><span class="nav-number">6.9.2.</span> <span class="nav-text">使用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、案例学习"><span class="nav-number">7.</span> <span class="nav-text">七、案例学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用MySQL构建一个队列表"><span class="nav-number">7.1.</span> <span class="nav-text">使用MySQL构建一个队列表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基础原则："><span class="nav-number">7.1.1.</span> <span class="nav-text">基础原则：</span></a></li></ol></li></ol></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">川总</span></div><span id="sitetime"></span><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=1e3,t=60*e,o=60*t,i=24*o,a=365*i,n=new Date,r=n.getFullYear(),l=n.getMonth()+1,s=n.getDate(),M=n.getHours(),g=n.getMinutes(),m=n.getSeconds(),T=Date.UTC(2019,6,18,15,0,0),f=Date.UTC(r,l,s,M,g,m),h=f-T,u=Math.floor(h/a),d=Math.floor(h/i-365*u),D=Math.floor((h-(365*u+d)*i)/o),c=Math.floor((h-(365*u+d)*i-D*o)/t),w=Math.floor((h-(365*u+d)*i-D*o-c*t)/e);document.getElementById("sitetime").innerHTML=" 已运行"+d+" 天 "+D+" 小时 "+c+" 分钟 "+w+" 秒"}siteTime()</script><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv">本站访客数 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人次 </span><span class="site-pv">本站总访问量 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="/live2d-widget/autoload.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'to5fDrBPDdv6UnQXr1iwYrmS-gzGzoHsz',
        appKey: 'oGnbboaGKW9oPhGGcher6ig7',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("to5fDrBPDdv6UnQXr1iwYrmS-gzGzoHsz","oGnbboaGKW9oPhGGcher6ig7")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var i=0;i<e.length;i++){var r=e[i],s=r.get("url"),l=r.get("time"),c=document.getElementById(s);$(c).find(t).text(l)}for(var i=0;i<n.length;i++){var s=n[i],c=document.getElementById(s),u=$(c).find(t);""==u.text()&&u.text(0)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var r=new e,s=new AV.ACL;s.setPublicReadAccess(!0),s.setPublicWriteAccess(!0),r.setACL(s),r.set("title",o),r.set("url",n),r.set("time",1),r.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script><script type="text/javascript" src="/js/src/love.js"></script></body></html><!-- rebuild by neat -->